#ifndef __TILE_DRIVER_H__
#define __TILE_DRIVER_H__

#include "tile_isp_reg.h"/* must */
#include "tile_mdp_reg.h"/* must */

#define TILE_PLATFORM_DRIVER /* to change define with platform unique */

//#define TILE_NEW_ENG_TEST/* for new tile engine check only */
//#define TILE_DIRECT_LINK_CMODEL_TEST /* to change define with platform unique */
//#define TILE_CAL_DUMP_ORDER_TEST/* tile cal & dump order */
//#define TILE_ENABLE_UFD_FULL_X_TEST/* for ufd debug only */
//#define TILE_ENABLE_UFD_FULL_Y_TEST/* for ufd debug only */
//#define TILE_ENABLE_UFD_NO_COMP_TEST/* for ufd debug only */

/* DIRECT_LINK FUNC NUM, can assign to different functions */
#define TILE_DIRECT_LINK_FUNC_NUM	TILE_FUNC_MDP_CROP_ID
//#define TILE_DIRECT_LINK_FUNC_NUM	TILE_FUNC_IMG2O_ID
//#define TILE_DIRECT_LINK_FUNC_NUM	TILE_FUNC_IMG3O_ID
//#define TILE_DIRECT_LINK_FUNC_NUM	TILE_FUNC_MDP_CROP2_ID
#define TILE_DIRECT_LINK_FUNC_NUM_WPE	TILE_FUNC_WPE_MDP_CROP_ID

#if defined(_MSC_VER)
#include <conio.h> 
#define tile_kbhit() _kbhit()
#define tile_stricmp                                             _stricmp
#define TILE_FOLDER_SYMBOL_STR                                       "\\"
#define TILE_FOLDER_SYMBOL_CHAR                                      '\\'
#define tile_sprintf(dst_ptr, size_dst, format, ...)             sprintf_s(dst_ptr, size_dst, format, __VA_ARGS__)
#define tile_fopen(file_ptr, filename_ptr, mode)                 fopen_s(&file_ptr, filename_ptr, mode)
#define tile_fscanf                                              fscanf_s
#define TILE_MOVE_CMD                                                "move"
#define TILE_CMP_CMD                                                 "fc"
#define TILE_DEL_CMD                                                 "del"
#define TILE_COPY_CMD                                                 "copy"
#define tile_sscanf_1(...)                                sscanf_s(__VA_ARGS__)
#define tile_sscanf_2(...)                          sscanf_s(__VA_ARGS__)
#define tile_sscanf_4(...)                          sscanf_s(__VA_ARGS__)
#define tile_sscanf_8(...)                          sscanf_s(__VA_ARGS__)
#define tile_sscanf_12(...)                          sscanf_s(__VA_ARGS__)
#define TILE_SAVE_FILE_FIRST_DIR ".\\tile_conf\\"
#define TILE_SAVE_FILE_SECOND_DIR ".\\"
#define tile_localtime(a, b)	localtime_s(a, b)
#elif defined(linux) || defined(__linux) || defined(__arm__)
#define tile_kbhit() true
#define tile_stricmp                                             strcasecmp
#define TILE_FOLDER_SYMBOL_STR                                       "/"
#define TILE_FOLDER_SYMBOL_CHAR                                      '/'
#define tile_sprintf(dst_ptr, size_dst, ...)                     sprintf(dst_ptr, __VA_ARGS__)
#define tile_fopen(file_ptr, filename_ptr, mode)                 file_ptr = fopen(filename_ptr, mode)
#define tile_fscanf                                              fscanf
#define TILE_MOVE_CMD                                                "mv"
#define TILE_CMP_CMD                                                 "cmp"
#define TILE_DEL_CMD                                                 "rm"
#define TILE_COPY_CMD                                                 "cp"
#define tile_sscanf_1(x, y, a, b)                                sscanf(x, y, a)
#define tile_sscanf_2(x, y, a, b, c, d)                          sscanf(x, y, a, b)
#define tile_sscanf_4(x, y, a, b, c, d, e, f, g, h)           sscanf(x, y, a, b, c, d)
#define tile_sscanf_8(x, y, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)	sscanf(x, y, a, b, c, d, e, f, g, h)
#define tile_sscanf_12(x, y, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, z)	sscanf(x, y, a, b, c, d, e, f, g, h, i, j, k, l)
#define TILE_SAVE_FILE_FIRST_DIR "./tile_conf/"
#define TILE_SAVE_FILE_SECOND_DIR "./"
#define O_BINARY (0)
#define tile_localtime(a, b) \
{\
	struct tm *TM_TEMP;\
	TM_TEMP = localtime(b);\
	memcpy(a, TM_TEMP, sizeof(struct tm));\
}\

#else
#error("Non-supported c compiler environment\r\n") 
#endif

#if 0//def TILE_PLATFORM_DRIVER
#if defined(_MSC_VER)           // VC
#define tile_driver_printf printf_prefix
#define tile_driver_printf_no_prefix printf
#define uart_printf printf
#elif defined(linux) || defined(__linux) //Linux
#if defined(__arm__) || defined(__aarch64__) //arm
//#define tile_driver_printf(...)
//#define tile_driver_printf_no_prefix(...)
#define NEW_LINE_CHAR   "\n"
#if defined(USING_MTK_LDVT)     // LDVT
#pragma message("LDVT environment")
#include "uvvf.h"
#define tile_driver_printf(...)
#define tile_driver_printf_no_prefix(...)
#define uart_printf(fmt, arg...) printf("[] " fmt, ##arg)
#else //not LDVT
//#pragma message("FPGA/EVB/Phone environment")
#include <android/log.h>        // Android
#define tile_driver_printf(fmt, ...) ((void)__android_log_print(ANDROID_LOG_DEBUG, "MDP/T", "[%s][%d] " fmt, __FILE__, __LINE__, ##__VA_ARGS__))
#define tile_driver_printf_no_prefix(fmt, ...) ((void)__android_log_print(ANDROID_LOG_DEBUG, "MDP/T", fmt, ##__VA_ARGS__))
#define uart_printf(fmt, ...) ((void)__android_log_print(ANDROID_LOG_DEBUG, "MDP/T", "[] " fmt, ##__VA_ARGS__))
#endif //END LDVT
#else //not arm
#define tile_driver_printf printf_prefix
#define tile_driver_printf_no_prefix printf
#define uart_printf printf
#endif //END platform
#endif //END VC
#else
#define tile_driver_printf printf_prefix
#define tile_driver_printf_no_prefix printf
#define uart_printf printf
#endif

#define MAX_TILE_SIZE (8192)

#ifdef TILE_PLATFORM_DRIVER
#define MAX_TILE_WIDTH_HW (768)
#define MAX_TILE_WIDTH 0 /* 0: read tile width from INIT_PROPERTY_LUT, MAX_TILE_WIDTH_HW: unified HW tile width */
#define MAX_TILE_WIDTH_HW_WPE (512)
#define MAX_TILE_WIDTH_WPE 0 /* 0: read tile width from INIT_PROPERTY_LUT, MAX_TILE_WIDTH_HW_WPE: unified HW tile width */
#define MAX_TILE_WIDTH_HW_EAF (512) /* 0: read tile width from INIT_PROPERTY_LUT, 512: unified HW tile width */
#define MAX_TILE_WIDTH_EAF 0 /* 0: read tile width from INIT_PROPERTY_LUT, MAX_TILE_WIDTH_HW_EAF: unified HW tile width */
#define MAX_TILE_WIDTH_HW_BLD (256) /* 0: read tile width from INIT_PROPERTY_LUT, 256: unified HW tile width */
#define MAX_TILE_WIDTH_BLD MAX_TILE_WIDTH_HW_BLD /* 0: read tile width from INIT_PROPERTY_LUT, MAX_TILE_WIDTH_HW_BLD: unified HW tile width */
#define MAX_TILE_HEIGHT_HW (8192)
#define MAX_TILE_TOT_NO (1200)
#define MAX_ISP_DUMP_HEX_PER_TILE (256)
#define MAX_ISP_MASK_HEX_PER_TILE (300)
#define MAX_ISP_DUMP_HEX_PER_TILE_WPE (32)
#define MAX_ISP_MASK_HEX_PER_TILE_WPE (32)
#define MAX_ISP_DUMP_HEX_PER_TILE_EAF (64)
#define MAX_ISP_MASK_HEX_PER_TILE_EAF (64)
#define MAX_ISP_DUMP_HEX_PER_TILE_BLD (64)
#define MAX_ISP_MASK_HEX_PER_TILE_BLD (64)
#define MAX_ISP_TILE_TDR_HEX_NO (MAX_TILE_TOT_NO*MAX_ISP_DUMP_HEX_PER_TILE)
#define MAX_ISP_TILE_TDR_HEX_NO_WPE (MAX_TILE_TOT_NO*MAX_ISP_DUMP_HEX_PER_TILE_WPE)
#define MAX_ISP_TILE_TDR_HEX_NO_EAF (MAX_TILE_TOT_NO*MAX_ISP_DUMP_HEX_PER_TILE_EAF)
#define MAX_ISP_TILE_TDR_HEX_NO_BLD (MAX_TILE_TOT_NO*MAX_ISP_DUMP_HEX_PER_TILE_BLD)
#define MAX_ISP_DUMP_HEX_PER_TILE_INTERNAL (128)
#define MAX_ISP_MASK_HEX_PER_TILE_INTERNAL (128)
#define MAX_ISP_DUMP_HEX_PER_TILE_INTERNAL_WPE (32)
#define MAX_ISP_MASK_HEX_PER_TILE_INTERNAL_WPE (32)
#define MAX_ISP_DUMP_HEX_PER_TILE_INTERNAL_EAF (32)
#define MAX_ISP_MASK_HEX_PER_TILE_INTERNAL_EAF (32)
#define MAX_ISP_DUMP_HEX_PER_TILE_INTERNAL_BLD (32)
#define MAX_ISP_MASK_HEX_PER_TILE_INTERNAL_BLD (32)
#define MAX_ISP_TILE_TDR_HEX_NO_INTERNAL (MAX_TILE_TOT_NO*MAX_ISP_DUMP_HEX_PER_TILE_INTERNAL)
#define MAX_ISP_TILE_TDR_HEX_NO_INTERNAL_WPE (MAX_TILE_TOT_NO*MAX_ISP_DUMP_HEX_PER_TILE_INTERNAL_WPE)
#define MAX_ISP_TILE_TDR_HEX_NO_INTERNAL_EAF (MAX_TILE_TOT_NO*MAX_ISP_DUMP_HEX_PER_TILE_INTERNAL_EAF)
#define MAX_ISP_TILE_TDR_HEX_NO_INTERNAL_BLD (MAX_TILE_TOT_NO*MAX_ISP_DUMP_HEX_PER_TILE_INTERNAL_BLD)
#define MAX_TDR_REGISTER_STRING_LENGTH (4)
#define MAX_TILE_PREV_NO (4)
#define MAX_TILE_BRANCH_NO (4)
#define MIN_TILE_FUNC_NO (3)
#define MIN_TDR_WORD_NO (4)
#define MAX_TILE_FUNC_NO (96) /* smaller or equal to (PREVIOUS_BLK_NO_OF_START-1) */
#define MAX_INPUT_TILE_FUNC_NO (10)
#define MAX_FORWARD_FUNC_CAL_LOOP_NO (16*MAX_TILE_FUNC_NO)
#define MAX_TILE_FUNC_EN_NO (128)
#define MAX_TILE_FUNC_SUBRDMA_NO (24)
#define MAX_SUBRDMA_NO (24)
#define MAX_TILE_FUNC_NAME_SIZE (16)
#else
#define MAX_TILE_WIDTH_HW (768)
#define MAX_TILE_WIDTH 0/* 0: read tile width from INIT_PROPERTY_LUT, MAX_TILE_WIDTH_HW: unified HW tile width */
#define MAX_TILE_WIDTH_HW_WPE (512)
#define MAX_TILE_WIDTH_WPE 0 /* 0: read tile width from INIT_PROPERTY_LUT, MAX_TILE_WIDTH_HW_WPE: unified HW tile width */
#define MAX_TILE_WIDTH_HW_EAF (512) /* 0: read tile width from INIT_PROPERTY_LUT, 512: unified HW tile width */
#define MAX_TILE_WIDTH_EAF 0 /* 0: read tile width from INIT_PROPERTY_LUT, MAX_TILE_WIDTH_HW_EAF: unified HW tile width */
#define MAX_TILE_WIDTH_HW_BLD (256) /* 0: read tile width from INIT_PROPERTY_LUT, 256: unified HW tile width */
#define MAX_TILE_WIDTH_BLD MAX_TILE_WIDTH_HW_BLD /* 0: read tile width from INIT_PROPERTY_LUT, MAX_TILE_WIDTH_HW_BLD: unified HW tile width */
#define MAX_TILE_HEIGHT_HW (8192)
#define MAX_TILE_TOT_NO (1200)
#define MAX_ISP_DUMP_HEX_PER_TILE (256)
#define MAX_ISP_MASK_HEX_PER_TILE (300)
#define MAX_ISP_DUMP_HEX_PER_TILE_WPE (32)
#define MAX_ISP_MASK_HEX_PER_TILE_WPE (32)
#define MAX_ISP_DUMP_HEX_PER_TILE_EAF (64)
#define MAX_ISP_MASK_HEX_PER_TILE_EAF (64)
#define MAX_ISP_DUMP_HEX_PER_TILE_BLD (64)
#define MAX_ISP_MASK_HEX_PER_TILE_BLD (64)
#define MAX_ISP_TILE_TDR_HEX_NO (MAX_TILE_TOT_NO*MAX_ISP_DUMP_HEX_PER_TILE)
#define MAX_ISP_TILE_TDR_HEX_NO_WPE (MAX_TILE_TOT_NO*MAX_ISP_DUMP_HEX_PER_TILE_WPE)
#define MAX_ISP_TILE_TDR_HEX_NO_EAF (MAX_TILE_TOT_NO*MAX_ISP_DUMP_HEX_PER_TILE_EAF)
#define MAX_ISP_TILE_TDR_HEX_NO_BLD (MAX_TILE_TOT_NO*MAX_ISP_DUMP_HEX_PER_TILE_BLD)
#define MAX_ISP_DUMP_HEX_PER_TILE_INTERNAL (128)
#define MAX_ISP_MASK_HEX_PER_TILE_INTERNAL (128)
#define MAX_ISP_DUMP_HEX_PER_TILE_INTERNAL_WPE (32)
#define MAX_ISP_MASK_HEX_PER_TILE_INTERNAL_WPE (32)
#define MAX_ISP_DUMP_HEX_PER_TILE_INTERNAL_EAF (32)
#define MAX_ISP_MASK_HEX_PER_TILE_INTERNAL_EAF (32)
#define MAX_ISP_DUMP_HEX_PER_TILE_INTERNAL_BLD (32)
#define MAX_ISP_MASK_HEX_PER_TILE_INTERNAL_BLD (32)
#define MAX_ISP_TILE_TDR_HEX_NO_INTERNAL (MAX_TILE_TOT_NO*MAX_ISP_DUMP_HEX_PER_TILE_INTERNAL)
#define MAX_ISP_TILE_TDR_HEX_NO_INTERNAL_WPE (MAX_TILE_TOT_NO*MAX_ISP_DUMP_HEX_PER_TILE_INTERNAL_WPE)
#define MAX_ISP_TILE_TDR_HEX_NO_INTERNAL_EAF (MAX_TILE_TOT_NO*MAX_ISP_DUMP_HEX_PER_TILE_INTERNAL_EAF)
#define MAX_ISP_TILE_TDR_HEX_NO_INTERNAL_BLD (MAX_TILE_TOT_NO*MAX_ISP_DUMP_HEX_PER_TILE_INTERNAL_BLD)
#define MAX_TDR_REGISTER_STRING_LENGTH (4)
#define MAX_TILE_PREV_NO (4)
#define MAX_TILE_BRANCH_NO (4)
#define MIN_TILE_FUNC_NO (3)
#define MIN_TDR_WORD_NO (4)
#define MAX_TILE_FUNC_NO (96) /* smaller or equal to (PREVIOUS_BLK_NO_OF_START-1) */
#define MAX_INPUT_TILE_FUNC_NO (10)
#define MAX_FORWARD_FUNC_CAL_LOOP_NO (16*MAX_TILE_FUNC_NO)
#define MAX_TILE_FUNC_EN_NO (128)
#define MAX_TILE_FUNC_SUBRDMA_NO (24)
#define MAX_SUBRDMA_NO (24)
#define MAX_TILE_FUNC_NAME_SIZE (16)
#endif

/* common define */
#ifndef __cplusplus
#ifndef bool
#define bool unsigned char
#define HAVE_BOOL 1
#endif
#ifndef true
#define true 1
#endif
#ifndef false
#define false 0
#endif
#endif

#define TILE_MOD(num, denom) (((denom)==1)?0:(((denom)==2)?((num)&0x1):(((denom)==4)?\
	((num)&0x3):(((denom)==8)?((num)&0x7):((num)%(denom))))))
#define TILE_INT_DIV(num, denom) (((denom)==1)?(num):(((denom)==2)?((unsigned int)(num)>>0x1):\
	(((denom)==4)?((unsigned int)(num)>>0x2):(((denom)==8)?((unsigned int)(num)>>0x3):((num)/(denom))))))\

#define TILE_SEL_DIP_A (0x1)
#define TILE_SEL_DIP_B (0x2)
#define TILE_SEL_DIP_C (0x4)
#define TILE_SEL_DIP_D (0x8)
#define TILE_SEL_WPE_A (0x10)
#define TILE_SEL_WPE_B (0x20)
#define TILE_SEL_WPE2_A (0x100)
#define TILE_SEL_EAF_A (0x1000)
#define TILE_SEL_MDP_A (0x10000)
#define TILE_SEL_BLD_A (0x100000)
#define TILE_SEL_COUNT (TILE_SEL_COUNT_A + TILE_SEL_COUNT_B)
#define TILE_SEL_COUNT_A ((TILE_SEL_DIP_A?1:0) + (TILE_SEL_WPE_A?1:0) + (TILE_SEL_WPE2_A?1:0) + (TILE_SEL_EAF_A?1:0) + (TILE_SEL_BLD_A?1:0))
#define TILE_SEL_COUNT_B ((TILE_SEL_DIP_B?1:0) + (TILE_SEL_WPE_B?1:0))
#define TILE_SEL_COUNT_DIP ((TILE_SEL_DIP_A?1:0) + (TILE_SEL_DIP_B?1:0))
#define TILE_SEL_COUNT_WPE ((TILE_SEL_WPE_A?1:0) + (TILE_SEL_WPE_B?1:0))
#define TILE_SEL_COUNT_WPE2 (TILE_SEL_WPE2_A?1:0)
#define TILE_SEL_COUNT_EAF (TILE_SEL_EAF_A?1:0)
#define TILE_SEL_COUNT_BLD (TILE_SEL_BLD_A?1:0)
#define TILE_SEL_SUM (TILE_SEL_SUM_A | TILE_SEL_SUM_B)
#define TILE_SEL_SUM_A (TILE_SEL_DIP_A | TILE_SEL_WPE_A | TILE_SEL_WPE2_A | TILE_SEL_EAF_A | TILE_SEL_BLD_A)
#define TILE_SEL_SUM_B (TILE_SEL_DIP_B | TILE_SEL_WPE_B)
#define TILE_SEL_SUM_DIP (TILE_SEL_DIP_A | TILE_SEL_DIP_B)
#define TILE_SEL_SUM_WPE (TILE_SEL_WPE_A | TILE_SEL_WPE_B)
#define TILE_SEL_SUM_WPE2 (TILE_SEL_WPE2_A)
#define TILE_SEL_SUM_EAF (TILE_SEL_EAF_A)
#define TILE_SEL_SUM_BLD (TILE_SEL_BLD_A)
#define TILE_SEL_DIP_FIRST(tile_group) (((tile_group) & TILE_SEL_DIP_A)?TILE_SEL_DIP_A:(((tile_group) & TILE_SEL_DIP_B)?TILE_SEL_DIP_A:0))
#define TILE_SEL_WPE_FIRST(tile_group) (((tile_group) & TILE_SEL_WPE_A)?TILE_SEL_WPE_A:(((tile_group) & TILE_SEL_WPE_B)?TILE_SEL_WPE_B:0))
#define TILE_SEL_WPE2_FIRST(tile_group) (((tile_group) & TILE_SEL_WPE2_A)?TILE_SEL_WPE2_A:0)
#define TILE_SEL_EAF_FIRST(tile_group) (((tile_group) & TILE_SEL_EAF_A)?TILE_SEL_EAF_A:0)
#define TILE_SEL_BLD_FIRST(tile_group) (((tile_group) & TILE_SEL_BLD_A)?TILE_SEL_BLD_A:0)
#define TILE_SEL_GROUP_COUNT(tile_group) (((tile_group) & TILE_SEL_SUM_A)?1:0) + (((tile_group) & TILE_SEL_SUM_B)?1:0)

/* PLATFORM parameters */
/* a, b, c, d, e, f reserved */
/* support mode */
#define TILE_SEL_SUPPORT_LIST(CMD, a, b, c, d, e, f) \
	CMD(a, b, c, d, e, f, 0x1)/* 0001, DIP_A */\
	CMD(a, b, c, d, e, f, 0x2)/* 0002, DIP_B */\
	CMD(a, b, c, d, e, f, 0x3)/* 0003,  DIP_A+DIP_B */\
	CMD(a, b, c, d, e, f, 0x10)/* 0010, WPE_A */\
	CMD(a, b, c, d, e, f, 0x20)/* 0020, WPE_B */\
	CMD(a, b, c, d, e, f, 0x30)/* 0030, WPE_A+WPE_B */\
	CMD(a, b, c, d, e, f, 0x11)/* 0111, DIP_A+WPE_A */\
	CMD(a, b, c, d, e, f, 0x1000)/* 1000, EAF_A */\
	CMD(a, b, c, d, e, f, 0x1001)/* 1001, EAF_A+DIP_A for test only */\
	CMD(a, b, c, d, e, f, 0x10001)/* 10001, DIP_A+MDP_A */\
	CMD(a, b, c, d, e, f, 0x10010)/* 10010, WPE_A+MDP_A */\
	CMD(a, b, c, d, e, f, 0x10011)/* 10111, WPE_A+DIP_A+MDP_A */\
	CMD(a, b, c, d, e, f, 0x100000)/* 100000, BLD_A */\
	CMD(a, b, c, d, e, f, 0x100001)/* 100001, BLD_A+DIP_A for test only */\

#define TILE_SEL_CHECK(a, b, c, d, e, f, g,...) \
	if (false == (b))\
	{\
		if ((a) == g)\
		{\
			(b) = true;\
		}\
	}\

#define TILE_ORDER_Y_FIRST (0x1)
#define TILE_ORDER_RIGHT_TO_LEFT (0x2)
#define TILE_ORDER_BOTTOM_TO_TOP (0x4)

#define TILE_DUAL_DISPATCH_INTERLACE (0x0)
#define TILE_DUAL_DISPATCH_SPLIT (0x1)

/* normalized offset up to 20 bits */
#define REZ_OFFSET_SHIFT_VAL (1<<20)
#define REZ_OFFSET_SHIFT_FACTOR (20)
#define SRZ_OFFSET_SHIFT_VAL (1<<15)
#define SRZ_OFFSET_SHIFT_FACTOR (15)
#define VGEN_OFFSET_SHIFT_VAL (1<<24)
#define VGEN_OFFSET_SHIFT_FACTOR (24)
#define TILE_MAX_PATHNAME_LENGTH (256)
#define TILE_MAX_FILENAME_LENGTH (128)
#define TILE_MAX_COMMAND_LENGTH (512)
#define MAX_DUMP_COLUMN_LENGTH (1024)
#define MIN_MCU_BUFFER_NO (2)
#define PREVIOUS_BLK_NO_OF_START (0xFF)

/* debug log dump & parse */
#define TILE_DEBUG_DUMP_VERSION "V.0.0.0.1"
#define TILE_DEBUG_DUMP_VERSION_START_CHAR 'V'
#define TILE_DEBUG_DUMP_VERSION_SIZE (sizeof(TILE_DEBUG_DUMP_VERSION))
/* must be size of TILE_DEBUG_DUMP_VERSION */
#define TILE_DEBUG_EQUAL_SYMBOL_CHR '='
#define TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR " = "

/* Direct-link dump & parse */
#define TILE_RDMA_DUMP_ADDR "+0x"
#define TILE_RDMA_DUMP_VAL "=0x"

/* 4 bytes alignment */
#define TILE_4_BYTES_PENDING(x) (((x) & 0x3)?((x) + 4 - ((x) & 0x3)):(x))

/* macro for debug print to file, #include <stdio.h> */
#define printf_prefix(...) {\
    const char *ptr_char = get_current_file_name(__FILE__);\
    printf("[%s][%s][%d] ", ptr_char,  __FUNCTION__, __LINE__);\
    printf(__VA_ARGS__);\
}

/* TILE RUN DPFRAMEWORK */
typedef enum TILE_CAL_MAIN_DP_ENUM
{
    TILE_CAL_MAIN_DP_INIT_FUNC_PROP=0,
    TILE_CAL_MAIN_DP_INIT_FRAME_MODE,
    TILE_CAL_MAIN_DP_CLOSE_FRAME_MODE,
    TILE_CAL_MAIN_DP_INIT_TILE_MODE,
    TILE_CAL_MAIN_DP_CLOSE_TILE_MODE,
    TILE_CAL_MAIN_DP_MAX_NO
}TILE_CAL_MAIN_DP_ENUM;

/* last_irq_mode */
typedef enum TILE_LAST_IRQ_MODE_ENUM
{
    TILE_LAST_IRQ_FRAME_STOP=0,
    TILE_LAST_IRQ_LINE_END,
    TILE_LAST_IRQ_PER_TILE,
    TILE_LAST_IRQ_MODE_MAX_NO
}TILE_LAST_IRQ_MODE_ENUM;

/* MAX TILE WIDTH & HEIGHT */
#define MAX_SIZE (65536)

/* TILE HORIZONTAL BUFFER */
#define MAX_TILE_BACKUP_HORZ_NO (24)

/* Tile edge */
#define TILE_EDGE_BOTTOM_MASK (0x8)
#define TILE_EDGE_TOP_MASK (0x4)
#define TILE_EDGE_RIGHT_MASK (0x2)
#define TILE_EDGE_LEFT_MASK (0x1)
#define TILE_EDGE_HORZ_MASK (TILE_EDGE_RIGHT_MASK + TILE_EDGE_LEFT_MASK)

typedef enum TILE_FUNC_ID_ENUM
{
	LAST_MODULE_ID_OF_START = (0xFFFFFFF),
	NULL_TILE_ID  = (0xFFFFFFF),
	/* isp func id */
	TILE_FUNC_IMGI_ID = (1001),
	TILE_FUNC_IMGBI_ID = (1002),
	TILE_FUNC_IMGCI_ID = (1003),
	TILE_FUNC_UFDI_ID = (1013),
	TILE_FUNC_UNP_ID = (98),
	TILE_FUNC_UFDG_ID = (216),
	TILE_FUNC_UFD_ID = (916),
	TILE_FUNC_DCPN2_ID = (2044),
	TILE_FUNC_LSC2_ID = (2045),
	TILE_FUNC_CPN2_ID = (2046),
	TILE_FUNC_SL2_ID = (213),
	TILE_FUNC_RNR_ID = (158),
	TILE_FUNC_UDM_ID = (58),
	TILE_FUNC_C24_ID = (92),
	TILE_FUNC_VIPI_ID = (1010),
	TILE_FUNC_VIP2I_ID = (1011),
	TILE_FUNC_VIP3I_ID = (1012),
	TILE_FUNC_PAK2O_ID = (1041),
	TILE_FUNC_G2C_ID = (4),
	TILE_FUNC_C42_ID = (51),
	TILE_FUNC_SL2B_ID = (218),
	TILE_FUNC_NBC_ID = (209),
	TILE_FUNC_NBC_PAD_ID = (210),
	TILE_FUNC_NBC_LTM_ID = (212),
	TILE_FUNC_NBC2_ID = (2209),
	TILE_FUNC_SRZ1_ID = (241),
	TILE_FUNC_MIX1_ID = (231),
	TILE_FUNC_SRZ2_ID = (242),
	TILE_FUNC_SRZ3_ID = (243),
	TILE_FUNC_SRZ4_ID = (244),
	TILE_FUNC_SRZ6_ID = (246),
	TILE_FUNC_PCA_ID = (205),
	TILE_FUNC_MIX2_ID = (232),
	TILE_FUNC_SL2C_ID = (219),
	TILE_FUNC_SL2C_CROP_ID = (2219),
	TILE_FUNC_SL2D_ID = (220),
	TILE_FUNC_SL2E_ID = (221),
	TILE_FUNC_SL2H_ID = (222),
	TILE_FUNC_SL2H_CROP_ID = (223),
	TILE_FUNC_SEEE_ID = (211),
	TILE_FUNC_LCEI_ID = (1005),
	TILE_FUNC_LCE_ID = (217),
	TILE_FUNC_MIX3_ID = (233),
	TILE_FUNC_MIX4_ID = (234),
	TILE_FUNC_CDRZ_ID = (276),
	TILE_FUNC_DMGI_ID = (2076),
	TILE_FUNC_DEPI_ID = (2077),
	TILE_FUNC_IMG2O_ID = (1028),
	TILE_FUNC_IMG2BO_ID = (1029),
	TILE_FUNC_FE_ID = (302),
	TILE_FUNC_FEO_ID = (1033),
	TILE_FUNC_C02_ID = (61),
	TILE_FUNC_C02B_ID = (6061),
	TILE_FUNC_NR3D_ID = (23),
	TILE_FUNC_CRSP_ID = (258),
	TILE_FUNC_IMG3O_ID = (1037),
	TILE_FUNC_IMG3BO_ID = (1038),
	TILE_FUNC_IMG3CO_ID = (1039),
	TILE_FUNC_C24B_ID = (292),
	TILE_FUNC_MDP_CROP_ID = (296),
	TILE_FUNC_MDP_CROP2_ID = (297),
	TILE_FUNC_PLNR1_ID = (3001),
	TILE_FUNC_PLNR2_ID = (3002),
	TILE_FUNC_PLNW1_ID = (3003),
	TILE_FUNC_PLNW2_ID = (3004),
	TILE_FUNC_DBS2_ID = (3005),
	TILE_FUNC_OBC2_ID = (3006),
	TILE_FUNC_BNR2_ID = (3007),
	TILE_FUNC_RMM2_ID = (3008),
	TILE_FUNC_GDR1_ID = (3009),
	TILE_FUNC_GDR2_ID = (3010),
	TILE_FUNC_G2G_ID = (3011),
	TILE_FUNC_G2G2_ID = (3012),
	TILE_FUNC_WUV_ID = (3013),
	TILE_FUNC_FLC_ID = (3014),
	TILE_FUNC_FLC2_ID = (3015),
	TILE_FUNC_GGM2_ID = (3016),
	TILE_FUNC_WSHIFT_ID = (3017),
	TILE_FUNC_GGM_ID = (3018),
	TILE_FUNC_PGN_ID = (3019),
	TILE_FUNC_RMG2_ID = (3020),
	TILE_FUNC_RCP2_ID = (3021),
	TILE_FUNC_PAK2_ID = (3022),
	TILE_FUNC_PAKG2_ID = (3023),
	TILE_FUNC_WPE_ID = (3024),
	TILE_FUNC_WPE2_ID = (3025),
	TILE_FUNC_VECI_ID = (3110),
	TILE_FUNC_VEC2I_ID = (3111),
	TILE_FUNC_VEC3I_ID = (3112),
	TILE_FUNC_WPEO_ID = (3113),
	TILE_FUNC_MSKO_ID = (3114),
	TILE_FUNC_WPE_C24_ID = (3115),
	TILE_FUNC_WPE_MDP_CROP_ID = (3116),
	TILE_FUNC_WPE_ISP_CROP_ID = (3117),
	TILE_FUNC_EAF_ID = (3200),
	TILE_FUNC_EAFI_MASK_ID = (3201),
	TILE_FUNC_EAFI_CUR_Y_ID = (3202),
	TILE_FUNC_EAFI_CUR_UV_ID = (3203),
	TILE_FUNC_EAFI_PRE_Y_ID = (3204),
	TILE_FUNC_EAFI_PRE_UV_ID = (3205),
	TILE_FUNC_EAFI_DEPTH_ID = (3206),
	TILE_FUNC_EAFI_LKH_WMAP_ID = (3207),
	TILE_FUNC_EAFI_LKH_EMAP_ID = (3208),
	TILE_FUNC_EAFI_PROB_ID = (3209),
	TILE_FUNC_EAFO_FOUT_ID = (3210),
	TILE_FUNC_EAFO_POUT_ID = (3211),
	TILE_FUNC_EAFI_PAD_ID = (3212),
	TILE_FUNC_SL2G_ID = (3026),
	TILE_FUNC_SL2G_CROP_ID = (3027),
	TILE_FUNC_HLR2_ID = (3028),
	TILE_FUNC_SL2I_ID = (3029),
	TILE_FUNC_HFG_ID = (3030),
	TILE_FUNC_HFG_CROP_ID = (3031),
	TILE_FUNC_HFC_ID = (3032),
	TILE_FUNC_SL2K_ID = (3033),
	TILE_FUNC_SL2K_CROP_ID = (3034),
	TILE_FUNC_NDG_ID = (3035),
	TILE_FUNC_NDG_CROP_ID = (3036),
	TILE_FUNC_NDG_PAD_ID = (3037),
	TILE_FUNC_NDG2_ID = (3038),
	TILE_FUNC_NDG2_CROP_ID = (3039),
	TILE_FUNC_NDG2_PAD_ID = (3040),
	TILE_FUNC_WSYNC_ID = (3041),
	/* SMX */
	TILE_FUNC_SMX1_ID = (5000),
	TILE_FUNC_SMX1_TH_ID = (5001),
	TILE_FUNC_SMX2_ID = (5002),
	TILE_FUNC_SMX2_TH_ID = (5003),
	TILE_FUNC_SMX3_ID = (5004),
	TILE_FUNC_SMX3_TH_ID = (5005),
	TILE_FUNC_SMX4_ID = (5006),
	TILE_FUNC_SMX4_TH_ID = (5007),
	TILE_FUNC_SMX1I_ID = (5008),
	TILE_FUNC_SMX1O_ID = (5009),
	TILE_FUNC_SMX2I_ID = (5010),
	TILE_FUNC_SMX2O_ID = (5011),
	TILE_FUNC_SMX3I_ID = (5012),
	TILE_FUNC_SMX3O_ID = (5013),
	TILE_FUNC_SMX4I_ID = (5014),
	TILE_FUNC_SMX4O_ID = (5015),
	/* tile driver function id */
	TILE_FUNC_ADBS2_ID = (2016),
	TILE_FUNC_C02_OUT_CROP_ID = (2061),
	TILE_FUNC_C02B_OUT_CROP_ID = (2062),
	TILE_FUNC_NR3D_IN_CROP_ID = (2023),
	TILE_FUNC_CRSP_IN_CROP_ID = (2258),
	/* IPU */
	TILE_FUNC_ADL2_ID = (1004),
	/*  BLD */
	TILE_FUNC_BLDI_ID = (4001),
	TILE_FUNC_BLD2I_ID = (4002),
	TILE_FUNC_BLD3I_ID = (4003),
	TILE_FUNC_BLD4I_ID = (4004),
	TILE_FUNC_BLD_ID = (4005),
	TILE_FUNC_BLDO_ID = (4006),
	TILE_FUNC_BLD2O_ID = (4007),
	TILE_FUNC_BLD_PAD_ID = (4008),
	TILE_FUNC_BLD_SRZ_ID = (4009),
	TILE_FUNC_BLD_WT_ID = (4010),
	TILE_FUNC_BLDBI_ID = (4011),
	TILE_FUNC_BLD2BI_ID = (4012),
	TILE_FUNC_C02C_ID = (4013),
	TILE_FUNC_C02C_OUT_CROP_ID = (4014),
	TILE_FUNC_C02D_ID = (4015),
	TILE_FUNC_C02D_OUT_CROP_ID = (4016),
	TILE_FUNC_CRSPB_IN_CROP_ID = (4017),
	TILE_FUNC_CRSPB_ID = (4018),
	TILE_FUNC_BLDBO_ID = (4019),
	TILE_FUNC_PLNW3_ID = (4020),
	MDP_TILE_FUNC_ID_ENUM_DECLARE
}TILE_FUNC_ID_ENUM;

typedef enum TILE_GROUP_NUM_ENUM
{
	TILE_DIP_GROUP_NUM = 0,
	TILE_WPE_GROUP_NUM,
	TILE_EAF_GROUP_NUM,
	TILE_BLD_GROUP_NUM,
	TILE_MDP_GROUP_NUM
}TILE_GROUP_NUM_ENUM;

typedef enum TILE_RUN_MODE_ENUM
{
	TILE_RUN_MODE_SUB_OUT = 0x1,
	TILE_RUN_MODE_SUB_IN = TILE_RUN_MODE_SUB_OUT + 0x2,
	TILE_RUN_MODE_MAIN = TILE_RUN_MODE_SUB_IN + 0x4
}TILE_RUN_MODE_ENUM;

/* YUV format */
#define CAM_IN_FMT_YUV422_1 (0)     //VIPI, IMG3O, IMG2O
#define CAM_IN_FMT_YUV422_2 (1)     //VIPI, IMG3O, IMG2O
#define CAM_IN_FMT_YUV422_3 (2)     //VIPI, IMG3O, IMG2O
#define CAM_IN_FMT_YUV420_2 (3)     //VIPI, IMG3O, IMG2O
#define CAM_IN_FMT_YUV420_3 (4)     //VIPI, IMG3O, IMG2O
#define CAM_IN_FMT_YUV400_1 (5)
/* MFB IMGI format */
#define CAM_IN_FMT_MFB_BLD (6)     
#define CAM_IN_FMT_MFB_MIX (7)
/* RAW format */
#define CAM_IN_FMT_BAYER_8      (8)
#define CAM_IN_FMT_BAYER_10     (9)
#define CAM_IN_FMT_BAYER_12     (10)
#define CAM_IN_FMT_BAYER_14	    (11)
#define CAM_IN_FMT_BAYER_8_2	    (12)
#define CAM_IN_FMT_BAYER_10_2	    (13)
#define CAM_IN_FMT_BAYER_12_2	    (14)
#define CAM_IN_FMT_BAYER_14_2	    (15)
#define CAM_IN_FMT_MIPI_10	    (16)
/* RGB format */
#define CAM_IN_FMT_RGB565    (24)
#define CAM_IN_FMT_RGB888    (25)
#define CAM_IN_FMT_XRGB8888  (26)
#define CAM_IN_FMT_RGB101010 (27)
#define CAM_IN_FMT_RGB121212 (28)
/* WPE format */
#define CAM_WPEO_FMT_Y (0)     //WPEO
#define CAM_WPEO_FMT_U (1)
#define CAM_WPEO_FMT_V (2)
#define CAM_WPEO_FMT_UV420_1 (3)
#define CAM_WPEO_FMT_UV422_1 (4)
#define CAM_WPEO_FMT_YUV422_1 (5)
/* LCE power no */
#define CAM_LCE_FRAC_NO (15)
#define CAM_LCE_FRAC_MASK (0x7FFF)
/* resizer prec bits */
#define TILE_RESIZER_N_TP_PREC_BITS (15)
#define TILE_RESIZER_N_TP_PREC_VAL (1<<TILE_RESIZER_N_TP_PREC_BITS)
#define TILE_RESIZER_ACC_PREC_BITS (20)
#define TILE_RESIZER_ACC_PREC_VAL (1<<TILE_RESIZER_ACC_PREC_BITS)
/* resizer direction flag */
typedef enum CAM_DIR_ENUM
{
    CAM_DIR_X=0,
    CAM_DIR_Y,
    CAM_DIR_MAX
} CAM_DIR_ENUM;
/* resizer align flag */
typedef enum CAM_UV_ENUM
{
    CAM_UV_422_FLAG=0,
    CAM_UV_444_FLAG,
    CAM_UV_MAX
} CAM_UV_ENUM;
/* UFO AU config */
#define UFO_AU_BIT  (6)
#define UFO_AU_SIZE (1<<UFO_AU_BIT)
#define UFO_LT_BIT  (8)
#define UFO_LT_SIZE (1<<UFO_LT_BIT)
/* error enum */
#define ERROR_MESSAGE_DATA(n, CMD) \
    CMD(n, ISP_MESSAGE_TILE_OK, ISP_TPIPE_MESSAGE_OK)\
	CMD(n, ISP_MESSAGE_TILE_NULL_PTR_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_UNKNOWN_DRIVER_CONFIGURED_REG_MODE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DIFFERENT_TILE_CONFIG_NO_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_OVER_MAX_MASK_WORD_NO_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_OVER_MAX_TILE_WORD_NO_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_OVER_MAX_TILE_TOT_NO_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_UNDER_MIN_TILE_FUNC_NO_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_OVER_MAX_TILE_FUNC_NO_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_OVER_MAX_TILE_FUNC_NAME_SIZE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_OVER_MAX_TILE_FUNC_EN_NO_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_OVER_MAX_TILE_FUNC_PREV_NO_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_OVER_MAX_TILE_FUNC_SUBRDMA_LIST_NO_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_OVER_MAX_TILE_FUNC_SUBRDMA_NO_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_NOT_FOUND_INIT_TILE_PROPERTY_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_NOT_FOUND_TDR_TILE_FUNC_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_NOT_FOUND_ENABLE_TILE_FUNC_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_NOT_FOUND_SUB_RDMA_TDR_FUNC_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    /* tile dump check */\
    CMD(n, ISP_MESSAGE_INCONSISTENT_TDR_DUMP_MASK_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DUPLICATED_TDR_DUMP_MASK_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DUPLICATED_SUPPORT_FUNC_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DUPLICATED_FUNC_EN_FOUND_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DUPLICATED_FUNC_DISABLE_OUTPUT_FOUND_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DUPLICATED_SUB_RDMA_FUNC_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_OVER_MAX_BRANCH_NO_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_OVER_MAX_INPUT_TILE_FUNC_NO_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_FUNC_CANNOT_FIND_LAST_FUNC_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_SCHEDULING_BACKWARD_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_SCHEDULING_FORWARD_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_IN_CONST_X_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_IN_CONST_Y_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_OUT_CONST_X_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_OUT_CONST_Y_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_NULL_INIT_PTR_FOR_START_FUNC_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_INIT_INCORRECT_X_INPUT_SIZE_POS_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_INIT_INCORRECT_Y_INPUT_SIZE_POS_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_INIT_INCORRECT_X_OUTPUT_SIZE_POS_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_INIT_INCORRECT_Y_OUTPUT_SIZE_POS_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_X_DIR_NOT_END_TOGETHER_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_Y_DIR_NOT_END_TOGETHER_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_INCORRECT_XE_INPUT_POS_REDUCED_BY_TILE_SIZE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_INCORRECT_YE_INPUT_POS_REDUCED_BY_TILE_SIZE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_FORWARD_FUNC_CAL_LOOP_COUNT_OVER_MAX_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_LOSS_OVER_TILE_HEIGHT_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_LOSS_OVER_TILE_WIDTH_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_OUTPUT_HORIZONTAL_OVERLAP_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_OUTPUT_VERTICAL_OVERLAP_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TP8_FOR_INVALID_OUT_XYS_XYE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TP6_FOR_INVALID_OUT_XYS_XYE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TP4_FOR_INVALID_OUT_XYS_XYE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TP2_FOR_INVALID_OUT_XYS_XYE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_SRC_ACC_FOR_INVALID_OUT_XYS_XYE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_CUB_ACC_FOR_INVALID_OUT_XYS_XYE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_BACKWARD_START_LESS_THAN_FORWARD_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_BACKWARD_END_LARGER_THAN_FORWARD_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_NOT_SUPPORT_RESIZER_MODE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_RECURSIVE_FOUND_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_CHECK_IN_CONFIG_ALIGN_XS_POS_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_CHECK_IN_CONFIG_ALIGN_XE_POS_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_CHECK_IN_CONFIG_ALIGN_YS_POS_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_CHECK_IN_CONFIG_ALIGN_YE_POS_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_XSIZE_NOT_DIV_BY_IN_CONST_X_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_YSIZE_NOT_DIV_BY_IN_CONST_Y_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_XSIZE_NOT_DIV_BY_OUT_CONST_X_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_YSIZE_NOT_DIV_BY_OUT_CONST_Y_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_FORWARD_OUT_OVER_TILE_WIDTH_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_FORWARD_OUT_OVER_TILE_HEIGHT_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_BACKWARD_IN_OVER_TILE_WIDTH_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_BACKWARD_IN_OVER_TILE_HEIGHT_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_FORWARD_CHECK_TOP_EDGE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_FORWARD_CHECK_BOTTOM_EDGE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_FORWARD_CHECK_LEFT_EDGE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_FORWARD_CHECK_RIGHT_EDGE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_BACKWARD_CHECK_TOP_EDGE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_BACKWARD_CHECK_BOTTOM_EDGE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_BACKWARD_CHECK_LEFT_EDGE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_BACKWARD_CHECK_RIGHT_EDGE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_CHECK_OUT_CONFIG_ALIGN_XS_POS_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_CHECK_OUT_CONFIG_ALIGN_XE_POS_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_CHECK_OUT_CONFIG_ALIGN_YS_POS_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_CHECK_OUT_CONFIG_ALIGN_YE_POS_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_HEIGHT_ANR_II_MODE_CHECK_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_UNKNOWN_RESIZER_DIR_MODE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DISABLE_FUNC_X_SIZE_CHECK_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DISABLE_FUNC_Y_SIZE_CHECK_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_OUTPUT_DISABLE_INPUT_FUNC_CHECK_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_RESIZER_SRC_ACC_SCALING_UP_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_RESIZER_CUBIC_ACC_SCALING_UP_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TDR_ISP_EDGE_DIFFERENT_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TDR_CDP_EDGE_DIFFERENT_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TDR_WDMA_EDGE_DIFFERENT_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_RDMA_MODULE_CONFIG_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_INCORRECT_END_FUNC_TYPE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_INCORRECT_START_FUNC_TYPE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    /* verification */\
    CMD(n, ISP_MESSAGE_VERIFY_4_8_TAPES_XS_OUT_INCONSISTENCE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_VERIFY_4_8_TAPES_XE_OUT_INCONSISTENCE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_VERIFY_4_8_TAPES_YS_OUT_INCONSISTENCE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_VERIFY_4_8_TAPES_YE_OUT_INCONSISTENCE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_VERIFY_CUBIC_ACC_XS_OUT_INCONSISTENCE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_VERIFY_CUBIC_ACC_XE_OUT_INCONSISTENCE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_VERIFY_CUBIC_ACC_YS_OUT_INCONSISTENCE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_VERIFY_CUBIC_ACC_YE_OUT_INCONSISTENCE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_VERIFY_SRC_ACC_XS_OUT_INCONSISTENCE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_VERIFY_SRC_ACC_XE_OUT_INCONSISTENCE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_VERIFY_SRC_ACC_YS_OUT_INCONSISTENCE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_VERIFY_SRC_ACC_YE_OUT_INCONSISTENCE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_VERIFY_BACKWARD_XS_LESS_THAN_FORWARD_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_VERIFY_FORWARD_XE_LESS_THAN_BACKWARD_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_VERIFY_BACKWARD_YS_LESS_THAN_FORWARD_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_VERIFY_FORWARD_YE_LESS_THAN_BACKWARD_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    /* dump c model hex */\
    CMD(n, ISP_MESSAGE_TILE_CONFIG_EN_FILE_OPEN_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_CONFIG_MAP_FILE_OPEN_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_CONFIG_MAP_SKIP_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    /* tile mode control */\
    CMD(n, ISP_MESSAGE_TILE_MODE_OUTPUT_FILE_COPY_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_MODE_OUTPUT_FILE_CMP_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_MODE_OUTPUT_FILE_DEL_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    /* tile debug purpose */\
    CMD(n, ISP_MESSAGE_DEBUG_PRINT_FILE_OPEN_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    /* tile platform */\
    CMD(n, ISP_MESSAGE_TILE_PLATFORM_NULL_INPUT_CONFIG_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_PLATFORM_NULL_WORKING_BUFFER_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_PLATFORM_LESS_WORKING_BUFFER_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_NULL_PTR_COMP_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_ISP_HEX_DUMP_COMP_DIFF_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_REG_MAP_COMP_DIFF_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_PLATFORM_RETURN_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_NULL_MEM_PTR_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_ISP_DESCRIPTOR_PTR_NON_4_BYTES_ALGIN_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_WORKING_BUFFER_PTR_NON_4_BYTES_ALGIN_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_WORKING_BUFFER_SIZE_NON_4_BYTES_ALGIN_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_INVALID_DIRECT_LINK_REG_FILE_WARNING, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_INVALID_CAL_DUMP_FILE_WARNING, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DISABLE_C_MODEL_DIRECT_LINK_WARNING, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_ZERO_SL_HRZ_OR_VRZ_COMP_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    /* tdr inverse */\
    CMD(n, ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TDR_INV_DIFFERENT_TILE_CONFIG_NO_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TDR_INV_NULL_PTR_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    /* tile ut */\
    CMD(n, ISP_MESSAGE_TILE_UT_FILE_OPEN_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    /* last irq check */\
    CMD(n, ISP_MESSAGE_TDR_LAST_IRQ_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    /* tile verification c model */\
    CMD(n, ISP_MESSAGE_OVER_MAX_DIR_SIZE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    /* func ptr check */\
    CMD(n, ISP_MESSAGE_UNMATCH_INIT_FUNC_PTR_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_UNMATCH_FOR_FUNC_PTR_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_UNMATCH_BACK_FUNC_PTR_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_UNMATCH_TDR_FUNC_PTR_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_UNMATCH_SUBRDMA_FUNC_ENABLE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    /* tdr sort check */\
    CMD(n, ISP_MESSAGE_INCORRECT_ORDER_CONFIG_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_LAST_IRQ_NOT_SUPPORT_TDR_SORT_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TDR_SORT_OVER_MAX_H_TILE_NO_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TDR_SORT_NON_4_BYTES_TILE_INFO_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    /* tdr edge group check */\
    CMD(n, ISP_MESSAGE_INCORRECT_TDR_EDGE_GROUP_CONFIG_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    /* tile driver error check */\
    CMD(n, ISP_MESSAGE_OVER_MAX_ID_BUFFER_NO_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_MEM_DUMP_PARSE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DONT_CARE_END_CONFIG_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
	/* multi-input flow error check */\
    CMD(n, ISP_MESSAGE_TWO_MAIN_PREV_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TWO_START_PREV_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_NO_MAIN_OUTPUT_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DIFF_PREV_CONFIG_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DIFF_NEXT_CONFIG_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TWO_MAIN_START_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DIFF_PREV_FORWARD_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_FOR_BACK_COMP_X_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_FOR_BACK_COMP_Y_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_BROKEN_SUB_PATH_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_MIX_SUB_IN_OUT_PATH_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_INVALID_SUB_IN_CONFIG_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_INVALID_SUB_OUT_CONFIG_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_UNKNOWN_RUN_MODE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    /* DMA align check */\
    CMD(n, ISP_MESSAGE_WRONG_IMGI_STRIDE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_WRONG_BLDI_STRIDE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_WRONG_PASS1_STRIDE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    /* C model func id check */\
    CMD(n, ISP_MESSAGE_TILE_CMODEL_OVER_MAX_COUNT_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_CMODEL_FUNC_ID_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_CMODEL_FUNC_CROP_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    /* dpframework check */\
    CMD(n, ISP_MESSAGE_DPFRAMEWORK_UNKNOWN_ENUM_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DIRECT_LINK_DIFF_TILE_NO_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DIRECT_LINK_CHECK_RESULT_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_NULL_FILE_PTR_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
	/* diff view check */\
    CMD(n, ISP_MESSAGE_DIFF_VIEW_BRANCH_MERGE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DIFF_VIEW_INPUT_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DIFF_VIEW_OUTPUT_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_FRAME_MODE_NOT_END_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_WDMA_SKIP_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DIFF_VIEW_TDR_SORTING_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TDR_DISABLE_CONFIG_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_UNDER_MIN_TDR_WORD_NO_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TCM_DISABLE_NOT_SUPPORT_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DIFF_VIEW_TILE_WIDTH_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_DIFF_VIEW_TILE_HEIGHT_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
	/* c model random gen */\
    CMD(n, ISP_MESSAGE_NULL_RAND_GEN_FUNC_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_HEX_CMP_DIFF_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_READ_SDLK_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_RAND_GEN_FILE_OPEN_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_UPDATE_RESULT_FILE_OPEN_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TEST_CONFIG_PARSE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_CONFIG_OVER_BUFFER_SIZE_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
	/* tile sel mode */\
    CMD(n, ISP_MESSAGE_TDR_DISPATCH_CONFIG_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_SEL_DIFF_HW_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    CMD(n, ISP_MESSAGE_TILE_SEL_CHECK_ERROR, ISP_TPIPE_MESSAGE_FAIL)\
    /* ISP ERROR MESSAGE DATA */\
    ISP_TILE_ERROR_MESSAGE_ENUM(n, CMD)\
    /* MDP ERROR MESSAGE DATA */\
    MDP_TILE_ERROR_MESSAGE_ENUM(n, CMD)\
    /* final count, can not be changed */\
    CMD(n, ISP_MESSAGE_TILE_MAX_NO, ISP_TPIPE_MESSAGE_MAX_NO)

#define ISP_ENUM_DECLARE(n, a, b) a,
#define ISP_ENUM_GET_PLATFORM_ERROR_NO(n, a, b) if ((a) == (n)) return b;
#define ISP_ENUM_STRING(n, a, b) if ((a) == (n)) return #a;

/* to prevent from directly calling macro */
#define GET_ERROR_NAME(n) \
    if (0 == (n)) return "ISP_MESSAGE_UNKNOWN";\
    ERROR_MESSAGE_DATA(n, ISP_ENUM_STRING)\
    return "";

/* to prevent from directly calling macro */
#define GET_ISP_TILE_ERROR_NO(n) \
    if (0 == (n)) return ISP_TPIPE_MESSAGE_UNKNOWN;\
    ERROR_MESSAGE_DATA(n, ISP_ENUM_GET_PLATFORM_ERROR_NO)\
    return ISP_TPIPE_MESSAGE_UNKNOWN;

/* error enum */
typedef enum ISP_TILE_MESSAGE_ENUM
{
    ISP_TILE_MESSAGE_UNKNOWN=0,
    ERROR_MESSAGE_DATA(,ISP_ENUM_DECLARE)
}ISP_TILE_MESSAGE_ENUM;

/* error enum */
typedef enum TILE_RESIZER_MODE_ENUM
{
    TILE_RESIZER_MODE_UNKNOWN=0,//0
    TILE_RESIZER_MODE_4_TAPES,
    TILE_RESIZER_MODE_SRC_ACC,
    TILE_RESIZER_MODE_CUBIC_ACC,
    TILE_RESIZER_MODE_8_TAPES,
    TILE_RESIZER_MODE_6_TAPES,
    TILE_RESIZER_MODE_2_TAPES,
    TILE_RESIZER_MODE_MDP_6_TAPES,
    TILE_RESIZER_MODE_MDP_CUBIC_ACC,
    TILE_RESIZER_MODE_MAX_NO
}TILE_RESIZER_MODE_ENUM;

/* Func ptr flag */
#define TILE_INIT_FUNC_PTR_FLAG (0x1)
#define TILE_FOR_FUNC_PTR_FLAG (0x2)
#define TILE_BACK_FUNC_PTR_FLAG (0x4)
#define TILE_TDR_FUNC_PTR_FLAG (0x8)
#define TILE_SUBRDMA_FUNC_PTR_FLAG (0x10)
/* a, b, c, d, e reserved */
/* data type */
/* register name of current c model */
/* reserved */
/* value mask */
/* array bracket [] */
/* S: c model variables, U: unmasked variable, M: masked variable */
/* be careful with init, must items to reset by TILE_MODULE_CHECK macro */
/* output_disable = false function to reset by tile_init_config() */
#define TILE_FUNC_BLOCK_LUT(CMD, a, b, c, d, e) \
    CMD(a, b, c, d, e, TILE_FUNC_ID_ENUM, func_num,,,, S,,)\
    CMD(a, b, c, d, e, char, func_name,,, [MAX_TILE_FUNC_NAME_SIZE], S,,)\
    CMD(a, b, c, d, e, TILE_RUN_MODE_ENUM, run_mode,,,, S,,)\
    CMD(a, b, c, d, e, bool, enable_flag,,,, S,,)\
    CMD(a, b, c, d, e, bool, output_disable_flag,,,, S,,)\
    CMD(a, b, c, d, e, unsigned char, tdr_edge,, TILE_EDGE_HORZ_MASK,, M,,)/* to reset */\
    CMD(a, b, c, d, e, unsigned char, tot_branch_num,,,, S,,)/* to reset */\
    CMD(a, b, c, d, e, unsigned char, next_blk_num,,, [MAX_TILE_BRANCH_NO], S,,)\
    CMD(a, b, c, d, e, unsigned char, tot_prev_num,,,, S,,)/* to reset */\
    CMD(a, b, c, d, e, unsigned char, prev_blk_num,,, [MAX_TILE_PREV_NO], S,,)\
    CMD(a, b, c, d, e, bool, tdr_h_disable_flag,,,, U,,)/* diff view cal with backup, to reset */\
    CMD(a, b, c, d, e, bool, h_end_flag,,,, U,,)/* backup */\
    CMD(a, b, c, d, e, bool, crop_h_end_flag,,,, S,,)\
    CMD(a, b, c, d, e, int, in_pos_xs,,,, U,,)\
    CMD(a, b, c, d, e, int, in_pos_xe,,,, U,,)\
    CMD(a, b, c, d, e, int, full_size_x_in,,,, S,,)\
    CMD(a, b, c, d, e, int, in_tile_width,,,, S,,)\
    CMD(a, b, c, d, e, int, in_tile_width_max,,,, S,,)/* backward boundary */\
    CMD(a, b, c, d, e, int, in_tile_width_max_str,,,, S,,)\
    CMD(a, b, c, d, e, int, in_tile_width_max_end,,,, S,,)\
    CMD(a, b, c, d, e, int, in_tile_width_loss,,,, S,,)/* backward boundary for ufd smx */\
    CMD(a, b, c, d, e, int, in_max_width,,,, S,,)\
    CMD(a, b, c, d, e, int, in_min_width,,,, S,,)\
    CMD(a, b, c, d, e, int, in_log_width,,,, S,,)\
    CMD(a, b, c, d, e, int, out_pos_xs,,,, U,,)\
    CMD(a, b, c, d, e, int, out_pos_xe,,,, U,,)\
    CMD(a, b, c, d, e, int, full_size_x_out,,,, S,,)/* to reset */\
    CMD(a, b, c, d, e, int, out_tile_width,,,, S,,)\
    CMD(a, b, c, d, e, int, out_tile_width_max,,,, S,,)/* backward boundary */\
    CMD(a, b, c, d, e, int, out_tile_width_max_str,,,, S,,)\
    CMD(a, b, c, d, e, int, out_tile_width_max_end,,,, S,,)\
    CMD(a, b, c, d, e, int, out_tile_width_loss,,,, S,,)/* backward boundary for ufd smx */\
    CMD(a, b, c, d, e, int, out_max_width,,,, S,,)\
    CMD(a, b, c, d, e, int, out_log_width,,,, S,,)\
    CMD(a, b, c, d, e, bool, max_h_edge_flag,,,, S,,)\
    CMD(a, b, c, d, e, unsigned char, in_const_x,,,, S,,)\
    CMD(a, b, c, d, e, unsigned char, out_const_x,,,, S,,)\
    CMD(a, b, c, d, e, bool, tdr_v_disable_flag,,,, S,,)/* diff view cal, to reset */\
    CMD(a, b, c, d, e, bool, v_end_flag,,,, S,,)\
    CMD(a, b, c, d, e, bool, crop_v_end_flag,,,, S,,)\
    CMD(a, b, c, d, e, int, in_pos_ys,,,, S,,)\
    CMD(a, b, c, d, e, int, in_pos_ye,,,, S,,)\
    CMD(a, b, c, d, e, int, full_size_y_in,,,, S,,)/* to reset */\
    CMD(a, b, c, d, e, int, in_tile_height,,,, S,,)\
    CMD(a, b, c, d, e, int, in_tile_height_max,,,, S,,)/* backward boundary */\
    CMD(a, b, c, d, e, int, in_tile_height_max_str,,,, S,,)\
    CMD(a, b, c, d, e, int, in_tile_height_max_end,,,, S,,)\
    CMD(a, b, c, d, e, int, in_max_height,,,, S,,)\
    CMD(a, b, c, d, e, int, in_min_height,,,, S,,)\
    CMD(a, b, c, d, e, int, in_log_height,,,, S,,)\
    CMD(a, b, c, d, e, int, out_pos_ys,,,, S,,)\
    CMD(a, b, c, d, e, int, out_pos_ye,,,, S,,)\
    CMD(a, b, c, d, e, int, full_size_y_out,,,, S,,)\
    CMD(a, b, c, d, e, int, out_tile_height,,,, S,,)\
    CMD(a, b, c, d, e, int, out_tile_height_max,,,, S,,)/* backward boundary */\
    CMD(a, b, c, d, e, int, out_tile_height_max_str,,,, S,,)\
    CMD(a, b, c, d, e, int, out_tile_height_max_end,,,, S,,)\
    CMD(a, b, c, d, e, int, out_max_height,,,, S,,)\
    CMD(a, b, c, d, e, int, out_log_height,,,, S,,)\
    CMD(a, b, c, d, e, bool, max_v_edge_flag,,,, S,,)\
    CMD(a, b, c, d, e, unsigned char, in_const_y,,,, S,,)\
    CMD(a, b, c, d, e, unsigned char, out_const_y,,,, S,,)\
    CMD(a, b, c, d, e, int, min_in_pos_xs,,,, S,,)\
    CMD(a, b, c, d, e, int, max_in_pos_xe,,,, S,,)\
    CMD(a, b, c, d, e, int, min_out_pos_xs,,,, S,,)\
    CMD(a, b, c, d, e, int, max_out_pos_xe,,,, S,,)\
    CMD(a, b, c, d, e, int, min_in_crop_xs,,,, S,,)/* backward boundary for ufd smx */\
    CMD(a, b, c, d, e, int, max_in_crop_xe,,,, S,,)/* backward boundary for ufd smx */\
    CMD(a, b, c, d, e, int, min_out_crop_xs,,,, S,,)/* backward boundary for ufd smx */\
    CMD(a, b, c, d, e, int, max_out_crop_xe,,,, S,,)/* backward boundary for ufd smx */\
    CMD(a, b, c, d, e, int, min_in_pos_ys,,,, S,,)\
    CMD(a, b, c, d, e, int, max_in_pos_ye,,,, S,,)\
    CMD(a, b, c, d, e, int, min_out_pos_ys,,,, S,,)\
    CMD(a, b, c, d, e, int, max_out_pos_ye,,,, S,,)\
    CMD(a, b, c, d, e, int, valid_h_no,,,, S,,)/* diff view cal, to reset */\
    CMD(a, b, c, d, e, int, valid_v_no,,,, S,,)/* diff view cal, to reset */\
    CMD(a, b, c, d, e, int, last_valid_tile_no,,,, S,,)/* diff view cal, to reset */\
    CMD(a, b, c, d, e, int, last_valid_v_no,,,, S,,)/* diff view cal, to reset */\
    CMD(a, b, c, d, e, int, smx_tdr_offset_x,,,, S,,)/* diff view cal, to reset */\
    CMD(a, b, c, d, e, int, smx_tdr_offset_y,,,, S,,)/* diff view cal, to reset */\
    CMD(a, b, c, d, e, int, bias_x,,,, U,,)\
    CMD(a, b, c, d, e, int, offset_x,,,, U,,)\
    CMD(a, b, c, d, e, int, bias_x_c,,,, U,,)\
    CMD(a, b, c, d, e, int, offset_x_c,,,, U,,)\
    CMD(a, b, c, d, e, int, bias_y,,,, S,,)\
    CMD(a, b, c, d, e, int, offset_y,,,, S,,)\
    CMD(a, b, c, d, e, int, bias_y_c,,,, S,,)\
    CMD(a, b, c, d, e, int, offset_y_c,,,, S,,)\
    CMD(a, b, c, d, e, unsigned char, l_tile_loss,,,, S,,)\
    CMD(a, b, c, d, e, unsigned char, r_tile_loss,,,, S,,)\
    CMD(a, b, c, d, e, unsigned char, t_tile_loss,,,, S,,)\
    CMD(a, b, c, d, e, unsigned char, b_tile_loss,,,, S,,)\
    CMD(a, b, c, d, e, int, crop_bias_x,,,, S,,)\
    CMD(a, b, c, d, e, int, crop_offset_x,,,, S,,)\
    CMD(a, b, c, d, e, int, crop_bias_y,,,, S,,)\
    CMD(a, b, c, d, e, int, crop_offset_y,,,, S,,)\
    CMD(a, b, c, d, e, int, backward_input_xs_pos,,,, S,,)\
    CMD(a, b, c, d, e, int, backward_input_xe_pos,,,, S,,)\
    CMD(a, b, c, d, e, int, backward_output_xs_pos,,,, S,,)\
    CMD(a, b, c, d, e, int, backward_output_xe_pos,,,, S,,)\
    CMD(a, b, c, d, e, int, backward_input_ys_pos,,,, S,,)\
    CMD(a, b, c, d, e, int, backward_input_ye_pos,,,, S,,)\
    CMD(a, b, c, d, e, int, backward_output_ys_pos,,,, S,,)\
    CMD(a, b, c, d, e, int, backward_output_ye_pos,,,, S,,)\
    CMD(a, b, c, d, e, int, last_input_xs_pos,,,, S,,)\
    CMD(a, b, c, d, e, int, last_input_xe_pos,,,, S,,)\
    CMD(a, b, c, d, e, int, last_output_xs_pos,,,, S,,)\
    CMD(a, b, c, d, e, int, last_output_xe_pos,,,, S,,)\
    CMD(a, b, c, d, e, int, last_input_ys_pos,,,, S,,)\
    CMD(a, b, c, d, e, int, last_input_ye_pos,,,, S,,)\
    CMD(a, b, c, d, e, int, last_output_ys_pos,,,, S,,)\
    CMD(a, b, c, d, e, int, last_output_ye_pos,,,, S,,)\
    CMD(a, b, c, d, e, unsigned char, type,,,, S,,)\
    CMD(a, b, c, d, e, unsigned int, in_stream_order,,,, S,,)\
    CMD(a, b, c, d, e, unsigned int, out_stream_order,,,, S,,)\
    CMD(a, b, c, d, e, unsigned int, in_cal_order,,,, S,,)\
    CMD(a, b, c, d, e, unsigned int, out_cal_order,,,, S,,)\
    CMD(a, b, c, d, e, unsigned int, in_dump_order,,,, S,,)\
    CMD(a, b, c, d, e, unsigned int, out_dump_order,,,, S,,)\
    CMD(a, b, c, d, e, int, min_tile_in_pos_xs,,,, S,,)/* diff view cal */\
    CMD(a, b, c, d, e, int, min_tile_in_pos_xe,,,, S,,)/* diff view cal */\
    CMD(a, b, c, d, e, int, min_tile_out_pos_xs,,,, S,,)/* diff view cal */\
    CMD(a, b, c, d, e, int, min_tile_out_pos_xe,,,, S,,)/* diff view cal */\
    CMD(a, b, c, d, e, int, min_tile_crop_in_pos_xs,,,, S,,)/* diff view cal */\
    CMD(a, b, c, d, e, int, min_tile_crop_in_pos_xe,,,, S,,)/* diff view cal */\
    CMD(a, b, c, d, e, int, min_tile_crop_out_pos_xs,,,, S,,)/* diff view cal */\
    CMD(a, b, c, d, e, int, min_tile_crop_out_pos_xe,,,, S,,)/* diff view cal */\
    CMD(a, b, c, d, e, int, min_tile_in_pos_ys,,,, S,,)/* diff view cal */\
    CMD(a, b, c, d, e, int, min_tile_in_pos_ye,,,, S,,)/* diff view cal */\
    CMD(a, b, c, d, e, int, min_tile_out_pos_ys,,,, S,,)/* diff view cal */\
    CMD(a, b, c, d, e, int, min_tile_out_pos_ye,,,, S,,)/* diff view cal */\
    CMD(a, b, c, d, e, bool, min_cal_tdr_h_disable_flag,,,, S,,)/* diff view cal */\
    CMD(a, b, c, d, e, bool, min_cal_h_end_flag,,,, S,,)/* diff view log */\
    CMD(a, b, c, d, e, bool, min_cal_max_h_edge_flag,,,, S,,)/* diff view log */\
    CMD(a, b, c, d, e, bool, min_cal_tdr_v_disable_flag,,,, S,,)\
    CMD(a, b, c, d, e, bool, min_cal_v_end_flag,,,, S,,)/* diff view log */\
    CMD(a, b, c, d, e, bool, min_cal_max_v_edge_flag,,,, S,,)/* diff view log */\
    CMD(a, b, c, d, e, bool, direct_h_end_flag,,,, S,,)/* DL interface */\
    CMD(a, b, c, d, e, bool, direct_v_end_flag,,,, S,,)/* DL interface */\
    CMD(a, b, c, d, e, int, direct_out_pos_xs,,,, S,,)/* DL interface */\
    CMD(a, b, c, d, e, int, direct_out_pos_xe,,,, S,,)/* DL interface */\
    CMD(a, b, c, d, e, int, direct_out_pos_ys,,,, S,,)/* DL interface */\
    CMD(a, b, c, d, e, int, direct_out_pos_ye,,,, S,,)/* DL interface */\
    CMD(a, b, c, d, e, bool, backward_tdr_h_disable_flag,,,, U,,)/* diff view tdr used with backup */\
    CMD(a, b, c, d, e, bool, backward_tdr_v_disable_flag,,,, S,,)\
    CMD(a, b, c, d, e, bool, backward_h_end_flag,,,, U,,)/* diff view tdr used with backup */\
    CMD(a, b, c, d, e, bool, backward_v_end_flag,,,, S,,)\
    CMD(a, b, c, d, e, int, in_tile_width_backup,,,, S,,)\
    CMD(a, b, c, d, e, int, out_tile_width_backup,,,, S,,)\
    CMD(a, b, c, d, e, int, in_tile_height_backup,,,, S,,)\
    CMD(a, b, c, d, e, int, out_tile_height_backup,,,, S,,)\
    CMD(a, b, c, d, e, int, min_last_input_xs_pos,,,, S,,)\
    CMD(a, b, c, d, e, int, max_last_input_xe_pos,,,, S,,)\
    CMD(a, b, c, d, e, int, max_last_input_ye_pos,,,, S,,)\
    CMD(a, b, c, d, e, TILE_TDR_EDGE_GROUP_ENUM, tdr_group,,,, S,,)\
    CMD(a, b, c, d, e, TILE_FUNC_ID_ENUM, last_func_num,,, [MAX_TILE_PREV_NO], S,,)\
    CMD(a, b, c, d, e, TILE_FUNC_ID_ENUM, next_func_num,,, [MAX_TILE_BRANCH_NO], S,,)\
    CMD(a, b, c, d, e, TILE_HORZ_BACKUP_BUFFER, horz_para,,, [MAX_TILE_BACKUP_HORZ_NO], S,,)\
    CMD(a, b, c, d, e, TILE_GROUP_NUM_ENUM, group_num,,,, S,,)\
	CMD(a, b, c, d, e, unsigned int, func_ptr_flag,,,, S,,)\
    CMD(a, b, c, d, e, unsigned char, tot_subrdma_num,,,, S,,)/* to reset */\
    CMD(a, b, c, d, e, unsigned char, subrdma_num,,, [MAX_SUBRDMA_NO], S,,)\
    CMD(a, b, c, d, e, TILE_FUNC_ID_ENUM, subrdma_func_num,,, [MAX_SUBRDMA_NO], S,,)\

/* register table (Cmodel, platform, tile driver) for SW parameters */
/* a, b, c, d, e reserved */
/* data type */
/* register name of current c model */
/* register name of HW ISP & platform parameters */
/* internal variable name of tile */
/* array bracket [xx] */
/* valid condition by tdr_en to print platform log with must string, default: false */
/* isp_reg.h reg name */
/* isp_reg.h field name */
/* direct-link param 0: must be equal, 1: replaced by MDP, 2: don't care */
#ifndef TILE_NEW_ENG_TEST
#define TILE_SW_REG_LUT(LABEL, CMD, a, b, c, d, e) \
    LABEL##_TILE_SW_REG_LUT(CMD, a, b, c, d, e)

#else
/* for new tile engine check only */
#define TILE_SW_REG_LUT(LABEL, CMD, a, b, c, d, e) \
    LABEL##_TILE_SW_REG_MAP(CMD, a, b, c, d, e)\

#define ISP_TILE_SW_REG_MAP		ISP_TILE_SW_REG_LUT
#define DIP_TILE_SW_REG_MAP	DIP_TILE_SW_REG_LUT
#define WPE_TILE_SW_REG_MAP	WPE_TILE_SW_REG_LUT
#define EAF_TILE_SW_REG_MAP	EAF_TILE_SW_REG_LUT
#define BLD_TILE_SW_REG_MAP	BLD_TILE_SW_REG_LUT
#define MDP_TILE_SW_REG_MAP	MDP_TILE_SW_REG_LUT
#endif

/* register table (Cmodel, platform, tile driver) for HW parameters */
/* a, b, c, d, e reserved */
/* data type */
/* register name of current c model */
/* register name of HW ISP & platform parameters */
/* internal variable name of tile */
/* array bracket [xx] */
/* valid condition by tdr_en to print platform log with must string, default: false */
/* isp_reg.h reg name */
/* isp_reg.h field name */
/* direct-link param 0: must be equal, 1: replaced by MDP, 2: don't care */
#ifndef TILE_NEW_ENG_TEST
#define TILE_HW_REG_LUT(LABEL, CMD, a, b, c, d, e)	LABEL##_TILE_HW_REG_LUT(CMD, a, b, c, d, e)
#else
/* for new tile engine check only */
#define TILE_HW_REG_LUT(LABEL, CMD, a, b, c, d, e)	LABEL##_TILE_HW_REG_MAP(CMD, a, b, c, d, e)
#define DIP_TILE_HW_REG_MAP		WPE_TILE_HW_REG_LUT
#define MDP_TILE_HW_REG_MAP		MDP_TILE_HW_REG_LUT
#define WPE_TILE_HW_REG_MAP		WPE2_TILE_HW_REG_LUT
#define WPE2_TILE_HW_REG_MAP		EAF_TILE_HW_REG_LUT
#define EAF_TILE_HW_REG_MAP		DIP_TILE_HW_REG_LUT
#define BLD_TILE_HW_REG_MAP		BLD_TILE_HW_REG_LUT
#define MDP_TILE_HW_REG_MAP		MDP_TILE_HW_REG_LUT
#endif
/* register table (Cmodel, , tile driver) for Cmodel only parameters */
/* a, b, c, d, e reserved */
/* data type */
/* register name of current c model */
/* register name of HW ISP & platform parameters */
/* internal variable name of tile */
/* array bracket [xx] */
/* valid condition by tdr_en to print platform log with must string, default: false */
/* isp_reg.h reg name */
/* isp_reg.h field name */
/* direct-link param 0: must be equal, 1: replaced by MDP, 2: don't care */
#define TILE_CMODEL_PATH_LUT(LABEL, CMD, a, b, c, d, e) \
    LABEL##_TILE_CMODEL_PATH_LUT(CMD, a, b, c, d, e)

/* register table (Cmodel, , tile driver) for Cmodel only parameters */
/* a, b, c, d, e reserved */
/* data type */
/* register name of current c model */
/* register name of HW ISP & platform parameters */
/* internal variable name of tile */
/* array bracket [xx] */
/* reserved */
#define TILE_CMODEL_REG_LUT(LABEL, CMD, a, b, c, d, e) \
    LABEL##_TILE_CMODEL_REG_LUT(CMD, a, b, c, d, e)

/* register table ( , platform, tile driver) for Platform only parameters */
/* a, b, c, d, e reserved */
/* data type */
/* register name of current c model */
/* register name of HW ISP & platform parameters */
/* internal variable name of tile */
/* array bracket [xx] */
/* valid condition by tdr_en to print platform log with must string, default: false */
/* isp_reg.h reg name */
/* isp_reg.h field name */
/* direct-link param 0: must be equal, 1: replaced by MDP, 2: don't care */
#define TILE_PLATFORM_REG_LUT(LABEL, CMD, a, b, c, d, e) \
    LABEL##_TILE_PLATFORM_REG_LUT(CMD, a, b, c, d, e)

/* register table ( , , tile driver) for tile driver only parameters */
/* a, b, c, d, e reserved */
/* data type */
/* register name of current c model */
/* register name of HW ISP & platform parameters */
/* internal variable name of tile */
/* array bracket [xx] */
/* valid condition by tdr_en to print platform log with must string, default: false */
/* isp_reg.h reg name */
/* isp_reg.h field name */
/* direct-link param 0: must be equal, 1: replaced by MDP, 2: don't care */
#define TILE_PLATFORM_DEBUG_REG_LUT(LABEL, CMD, a, b, c, d, e) \
    LABEL##_TILE_PLATFORM_DEBUG_REG_LUT(CMD, a, b, c, d, e)

/* register table ( , , tile driver) for tile driver only parameters */
/* a, b, c, d, e reserved */
/* data type */
/* register name of current c model */
/* register name of HW ISP & platform parameters */
/* internal variable name of tile */
/* array bracket [xx] */
/* valid condition by tdr_en to print platform log with must string, default: false */
/* isp_reg.h reg name */
/* isp_reg.h field name */
/* direct-link param 0: must be equal, 1: replaced by MDP, 2: don't care */
#define TILE_INTERNAL_TDR_REG_LUT(LABEL, CMD, a, b, c, d, e) \
    LABEL##_TILE_INTERNAL_TDR_REG_LUT(CMD, a, b, c, d, e)

#define TILE_INTERNAL_REG_LUT(LABEL, CMD, a, b, c, d, e) \
	LABEL##_TILE_INTERNAL_REG_LUT(CMD, a, b, c, d, e)

/* register table ( , , tile driver) for tile driver only parameters */
/* a, b, c, d, e reserved */
/* data type */
/* register name of current c model */
/* register name of HW ISP & platform parameters */
/* internal variable name of tile */
/* array bracket [xx] */
/* valid condition by tdr_en to print platform log with must string, default: false */
/* isp_reg.h reg name */
/* isp_reg.h field name */
/* direct-link param 0: must be equal, 1: replaced by MDP, 2: don't care */
#define COMMON_TILE_INTERNAL_REG_LUT(CMD, a, b, c, d, e) \
    /* Internal */\
    CMD(a, b, c, d, e, int,,, skip_x_cal,,,,, 2)\
    CMD(a, b, c, d, e, int,,, skip_y_cal,,,,, 2)\
    CMD(a, b, c, d, e, int,,, backup_x_skip_y,,,,, 2)\
    /* tdr_control_en */\
    CMD(a, b, c, d, e, int,,, tdr_ctrl_en,,,,, 1)\
    /* run mode */\
    CMD(a, b, c, d, e, int,,, run_mode,,,,, 2)\
	/* frame mode flag */\
    CMD(a, b, c, d, e, int,,, first_frame,,,,, 2)/* first frame to run frame mode */\
    /* used_word_no */\
    CMD(a, b, c, d, e, int,,, isp_used_word_no,,,,, 2)\
    /* used_word_no_d */\
    CMD(a, b, c, d, e, int,,, isp_used_word_no_d,,,,, 2)\
    /* used_word_no */\
    CMD(a, b, c, d, e, int,,, isp_used_word_no_wpe,,,,, 2)\
    /* used_word_no_d */\
    CMD(a, b, c, d, e, int,,, isp_used_word_no_d_wpe,,,,, 2)\
    /* used_word_no */\
    CMD(a, b, c, d, e, int,,, isp_used_word_no_wpe2,,,,, 2)\
    /* used_word_no */\
    CMD(a, b, c, d, e, int,,, isp_used_word_no_eaf,,,,, 2)\
    /* used_word_no */\
    CMD(a, b, c, d, e, int,,, isp_used_word_no_bld,,,,, 2)\
    /* used_word_no_internal */\
    CMD(a, b, c, d, e, int,,, isp_used_word_no_internal,,,,, 2)\
    /* used_word_no_internal_d */\
    CMD(a, b, c, d, e, int,,, isp_used_word_no_internal_d,,,,, 2)\
    /* used_word_no_internal */\
    CMD(a, b, c, d, e, int,,, isp_used_word_no_internal_wpe,,,,, 2)\
    /* used_word_no_internal_d */\
    CMD(a, b, c, d, e, int,,, isp_used_word_no_internal_d_wpe,,,,, 2)\
    /* used_word_no_internal */\
    CMD(a, b, c, d, e, int,,, isp_used_word_no_internal_wpe2,,,,, 2)\
    /* used_word_no_internal */\
    CMD(a, b, c, d, e, int,,, isp_used_word_no_internal_eaf,,,,, 2)\
    /* used_word_no_internal */\
    CMD(a, b, c, d, e, int,,, isp_used_word_no_internal_bld,,,,, 2)\
    /* config_no_per_tile */\
    CMD(a, b, c, d, e, int,,, isp_config_no_per_tile,,,,, 2)\
    /* config_no_per_tile_internal */\
    CMD(a, b, c, d, e, int,,, isp_config_no_per_tile_internal,,,,, 2)\
    /* config_no_per_tile */\
    CMD(a, b, c, d, e, int,,, isp_config_no_per_tile_wpe,,,,, 2)\
    /* config_no_per_tile_internal */\
    CMD(a, b, c, d, e, int,,, isp_config_no_per_tile_internal_wpe,,,,, 2)\
    /* config_no_per_tile */\
    CMD(a, b, c, d, e, int,,, isp_config_no_per_tile_wpe2,,,,, 2)\
    /* config_no_per_tile_internal */\
    CMD(a, b, c, d, e, int,,, isp_config_no_per_tile_internal_wpe2,,,,, 2)\
    /* config_no_per_tile */\
    CMD(a, b, c, d, e, int,,, isp_config_no_per_tile_eaf,,,,, 2)\
    /* config_no_per_tile_internal */\
    CMD(a, b, c, d, e, int,,, isp_config_no_per_tile_internal_eaf,,,,, 2)\
    /* config_no_per_tile */\
    CMD(a, b, c, d, e, int,,, isp_config_no_per_tile_bld,,,,, 2)\
    /* config_no_per_tile_internal */\
    CMD(a, b, c, d, e, int,,, isp_config_no_per_tile_internal_bld,,,,, 2)\
	/* vertical_tile_no */\
    CMD(a, b, c, d, e, int,,, curr_vertical_tile_no,,,,, 2)\
    /* horizontal_tile_no */\
    CMD(a, b, c, d, e, int,,, horizontal_tile_no,,,,, 2)\
    /* curr_horizontal_tile_no */\
    CMD(a, b, c, d, e, int,,, curr_horizontal_tile_no,,,,, 2)\
    /* used_tile_no */\
    CMD(a, b, c, d, e, int,,, used_tile_no,,,,, 2)\
    CMD(a, b, c, d, e, int,,, valid_tile_no,,,,, 2)\
    CMD(a, b, c, d, e, int,,, valid_tile_no_d,,,,, 2)\
    /* tile cal & dump order flag */\
    CMD(a, b, c, d, e, unsigned int,,, src_stream_order,,,,, 0)/* keep isp src_stream_order */\
    CMD(a, b, c, d, e, unsigned int,,, src_cal_order,,,,, 1)/* copy RDMA in_cal_order */\
    CMD(a, b, c, d, e, unsigned int,,, src_dump_order,,,,, 1)/* copy RDMA in_dump_order */\
    CMD(a, b, c, d, e, unsigned int,,, dual_dispatch_mode,,,,, 1)/* dispatch method */\
    /* skip tile mode by c model */\
    CMD(a, b, c, d, e, int,,, skip_tile_mode,,,,, 0)\
    /* sub mode */\
    CMD(a, b, c, d, e, int,,, found_sub_in,,,,, 2)\
    CMD(a, b, c, d, e, int,,, found_sub_out,,,,, 2)\
	/* frame mode flag */\
    CMD(a, b, c, d, e, int,,, first_pass,,,,, 2)/* first pass to run min edge & min tile cal */\
    /* first func no */\
    CMD(a, b, c, d, e, int,,, first_func_en_no,,,,, 2)\
    /* last func no */\
    CMD(a, b, c, d, e, int,,, last_func_en_no,,,,, 2)\
    /* tdr skip flag */\
    CMD(a, b, c, d, e, int,,, tdr_dump_skip,,,,, 2)\
    CMD(a, b, c, d, e, int,,, tdr_skip_count,,,,, 2)\
	/* last irq count for sorting & skip tdr */\
    CMD(a, b, c, d, e, int,,, last_irq_en,,,,, 2)\
    CMD(a, b, c, d, e, int,,, irq_disable_count,,,,, 2)\
    /* skip tile mode by c model */\
    CMD(a, b, c, d, e, int,,, run_c_model_direct_link,,,,, 1)\
    /* debug mode with invalid offset to enable recursive forward*/\
    CMD(a, b, c, d, e, int,,, recursive_forward_en,,,,, 2)\
    /* max input width */\
    CMD(a, b, c, d, e, int,,, max_input_width,,,,, 2)\
    /* max input height */\
    CMD(a, b, c, d, e, int,,, max_input_height,,,,, 2)\
    /* max input width */\
    CMD(a, b, c, d, e, int,,, max_input_width_wpe,,,,, 2)\
    /* max input height */\
    CMD(a, b, c, d, e, int,,, max_input_height_wpe,,,,, 2)\
    /* max input width */\
    CMD(a, b, c, d, e, int,,, max_input_width_eaf,,,,, 2)\
    /* max input height */\
    CMD(a, b, c, d, e, int,,, max_input_height_eaf,,,,, 2)\
	/* max input width */\
    CMD(a, b, c, d, e, int,,, max_input_width_bld,,,,, 2)\
    /* max input height */\
    CMD(a, b, c, d, e, int,,, max_input_height_bld,,,,, 2)\
    /* Tile IRQ */\
    CMD(a, b, c, d, e, int,,, TDR_EDGE,,,,, 2)\
    CMD(a, b, c, d, e, int,,, CDP_TDR_EDGE,,,,, 2)\
    CMD(a, b, c, d, e, int,,, TILE_IRQ,,,,, 2)\
    CMD(a, b, c, d, e, int,,, LAST_IRQ,,,,, 2)\
    CMD(a, b, c, d, e, int,,, CTRL_TILE_LOAD_SIZE,,,,, 2)\
    CMD(a, b, c, d, e, int,,, WPE_CTRL_TILE_LOAD_SIZE,,,,, 2)\
    CMD(a, b, c, d, e, int,,, WPE2_CTRL_TILE_LOAD_SIZE,,,,, 2)\
    CMD(a, b, c, d, e, int,,, EAF_CTRL_TILE_LOAD_SIZE,,,,, 2)\
    CMD(a, b, c, d, e, int,,, BLD_CTRL_TILE_LOAD_SIZE,,,,, 2)\

#define REG_CMP_EQ(ptr, reg, val) ((val) == (ptr)->reg)
#define REG_CMP_NOT_EQ(ptr, reg, val) ((val) != (ptr)->reg)
#define REG_CMP_NONZERO(ptr, reg) ((ptr)->reg)
#define REG_CMP_LE(ptr, reg, val) ((ptr)->reg <= (val))
#define REG_CMP_GE(ptr, reg, val) ((ptr)->reg >= (val))
#define REG_CHECK_EN(ptr, reg) (1 == (ptr)->reg)
#define REG_CHECK_DISABLED(ptr, reg) (0 == (ptr)->reg)
#define REG_CMP_AND(ptr, reg, val)  ((val) == ((ptr)->reg & (val)))
#define REG_CMP_NAND(ptr, reg, val)  (!((val) == ((ptr)->reg & (val))))
#define REG_VAL(ptr, reg) ((ptr)->reg)

/* a, b reserved */
/* c: ptr of tile_reg_map, reserved */
/* tile module scenario/submode reg */
/* function id, same one must put together for macro code to check */
/* function name */
/* last function id */
/* last function name */
#ifndef TILE_NEW_ENG_TEST
#define TILE_SUPPORT_FUN_LUT(LABEL, CMD, a, b, c, d, e, f) \
    LABEL##_TILE_SUPPORT_FUN_LUT(CMD, a, b, c, d, e, f)

#else
/* for new tile engine check only */
#define TILE_SUPPORT_FUN_LUT(LABEL, CMD, a, b, c, d, e, f) \
    LABEL##_TILE_SUPPORT_FUN_MAP(CMD, a, b, c, d, e, f)

#define DIP_TILE_SUPPORT_FUN_MAP	DIP_TILE_SUPPORT_FUN_LUT
#define WPE_TILE_SUPPORT_FUN_MAP	WPE_TILE_SUPPORT_FUN_LUT
#define EAF_TILE_SUPPORT_FUN_MAP	EAF_TILE_SUPPORT_FUN_LUT
#define BLD_TILE_SUPPORT_FUN_MAP	BLD_TILE_SUPPORT_FUN_LUT
#define MDP_TILE_SUPPORT_FUN_MAP	MDP_TILE_SUPPORT_FUN_LUT
#endif

/* Sub RDMA func support lut */
/* a, c, d, e reserved */
/* b: reg_map ptr reserved */
/* valid condition */
/* RDMA id, same one must put together for macro code to check */
/* RDMA func name */
/* property clone func id */
/* property clone fun name */
#ifndef TILE_NEW_ENG_TEST
#define TILE_SUB_RDMA_FUNC_SUPPORT_LUT(LABEL, CMD, a, b, c, d, e) \
    LABEL##_TILE_SUB_RDMA_FUNC_SUPPORT_LUT(CMD, a, b, c, d, e)

#else
/* for new tile engine check only */
#define TILE_SUB_RDMA_FUNC_SUPPORT_LUT(LABEL, CMD, a, b, c, d, e) \
    LABEL##_TILE_SUB_RDMA_FUNC_SUPPORT_MAP(CMD, a, b, c, d, e)

#define DIP_TILE_SUB_RDMA_FUNC_SUPPORT_MAP	DIP_TILE_SUB_RDMA_FUNC_SUPPORT_LUT
#define WPE_TILE_SUB_RDMA_FUNC_SUPPORT_MAP	WPE_TILE_SUB_RDMA_FUNC_SUPPORT_LUT
#define EAF_TILE_SUB_RDMA_FUNC_SUPPORT_MAP	EAF_TILE_SUB_RDMA_FUNC_SUPPORT_LUT
#define BLD_TILE_SUB_RDMA_FUNC_SUPPORT_MAP	BLD_TILE_SUB_RDMA_FUNC_SUPPORT_LUT
#define MDP_TILE_SUB_RDMA_FUNC_SUPPORT_MAP	MDP_TILE_SUB_RDMA_FUNC_SUPPORT_LUT
#endif

/* enable register LUT */
/* a, b, c, d reserved */
/* d: ptr of tile_reg_map, reserved */
/* function id */
/* function name */
/* tile module enable reg */
#ifndef TILE_NEW_ENG_TEST
#define TILE_FUNC_ENABLE_LUT(LABEL, CMD, a, b, c, d, e) \
    LABEL##_TILE_FUNC_ENABLE_LUT(CMD, a, b, c, d, e)

#else
/* for new tile engine check only */
#define TILE_FUNC_ENABLE_LUT(LABEL, CMD, a, b, c, d, e) \
    LABEL##_TILE_FUNC_ENABLE_MAP(CMD, a, b, c, d, e)

#define DIP_TILE_FUNC_ENABLE_MAP	DIP_TILE_FUNC_ENABLE_LUT
#define WPE_TILE_FUNC_ENABLE_MAP	WPE_TILE_FUNC_ENABLE_LUT
#define EAF_TILE_FUNC_ENABLE_MAP	EAF_TILE_FUNC_ENABLE_LUT
#define BLD_TILE_FUNC_ENABLE_MAP	BLD_TILE_FUNC_ENABLE_LUT
#define MDP_TILE_FUNC_ENABLE_MAP	MDP_TILE_FUNC_ENABLE_LUT
#endif

/* output disable register LUT */
/* a, b, c, d reserved */
/* d: ptr of tile_reg_map, reserved */
/* function id */
/* function name */
/* tile module output disable reg */
#ifndef TILE_NEW_ENG_TEST
#define TILE_FUNC_OUTPUT_DISABLE_LUT(LABEL, CMD, a, b, c, d, e) \
    LABEL##_TILE_FUNC_OUTPUT_DISABLE_LUT(CMD, a, b, c, d, e)

#else
/* for new tile engine check only */
#define TILE_FUNC_OUTPUT_DISABLE_LUT(LABEL, CMD, a, b, c, d, e) \
    LABEL##_TILE_FUNC_OUTPUT_DISABLE_MAP(CMD, a, b, c, d, e)

#define DIP_TILE_FUNC_OUTPUT_DISABLE_MAP	DIP_TILE_FUNC_OUTPUT_DISABLE_LUT
#define WPE_TILE_FUNC_OUTPUT_DISABLE_MAP	WPE_TILE_FUNC_OUTPUT_DISABLE_LUT
#define EAF_TILE_FUNC_OUTPUT_DISABLE_MAP	EAF_TILE_FUNC_OUTPUT_DISABLE_LUT
#define BLD_TILE_FUNC_OUTPUT_DISABLE_MAP	BLD_TILE_FUNC_OUTPUT_DISABLE_LUT
#define MDP_TILE_FUNC_OUTPUT_DISABLE_MAP	MDP_TILE_FUNC_OUTPUT_DISABLE_LUT
#endif

/* a, b c, d, e reserved */
/* function id */
/* function name */
/* tile type: 0x1 non-fixed func to configure, 0x2 rdma, 0x4 wdma, 0x8 crop_en */
/* tile group, 0: ISP group, 1: CDP group 2: resizer with offset & crop */
/* tile group except for 2 will restrict last end < current end (to ensure WDMA end at same time) */
/* tile loss, l_loss, r_loss, t_loss, b_loss, in_x, int_y, out_x, out_y */
/* init function name, default NULL */
/* forward function name, default NULL */
/* back function name, default NULL */
/* calculate tile reg function name, default NULL */
/* input tile constraint, 0: no check, 1: to clip when enabled */
/* output tile constraint, 0: no check, 1: to clip when enabled */
#define TILE_TYPE_LOSS (0x1)/* post process by c model */
#define TILE_TYPE_RDMA (0x2)
#define TILE_TYPE_WDMA (0x4)
#define TILE_TYPE_CROP_EN (0x8)
#define TILE_TYPE_DONT_CARE_END (0x10) /* used by dpframework & sub_out*/

/* edge enum */
typedef enum TILE_TDR_EDGE_GROUP_ENUM
{
    TILE_TDR_EDGE_GROUP_DEFAULT= 0,/* pass by last module */
    TILE_TDR_EDGE_GROUP_ISP,
    TILE_TDR_EDGE_GROUP_CDP,
    TILE_TDR_EDGE_GROUP_MDP,
    TILE_TDR_EDGE_GROUP_WDMA,/* wdma, end at same time */
    TILE_TDR_EDGE_GROUP_OTHER,/* don't care */
	TILE_TDR_EDGE_GROUP_NO
}TILE_TDR_EDGE_GROUP_ENUM;

#define TILE_INIT_PROPERTY_LUT(LABEL, CMD, a, b, c, d, e, f, g, h) \
    LABEL##_TILE_INIT_PROPERTY_LUT(CMD, a, b, c, d, e, f, g, h)

/* a, b, d, e, f reserved */
/* max_count: upper bound of dump hex, result: isp result */
/* c: ptr of tile_reg_map, reserved */
/* id of dump word, first line should be 0, other id can be different between neighboring dump word */
/* valid logic condition to dump */
/* register field name of c model to merge */
/* mask of register field */
#ifndef TILE_NEW_ENG_TEST
#define TILE_SUPPORT_DUMP_LUT(LABEL, CMD, a, b, c, d, e, f, max_count, result, word_no) \
    LABEL##_TILE_SUPPORT_DUMP_LUT(CMD, a, b, c, d, e, f, max_count, result, word_no)\

#define TILE_SUPPORT_DUMP_LUT_INTERNAL(LABEL, CMD, a, b, c, d, e, f, max_count, result, word_no) \
    LABEL##_TILE_SUPPORT_DUMP_LUT_INTERNAL(CMD, a, b, c, d, e, f, max_count, result, word_no)\

#else
/* for new tile engine check only */
#define TILE_SUPPORT_DUMP_LUT(LABEL, CMD, a, b, c, d, e, f, max_count, result, word_no) \
    LABEL##_TILE_SUPPORT_DUMP_MAP(CMD, a, b, c, d, e, f, max_count, result, word_no)\

#define TILE_SUPPORT_DUMP_LUT_INTERNAL(LABEL, CMD, a, b, c, d, e, f, max_count, result, word_no) \
    LABEL##_TILE_SUPPORT_DUMP_MAP_INTERNAL(CMD, a, b, c, d, e, f, max_count, result, word_no)\

#define DIP_TILE_SUPPORT_DUMP_MAP						WPE_TILE_SUPPORT_DUMP_LUT
#define DIP_TILE_SUPPORT_DUMP_MAP_INTERNAL		WPE_TILE_SUPPORT_DUMP_LUT_INTERNAL
#define WPE_TILE_SUPPORT_DUMP_MAP						EAF_TILE_SUPPORT_DUMP_LUT
#define WPE_TILE_SUPPORT_DUMP_MAP_INTERNAL		EAF_TILE_SUPPORT_DUMP_LUT_INTERNAL
#define EAF_TILE_SUPPORT_DUMP_MAP						BLD_TILE_SUPPORT_DUMP_LUT
#define EAF_TILE_SUPPORT_DUMP_MAP_INTERNAL		BLD_TILE_SUPPORT_DUMP_LUT_INTERNAL
#define BLD_TILE_SUPPORT_DUMP_MAP						DIP_TILE_SUPPORT_DUMP_LUT
#define BLD_TILE_SUPPORT_DUMP_MAP_INTERNAL		DIP_TILE_SUPPORT_DUMP_LUT_INTERNAL
#define MDP_TILE_SUPPORT_DUMP_MAP						MDP_TILE_SUPPORT_DUMP_LUT
#define MDP_TILE_SUPPORT_DUMP_MAP_INTERNAL		MDP_TILE_SUPPORT_DUMP_LUT_INTERNAL
#endif

/* a: add old, b: addr new, c: str name */
#define TILE_CPP_CODE_PRINTF_ISP_REG_ADDR_NAME(a, b, c, d, e, f, g, h, i, j, k, m, n, p, q, r, s,...) \
	{\
		unsigned int temp_addr = (size_t)(&((d)->m));\
		if ((a) < temp_addr)\
		{\
			if ((a) == (b))\
			{\
				unsigned int temp_addr_d = (size_t)(&((d)->r));\
				(b) = temp_addr;\
				tile_sprintf(c, sizeof(c), "\tCMD(a, b, c, 0x%08X, 0x%08X, %s, 0x%08X, %s)\\\r\n",\
					temp_addr - (e), temp_addr, #m, temp_addr_d, #r);\
			}\
			else\
			{\
				if (temp_addr < (b))\
				{\
					unsigned int temp_addr_d = (size_t)(&((d)->r));\
					(b) = temp_addr;\
					tile_sprintf(c, sizeof(c), "\tCMD(a, b, c, 0x%08X, 0x%08X, %s, 0x%08X, %s)\\\r\n",\
						temp_addr - (e), temp_addr, #m, temp_addr_d, #r);\
				}\
			}\
		}\
	}\

/* a: add old, b: addr new, c: str name */
#define TILE_FPRINTF_ISP_REG_ADDR_VAL(a, b, c, d, e, f, g, h, i, j, k, m, n, p, q, r, s,...) \
	{\
		unsigned int temp_addr = (size_t)(&((d)->m));\
		if ((a) < temp_addr)\
		{\
			if ((a) == (b))\
			{\
				(b) = temp_addr;\
				(c) = (unsigned int)ISP_REG((e), m);\
				/* debug display */\
				/* tile_driver_printf("addr: 0x%08X, name: %s, val: 0x%08X\r\n", b, #m, c);*/\
			}\
			else\
			{\
				if (temp_addr < (b))\
				{\
					(b) = temp_addr;\
					(c) = (unsigned int)ISP_REG((e), m);\
					/* debug display */\
					/* tile_driver_printf("addr: 0x%08X, name: %s, val: 0x%08X\r\n", b, #m, c);*/\
				}\
			}\
		}\
		temp_addr = (size_t)(&((d)->r));\
		if ((a) < temp_addr)\
		{\
			if ((a) == (b))\
			{\
				(b) = temp_addr;\
				(c) = (unsigned int)ISP_REG((e), r);\
				/* debug display */\
				/* tile_driver_printf("addr: 0x%08X, name: %s, val: 0x%08X\r\n", b, #m, c);*/\
			}\
			else\
			{\
				if (temp_addr < (b))\
				{\
					(b) = temp_addr;\
					(c) = (unsigned int)ISP_REG((e), r);\
					/* debug display */\
					/* tile_driver_printf("addr: 0x%08X, name: %s, val: 0x%08X\r\n", b, #m, c);*/\
				}\
			}\
		}\
	}\

/* a: add old, b: addr new, c: str name */
#define TILE_FREAD_ISP_REG_ADDR_VAL(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) \
	if ((a) == (size_t)(&(d.addr->m)))\
	{\
		ISP_REG(((d).val), m) = (b);\
		(c) = true;\
		(e).val->i = ISP_BITS(((d).val), m, n);\
		(e).flag->i = 0x1;\
		/* debug display */\
		/* tile_driver_printf("addr: 0x%08X, name: %s, field: %s, val: 0x%08X\r\n", a, #m, #n, e.val->i);*/\
	}\

/* wrapper macro codes */
#define TILE_WRAPPER_DATA_TYPE_EXTERN(a, b, c, d, e, f, g, h, i, j, k, m, n,...) extern f g j;
#define TILE_WRAPPER_DATA_TYPE_DECLARE(a, b, c, d, e, f, g, h, i, j, k, m, n,...) f g j;
#define TILE_HW_REG_TYPE_DECLARE(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) f i j;
#define TILE_WRAPPER_CURRENT_CMODEL_COPY(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) read_int_register_by_name(&(a)->i, g);
#define TILE_WRAPPER_CURRENT_CMODEL_COPY_D(a, b, c, d, e, f, g, h, i, j, k, m, n, p, q, r, s,...) read_int_register_by_name(&(a)->i, q);
#define TILE_WRAPPER_CURRENT_CMODEL_COPY_PATH(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) (a)->i = (f)g;
#define TILE_INTERNAL_REG_CLEAR(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) (a)->i = 0;
/* data copy from reg to reg */
#define TILE_WRAPPER_REG_COPY(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) \
	if ((1 == (p)) && ((a)->i != (b)->i))/* replace */\
	{\
		tile_driver_printf("replace reg %s, old val: %d, new val: %d\r\n", #i, (a)->i, (b)->i);\
		(a)->i = (b)->i;\
	}\

/* output c model param cpp file */
#define TILE_WRAPPER_DATA_PRINT_CPP(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) \
{\
	int $SECOND_NAME$_##g = 0;\
	read_int_register_by_name(&$SECOND_NAME$_##g, g);\
	b(a, "%s %s%s%s%d;\r\n", #f, #g, #j, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, $SECOND_NAME$_##g);\
}\

/* output c model param cpp file */
#define TILE_WRAPPER_DATA_PRINT_CPP_D(a, b, c, d, e, f, g, h, i, j, k, m, n, p, q, r, s,...) \
{\
	int $SECOND_NAME$_##q = 0;\
	read_int_register_by_name(&$SECOND_NAME$_##q, q);\
	b(a, "%s %s%s%s%d;\r\n", #f, #q, #j, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, $SECOND_NAME$_##q);\
}\

/* output c model param cpp file */
#define TILE_WRAPPER_DATA_PRINT_CPP_PATH(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) b(a, "%s %s%s%s\"%s\"\r\n", #f, #g, #j, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, g);
/* data copy from reg to platform param */
#define TILE_WRAPPER_REG_TO_PLATFORM_COPY_ISP(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) (a)->h = (b)->i;
/* data search & copy log to platform param */
#define TILE_WRAPPER_PLATFORM_DATA_CMP_FILL_VAL(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) \
    if (false == (d))\
    {\
		char *ptr_chr = strstr(b, #h);\
		if (ptr_chr)\
		{\
			if (0 == memcmp(ptr_chr + sizeof(#h) - 1, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, sizeof(TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR) - 1))\
			{\
				(a)->h = (c);\
				(d) = true;\
			}\
        }\
    }\

#define TILE_WRAPPER_PLATFORM_DATA_CMP_FILL_VAL_FLAG_ISP(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) \
    if (false == (d))\
    {\
		char *ptr_chr = (char *)strstr(b, #h);\
		if (ptr_chr)\
		{\
			if (0 ==  memcmp(ptr_chr + sizeof(#h) - 1, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, sizeof(TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR) - 1))\
			{\
				(a)->i = (c);\
				(e)->i = 1;\
				(d) = true;\
			}\
		}\
    }\

#define TILE_WRAPPER_REG_CMP_FILL_VAL_FLAG_ISP(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) \
    if ((size_t)((b).addr) == size_t(&((d).addr->m)))\
    {\
        if ((a).flag->i)\
        {\
            tile_driver_printf("-------------------------------------------------------\r\n");\
            tile_driver_printf("Warning duplicated to overwrite addr: 0x%08X\r\n", (b).addr);\
            tile_driver_printf("name: %s, field: %s\r\n", #m, #n);\
            tile_driver_printf("last val: 0x%08X, new val: 0x%08X\r\n", (a).val->i, (b).val);\
            tile_driver_printf("-------------------------------------------------------\r\n");\
        }\
        ISP_REG((d.val), m) = (b).val;\
        (a).val->i = ISP_BITS(((d).val), m, n);\
        (a).flag->i = 1;\
        /* debug display */\
        /*printf("addr: 0x%08X, name: %s, field: %s, val: 0x%08X\r\n", b.addr, #m, #n, (a).val->i);*/\
        (c)++;\
    }\

#define TILE_WRAPPER_REG_DATA_CMP_FILL_VAL_FLAG(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) \
    if (false == (d))\
    {\
		char *ptr_chr = (char *)strstr(b, #i);\
		if (ptr_chr)\
		{\
			if (0 ==  memcmp(ptr_chr + sizeof(#i) - 1, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, sizeof(TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR) - 1))\
			{\
				(a)->i = (c);\
				(e)->i = 1;\
				(d) = true;\
			}\
		}\
    }\

/* data search & update reg mapper */
/* a: ptr_reg */
/* b: cmp str */
/* c: value to fill */
/* d: found flag */
#define TILE_UT_REG_CMP_FILL_VAL(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) \
    if (false == (d))\
    {\
		if (0 == memcmp(b, #i, sizeof(#i)))\
		{\
			(a)->i = (c);\
			(d) = true;\
		}\
    }\

/* data search & update reg mapper */
/* a: ptr_reg */
/* b: cmp str */
/* c: value to fill */
/* d: found flag */
/* e: ptr_reg_flag */
#define TILE_DIRECT_LINK_REG_FILL_VAL_FLAG(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) \
    if (false == (d))\
    {\
		if (0 == memcmp(b, #i, sizeof(#i)))\
		{\
			(a)->i = (c);\
			(e)->i = true;\
			(d) = true;\
		}\
    }\

/* data search & update reg mapper */
/* a: ptr_reg */
/* b: ptr_reg */
/* c: ptr_reg_flag */
/* d: diff count */
/* e: lost count */
#define TILE_DIRECT_LINK_REG_CMP_FILL_VAL_FLAG(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) \
	if ((0 == (p)) || (1 == (p)))/* must & replaced */\
	{\
		if ((c)->i)/* must */\
		{\
			if (0 == (p))\
			{\
				if ((a)->i != (b)->i)\
				{\
					(d)++;\
					tile_driver_printf("Diff reg %s, isp: %d, direct: %d\r\n", #i, (a)->i, (b)->i);\
				}\
			}\
		}\
		else\
		{\
			(e)++;\
			tile_driver_printf("Lost isp reg %s\r\n", #i);\
		}\
	}\

/* data copy from platform to reg param */
#define TILE_WRAPPER_ISP_HW_TO_REG_COPY(a, b, c, d, e, f, g, h, i, j, k, m, n, p, q, r, s,...) \
    (b)->i = (int)ISP_BITS((a), m, n);\
    (c)->i = true;\
    (d)->i = (int)ISP_BITS((a), r, s);\
    (e)->i = true;\

/* data copy from platform to reg param */
#define TILE_WRAPPER_ISP_REG_TO_HW_COPY(a, b, c, d, e, f, g, h, i, j, k, m, n, p, q, r, s,...) \
	if ((c)->tile_sel_mode & TILE_SEL_SUM_A)\
	{\
		if (ISP_BITS((b), m, n))\
		{\
			printf("Warning duplicated hw reg with last val: 0x%08X\r\n", ISP_BITS((a), m, n));\
			printf("Overwrite by isp reg name: %s\r\n",#i);\
			printf("hw reg: %s, field: %s\r\n",#m, #n);\
			printf("val: 0x%08X\r\n", (c)->i);\
			printf("-------------------------------------------------------\r\n");\
		}\
		ISP_BITS((a), m, n) = (c)->i;\
		ISP_BITS((b), m, n) =  true;\
	}\
	if ((c)->tile_sel_mode & TILE_SEL_SUM_B)\
	{\
		if (ISP_BITS((b), r, s))\
		{\
			printf("Warning duplicated hw reg with last val: 0x%08X\r\n", ISP_BITS((a), r, s));\
			printf("Overwrite by isp reg name: %s\r\n",#i);\
			printf("hw reg: %s, field: %s\r\n",#r, #s);\
			printf("val: 0x%08X\r\n", (c)->i);\
			printf("-------------------------------------------------------\r\n");\
		}\
		ISP_BITS((a), r, s) = (c)->i;\
		ISP_BITS((b), r, s) =  true;\
	}\

/* data copy from platform to reg param */
#define TILE_WRAPPER_ISP_CONFIG_TO_HW_COPY(a, b, c, d, e, f, g, h, i, j, k, m, n, p, q, r, s,...) \
	if ((c)->sw.tpipe_sel_mode & TILE_SEL_SUM_A)\
	{\
		if (ISP_BITS((b), m, n))\
		{\
			printf("Warning duplicated hw reg with last val: 0x%08X\r\n", ISP_BITS((a), m, n));\
			printf("Overwrite by isp config name: %s\r\n", #h);\
			printf("hw reg: %s, field: %s\r\n", #m, #n);\
			printf("val: 0x%08X\r\n", (c)->h);\
			printf("-------------------------------------------------------\r\n");\
		}\
		ISP_BITS((a), m, n) = (c)->h;\
		ISP_BITS((b), m, n) =  true;\
	}\
	if ((c)->sw.tpipe_sel_mode & TILE_SEL_SUM_B)\
	{\
		if (ISP_BITS((b), r, s))\
		{\
			printf("Warning duplicated hw reg with last val: 0x%08X\r\n", ISP_BITS((a), r, s));\
			printf("Overwrite by config reg name: %s\r\n", #h);\
			printf("hw reg: %s, field: %s\r\n",#r, #s);\
			printf("val: 0x%08X\r\n", (c)->h);\
			printf("-------------------------------------------------------\r\n");\
		}\
		ISP_BITS((a), r, s) = (c)->h;\
		ISP_BITS((b), r, s) =  true;\
	}\

/* data copy from platform to reg param */
#define TILE_WRAPPER_PLATFORM_TO_REG_COPY_ISP(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) (a)->i = (b)->h;
/* output c model param txt file */
#define TILE_WRAPPER_DATA_PRINT_TXT(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) c(a, "%s%s%s%d\r\n", #i, #j, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, (b)->i);
#define TILE_WRAPPER_DATA_PRINT_PATH(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) if ((b)->i) c(a, "%s%s%s%s\r\n", #i, #j, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, (b)->i);
/* output platform param txt file by fprintf */
#define TILE_WRAPPER_PLATFORM_PRINT_TXT_ISP(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) \
    d(a, "%s %s%s%s%d %s\r\n", TPIPE_DEBUG_DUMP_HEADER, #h, #j, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, (b)->h, (k)?LOG_REMARK_MUST_FILL_STR:"");
#define TILE_WRAPPER_PLATFORM_DEBUG_PRINT_TXT(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) \
    c(a, "%s %s%s%s%d %s\r\n", TPIPE_DEBUG_DUMP_HEADER, #i, #j, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, (b)->i, LOG_REMARK_DEBUG_STR);
/* output platform param txt file uart printf */
#define TILE_WRAPPER_PLATFORM_ISP_UART_PRINT_TXT(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) \
    a("%s %s%s%s%d %s\r\n", TPIPE_DEBUG_DUMP_HEADER, #h, #j, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, (b)->h, (c)?((k)?LOG_REMARK_MUST_FILL_STR:""):"");
#define TILE_WRAPPER_PLATFORM_UART_DEBUG_PRINT_TXT(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) \
    a("%s %s%s%s%d %s\r\n", TPIPE_DEBUG_DUMP_HEADER, #i, #j, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR,\
    (b)->i, LOG_REMARK_DEBUG_STR);
#define TILE_WRAPPER_PLATFORM_PRINT_TXT_BY_FLAG_ISP(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) \
    fprintf(a, "%s %s%s%s%d %s%s\r\n", TPIPE_DEBUG_DUMP_HEADER, #h, #j,\
    TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, (b)->i, (k)?LOG_REMARK_MUST_FILL_STR:"",\
    ((d)->i)?"":LOG_REMARK_NOT_FOUND_STR);
#define TILE_WRAPPER_PLATFORM_PRINT_TXT_NO_HW_LOG_FLAG_ISP(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) \
    fprintf(a, "%s %s%s%s%d %s%s%s\r\n", TPIPE_DEBUG_DUMP_HEADER, #h, #j,\
    TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, (b)->i, (k)?LOG_REMARK_MUST_FILL_STR:"",\
    ((d)->i)?"":LOG_REMARK_NOT_FOUND_STR, LOG_REMARK_HW_REG_STR);
#define TILE_WRAPPER_PLATFORM_PRINT_TXT_BY_FLAG_WITH_REG_CHECK_ISP(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) \
    if ((e).flag->i)/* hw reg flag true */\
    {\
        if ((d)->i)/* with tile log*/\
    {\
            if (((b)->i) == (int)((e).val->i))\
            {\
                fprintf(a, "%s %s%s%s%d %s\r\n", TPIPE_DEBUG_DUMP_HEADER, #h, #j, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR,\
                    (b)->i, (k)?LOG_REMARK_MUST_FILL_STR:"");\
            }\
            else\
            {\
                fprintf(a, "%s %s%s%s%d %s%s%d\r\n", TPIPE_DEBUG_DUMP_HEADER, #h, #j, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR,\
                    (b)->i, (k)?LOG_REMARK_MUST_FILL_STR:"", LOG_REMARK_HW_DIFF_STR, ((e).val->i));\
            }\
        }\
        else/* no tile log*/\
        {\
            fprintf(a, "%s %s%s%s%d %s%s%s%d\r\n", TPIPE_DEBUG_DUMP_HEADER, #h, #j, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR,\
                (b)->i, LOG_REMARK_NOT_FOUND_STR, (k)?LOG_REMARK_MUST_FILL_STR:"", LOG_REMARK_HW_LOG_STR, ((e).val->i));\
        }\
    }\
    else/* hw reg flag false */\
    {\
        fprintf(a, "%s %s%s%s%d %s%s%s\r\n", TPIPE_DEBUG_DUMP_HEADER, #h, #j,\
            TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, (b)->i, (k)?LOG_REMARK_MUST_FILL_STR:"",\
            ((d)->i)?"":LOG_REMARK_NOT_FOUND_STR, LOG_REMARK_HW_NOT_FOUND_STR);\
    }\

#define TILE_WRAPPER_CHECK_REG_SEL(a, b, c, d, e, f, g, h, i, j, k, m, n, p, q, r, s,...) \
    if ((b).flag->i && (c).flag->i)/* same hw reg flag */\
    {\
		if ((b).val->i == (c).val->i)\
		{\
			fprintf(a, "%s.%s%s0x%X /* %s.%s %s */\r\n", #m, #n, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR,\
				(b).val->i, #r, #s, (4 == p)?LOG_REMARK_MUST_FILL_STR:"");\
		}\
		else\
		{\
			if (4 == p)\
			{\
				printf("%s.%s%s0x%X %s %s.%s%s0x%X %s\r\n", #m, #n, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR,\
					(b).val->i, LOG_REMARK_HW_DIFF_STR, #r, #s, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR,\
					(c).val->i, (4 == p)?LOG_REMARK_MUST_FILL_STR:"");\
				(e)++;\
			}\
			fprintf(a, "%s.%s%s0x%X %s /* %s.%s%s0x%X %s */\r\n", #m, #n, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR,\
				(b).val->i, LOG_REMARK_HW_DIFF_STR, #r, #s, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR,\
				(c).val->i, (4 == p)?LOG_REMARK_MUST_FILL_STR:"");\
        }\
    }\
    else/* hw reg flag false */\
    {\
		if (4 == p)\
		{\
			printf("%s.%s%s0x%X %s %s.%s%s0x%X %s%s\r\n", #m, #n, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR,\
				(b).val->i, (b).flag->i?"":LOG_REMARK_HW_NOT_FOUND_STR, #r, #s, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR,\
				(c).val->i, (c).flag->i?"":LOG_REMARK_HW_NOT_FOUND_STR, (4 == p)?LOG_REMARK_MUST_FILL_STR:"");\
			(d)++;\
		}\
		fprintf(a, "%s.%s%s0x%X %s /* %s.%s%s0x%X %s%s */\r\n", #m, #n, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR,\
			(b).val->i, (b).flag->i?"":LOG_REMARK_HW_NOT_FOUND_STR, #r, #s, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR,\
			(c).val->i, (c).flag->i?"":LOG_REMARK_HW_NOT_FOUND_STR, (4 == p)?LOG_REMARK_MUST_FILL_STR:"");\
    }\

#define TILE_ISP_REG_OFFSET_MASK_LSB_CODE_GEN(a, b, c, d, e, f, g, h, i, j, k, m, n, o, p, q, r,...) \
    if (o == 4)\
    {\
        int temp_count = 0;\
		unsigned int temp_offset = 0;\
		temp_offset = (size_t)(4*(&((a).m.Raw) - (unsigned int *)&(a)));\
        (a).m.Raw = 0x0;\
        (a).m.Bits.n |= 0xFFFFFFFF;\
        for ((temp_count)=0;(temp_count)<32;(temp_count)++)\
        {\
            if (0x1 & (((a).m.Raw)>>(temp_count)))\
            {\
                break;\
            }\
        }\
        fprintf(d, "\tCMD(a, b, c, d, e, %s, %s, 0x%08X, 0x%08X, 0x%08X, %d, %s, %s, ",\
			#h, #k, temp_offset, temp_offset + (b), (a).m.Raw, temp_count, #m, #n);\
		/* dual reg */\
        temp_offset = (size_t)(4*(&((a).q.Raw) - (unsigned int *)&(a)));\
        (a).q.Raw = 0x0;\
        (a).q.Bits.r |= 0xFFFFFFFF;\
        for ((temp_count)=0;(temp_count)<32;(temp_count)++)\
        {\
            if (0x1 & (((a).q.Raw)>>(temp_count)))\
            {\
                break;\
            }\
        }\
        fprintf(d, "0x%08X, 0x%08X, 0x%08X, %d, %s, %s)\\\r\n", temp_offset, temp_offset + (b), (a).q.Raw, temp_count, #q, #r);\
    }\

/* b: ptr_isp_reg_t */
/* c: ptr_reg_map_struct */
#define TILE_TPIPE_CONF_AND_ISP_REG_CMP(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s,...) \
    if(g)\
    {\
		if (0x1 & (d)->sw.tpipe_sel_mode)\
		{\
			int value = (*(((unsigned int*)(b))+(h>>2))>>k) & (j>>k) ;\
			if (value != (d)->f)\
			{\
				if (a)\
        		{\
					fprintf(a, "%s.%s%s%d%s%d\r\n", #l, #m, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, value, LOG_REMARK_HW_DIFF_STR, (d)->f);\
				}\
				e++;\
			}\
		}\
		if (0x2 & (d)->sw.tpipe_sel_mode)\
		{\
			int value = (*(((unsigned int*)(b))+((n)>>2))>>q) & (p>>q) ;\
			if (value != (d)->f)\
			{\
				if (a)\
        		{\
					fprintf(a, "%s.%s%s%d%s%d\r\n", #r, #s, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, value, LOG_REMARK_HW_DIFF_STR, (d)->f);\
				}\
				e++;\
			}\
		}\
    }\

/* b: ptr_isp_reg_t */
/* c: ptr_reg_map_struct */
#define TILE_TPIPE_CONF_AND_ISP_REG_CMP_PLATFORM(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s,...) \
    if (g)\
    {\
		if (0x1 & (d)->sw.tpipe_sel_mode)\
		{\
			int value = (*(((unsigned int*)(b))+(h>>2))>>k) & (j>>k) ;\
	        if( value != (d)->f)\
		    {\
			    a("%s.%s%s%d%s%d\r\n", #l, #m, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, value, LOG_REMARK_HW_DIFF_STR, (d)->f);\
				e++;\
			}\
        }\
		else if (0x2 & (d)->sw.tpipe_sel_mode)\
		{\
			int value = (*(((unsigned int*)(b))+((n)>>2))>>q) & (p>>q) ;\
	        if (value != (d)->f)\
		    {\
			    a("%s.%s%s%d%s%d\r\n", #r, #s, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, value, LOG_REMARK_HW_DIFF_STR, (d)->f);\
				e++;\
			}\
		}\
    }\

#define TILE_FUNC_FPRINT_STR(a, b, c, d, e, f, g, h, i, j, k, m, n,...) \
	fprintf(a, "%s%s%s\r\n", #g, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, strrchr((b)->g, ' ')?(strrchr((b)->g, ' ')+1):(b)->g);\

#define TILE_FUNC_FPRINT_ARRAY(a, b, c, d, e, f, g, h, i, j, k, m, n,...) \
	{\
		for (unsigned int temp_i=0;temp_i<sizeof((b)->g)/sizeof(f);temp_i++)\
		{\
			fprintf(a, "%s[%d]%s%d\r\n", #g, temp_i, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, (b)->g[temp_i]);\
		}\
		fprintf(a, "--------------------------\r\n");\
	}\

#define TILE_FUNC_FPRINT_INT(a, b, c, d, e, f, g, h, i, j, k, m, n,...) fprintf(a, "%s%s%d\r\n", #g, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, (b)->g);
#define TILE_WRAPPER_PLATFORM_DEBUG_PRINT_TXT_BY_FLAG(a, b, c, d, e, f, g, h, i, j, k, m, n,...) \
    fprintf(a, "%s %s%s%s%d %s%s\r\n", TPIPE_DEBUG_DUMP_HEADER, #i, #j, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, (b)->i, LOG_REMARK_DEBUG_STR, ((d)->i)?"":LOG_REMARK_NOT_FOUND_STR);
#define TILE_WRAPPER_HORZ_PARA_DECLARE(a, b, c, d, e, f, g, h, i, j, k, m, n,...) TILE_WRAPPER_HORZ_PARA_DECLARE_##k(f, g, j)
#define TILE_WRAPPER_HORZ_PARA_DECLARE_S(f, g, j)
#define TILE_WRAPPER_HORZ_PARA_DECLARE_U(f, g, j) f g j;
#define TILE_WRAPPER_HORZ_PARA_DECLARE_M(f, g, j) TILE_WRAPPER_HORZ_PARA_DECLARE_U(f, g, j)
#define TILE_WRAPPER_HORZ_PARA_BACKUP(a, b, c, d, e, f, g, h, i, j, k, m, n,...) TILE_WRAPPER_HORZ_PARA_BACKUP_##k(a, b, g);
#define TILE_WRAPPER_HORZ_PARA_BACKUP_S(a, b, g)
#define TILE_WRAPPER_HORZ_PARA_BACKUP_U(a, b, g) (a)->g = (b)->g;
#define TILE_WRAPPER_HORZ_PARA_BACKUP_M(a, b, g)TILE_WRAPPER_HORZ_PARA_BACKUP_U(a, b, g)
#define TILE_WRAPPER_HORZ_PARA_RESTORE(a, b, c, d, e, f, g, h, i, j, k, m, n,...) TILE_WRAPPER_HORZ_PARA_RESTORE_##k(a, b, g, i);
#define TILE_WRAPPER_HORZ_PARA_RESTORE_S(a, b, g, i)
#define TILE_WRAPPER_HORZ_PARA_RESTORE_U(a, b, g, i) (b)->g = (a)->g;
#define TILE_WRAPPER_HORZ_PARA_RESTORE_M(a, b, g, i) (b)->g = (((b)->g)&(~(i) & 0xF)) | (((a)->g)&(i));

#define TILE_WRAPPER_PLATFORM_REG_CMP(a, b, c, d, e, f, g, h, i, j, k, m, n,...) \
    if ((a)->i != (b)->i)\
    {\
        (c) = ISP_MESSAGE_TILE_REG_MAP_COMP_DIFF_ERROR;\
        tile_driver_printf("Different register %s: %d, %d\r\n", #i, (a)->i, (b)->i);\
    }\

/* register convert tile function */
//a: current func no
//b: ptr of TILE_FUNC_BLOCK_STRUCT[0]
//c: func valid condition
//d: func no
//e: fun name
//f: last func no
//g: last func name
/* only select enable items */
#define TILE_MODULE_CHECK(a, b, last_no, result, group_id, c, d, e, f, g) \
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if (true == (c))\
        {\
            if ((last_no) == (d))\
            {\
				/* tile_driver_printf("Found mutli-in func: %s, id: %d, last func: %s, id: %d\r\n", #e, d, #g, f);*/\
				if (((b) + ((a)-1))->tot_prev_num < MAX_TILE_PREV_NO)\
				{\
					((b) + ((a)-1))->last_func_num[((b) + ((a)-1))->tot_prev_num] = (f);\
					((b) + ((a)-1))->tot_prev_num++;\
				}\
				else\
				{\
					result = ISP_MESSAGE_OVER_MAX_TILE_FUNC_PREV_NO_ERROR;\
					tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
				}\
            }\
            else\
            {\
				/* prevent corrupt memory */\
				if ((a) < MAX_TILE_FUNC_NO)\
				{\
					(last_no) = (d);\
					/* save memset time of overall buffer */\
					memset(((b) + (a)), 0x0, sizeof(TILE_FUNC_BLOCK_STRUCT));\
					((b) + (a))->func_num = (d);\
					if (sizeof(#e) <= MAX_TILE_FUNC_NAME_SIZE)\
					{\
						memcpy(((b) + (a))->func_name, #e, sizeof(#e));\
						((b) + (a))->last_func_num[0] = (f);\
						((b) + (a))->tot_prev_num = 1;\
						((b) + (a))->group_num = (group_id);\
						/*tile_driver_printf("Found func: %s, id: %d, last func: %s, id: %d\r\n", #e, d, #g, f);*/\
						(a)++;\
					}\
					else\
					{\
						tile_driver_printf("Error func: %s, id: %d, name size: %d, over max: %d\r\n", #e, d, (int)sizeof(#e), MAX_TILE_FUNC_NAME_SIZE);\
						(result) = ISP_MESSAGE_OVER_MAX_TILE_FUNC_NAME_SIZE_ERROR;\
						tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
					}\
				}\
				else\
				{\
					(result) = ISP_MESSAGE_OVER_MAX_TILE_FUNC_NO_ERROR;\
					tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
				}\
            }\
        }\
    }\

/* register convert tile function */
//a: current func no
//b: ptr of func_en_id[0]
//c: func id
//d: name
//e: valid condition
/* list all functions enable or not */
#define TILE_ENABLE_CHECK(a, b, last_no, result, c, d, e) \
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
		if ((last_no) != (int)(c))\
		{\
			if (last_no)\
			{\
				(a)++;\
			}\
			/* prevent corrupt memory */\
			if ((a) >= MAX_TILE_FUNC_EN_NO)\
			{\
				(result) = ISP_MESSAGE_OVER_MAX_TILE_FUNC_EN_NO_ERROR;\
				tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
			}\
			else\
			{\
				(last_no) = (c);\
				((b) + (a))->func_num = (c);\
				if (e)\
				{\
					((b) + (a))->enable_flag = true;\
				}\
				else\
				{\
					((b) + (a))->enable_flag = false;\
				}\
			}\
		}\
		else\
		{\
			if (e)\
			{\
				if (((b) + (a))->enable_flag)\
				{\
					(result) = ISP_MESSAGE_DUPLICATED_FUNC_EN_FOUND_ERROR;\
					tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
					tile_driver_printf("Duplicated func: %s, id: %d\r\n", #d, c);\
				}\
				else\
				{\
					((b) + (a))->enable_flag = true;\
				}\
			}\
		}\
    }\

/* register convert tile function */
//a: current func no
//b: ptr of func_en_id[0]
//c: func id
//d: name
//e: valid condition
/* list all functions enable or not */
#define TILE_OUTPUT_DISABLE_CHECK(a, last_no, result, b, c, d, e) \
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if (c == (a)->func_num)\
		{\
			if ((last_no) != (int)(c))\
			{\
				(last_no) = (c);\
				if (e)\
				{\
					(a)->output_disable_flag = true;\
				}\
			}\
			else\
			{\
				if (e)\
				{\
					if ((a)->output_disable_flag)\
					{\
						(result) = ISP_MESSAGE_DUPLICATED_FUNC_DISABLE_OUTPUT_FOUND_ERROR;\
						tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
						tile_driver_printf("Duplicated func: %s, id: %d\r\n", #d, c);\
					}\
					else\
					{\
						(a)->output_disable_flag = true;\
					}\
				}\
			}\
		}\
    }\

/* register convert tile function */
//a: current func no
//b: ptr of func_en_id[0]
//c: func id
//d: name
//e: master func id
//f: master name
//g: valid condition
#define TILE_SUBRDMA_CHECK(a, b, result, group_id, c, d, e, f, g) \
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        /* check enable & duplicated later */\
        if (true == (g))\
        {\
            /* prevent corrupt memory */\
            if ((a) < MAX_TILE_FUNC_SUBRDMA_NO)\
            {\
                ((b) + (a))->func_num = (c);\
                ((b) + (a))->master_func_num = (e);\
                /* clear enable & tdr func flag */\
                ((b) + (a))->enable_flag = false;\
				((b) + (a))->func_ptr_flag = 0x0;\
				((b) + (a))->group_num = (group_id);\
                (a)++;\
            }\
            else\
            {\
				(result) = ISP_MESSAGE_OVER_MAX_TILE_FUNC_SUBRDMA_LIST_NO_ERROR;\
                tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
            }\
        }\
    }\

/* init tile function */
//a: ptr of current TILE_FUNC_BLOCK_STRUCT
//b: ptr of current TILE_CAL_FUNC_STRUCT
//c: found flag
//d: reserved
//e: reserved
//f: reserved
//g: func no
//h: func name
//t1~t10: tile property
//p1~p4: fun ptr
#define INIT_TILE_FUNC(a, b, c, d, e, f, mx, my, g, h, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, p1, p2, p3, p4, r1, r2, m1, m2) \
    if (false == (b))\
    {\
        if ((g) == (a)->func_num)\
        {\
			ISP_TILE_MESSAGE_ENUM (*init_func_ptr)(TILE_FUNC_BLOCK_STRUCT *ptr_func, TILE_REG_MAP_STRUCT* ptr_tile_reg_map) = p1;\
			ISP_TILE_MESSAGE_ENUM (*for_func_ptr)(TILE_FUNC_BLOCK_STRUCT *ptr_func, TILE_REG_MAP_STRUCT* ptr_tile_reg_map) = p2;\
			ISP_TILE_MESSAGE_ENUM (*back_func_ptr)(TILE_FUNC_BLOCK_STRUCT *ptr_func, TILE_REG_MAP_STRUCT* ptr_tile_reg_map) = p3;\
			ISP_TILE_MESSAGE_ENUM (*tdr_func_ptr)(TILE_FUNC_BLOCK_STRUCT *ptr_func, TILE_REG_MAP_STRUCT* ptr_tile_reg_map) = p4;\
			(a)->run_mode = TILE_RUN_MODE_MAIN;\
			(a)->type = (t1);\
            (a)->tdr_group = (TILE_TDR_EDGE_GROUP_ENUM)(t2);\
            (a)->l_tile_loss = (t3);\
            (a)->r_tile_loss = (t4);\
            (a)->t_tile_loss = (t5);\
            (a)->b_tile_loss = (t6);\
            (a)->in_const_x = (t7);\
            (a)->in_const_y = (t8);\
            (a)->out_const_x = (t9);\
            (a)->out_const_y = (t10);\
			(a)->func_ptr_flag = 0x0;\
			(a)->group_num = (d);\
			(a)->in_min_width = (m1);\
			(a)->in_min_height = (m2);\
			if (init_func_ptr)\
			{\
				(a)->init_func_ptr = init_func_ptr;\
				(a)->func_ptr_flag |= TILE_INIT_FUNC_PTR_FLAG;\
			}\
			else\
			{\
				(a)->init_func_ptr = NULL;\
			}\
			if (for_func_ptr)\
			{\
				(a)->for_func_ptr = for_func_ptr;\
				(a)->func_ptr_flag |= TILE_FOR_FUNC_PTR_FLAG;\
			}\
			else\
			{\
				(a)->for_func_ptr = NULL;\
			}\
			if (back_func_ptr)\
			{\
				(a)->back_func_ptr = back_func_ptr;\
				(a)->func_ptr_flag |= TILE_BACK_FUNC_PTR_FLAG;\
			}\
			else\
			{\
				(a)->back_func_ptr = NULL;\
			}\
			if (tdr_func_ptr)\
			{\
				(a)->tdr_func_ptr = tdr_func_ptr;\
				(a)->func_ptr_flag |= TILE_TDR_FUNC_PTR_FLAG;\
			}\
			else\
			{\
				(a)->tdr_func_ptr = NULL;\
			}\
			if (r1)\
			{\
				if (e)\
				{\
					(a)->in_tile_width = (e);\
				}\
				else\
				{\
					if (1 == r1)\
					{\
						tile_driver_printf("Error [%s] wrong initial in tile width = 1, recover to %d\r\n", #h, f);\
						(a)->in_tile_width = (f);\
					}\
					else\
					{\
						(a)->in_tile_width = (r1);\
					}\
				}\
				(a)->in_max_width = (mx);\
				(a)->in_tile_height = MAX_TILE_HEIGHT_HW;\
				(a)->in_max_height = (my);\
			}\
			else\
			{\
				(a)->in_tile_width = 0;\
				(a)->in_max_width = 0;\
				(a)->in_tile_height = 0;\
				(a)->in_max_height = 0;\
			}\
			if (r2)\
			{\
				if (e)\
				{\
					(a)->out_tile_width = (e);\
				}\
				else\
				{\
					if (1 == r2)\
					{\
						tile_driver_printf("Error [%s] wrong initial out tile width = 1, recover to %d\r\n", #h, f);\
						(a)->out_tile_width = (f);\
					}\
					else\
					{\
						(a)->out_tile_width = (r2);\
					}\
				}\
				(a)->out_max_width = (mx);\
				(a)->out_tile_height = MAX_TILE_HEIGHT_HW;\
				(a)->out_max_height = (my);\
			}\
			else\
			{\
				(a)->out_tile_width = 0;\
				(a)->out_max_width = 0;\
				(a)->out_tile_height = 0;\
				(a)->out_max_height = 0;\
			}\
			(a)->in_log_width = 0;\
			(a)->in_log_height = 0;\
			(a)->out_log_width = 0;\
			(a)->out_log_height = 0;\
            (b) = true;\
        }\
    }\

/* init tile function */
//a: ptr of current TILE_FUNC_BLOCK_STRUCT
//b: ptr of current TILE_CAL_FUNC_STRUCT
//c: found flag
//d: reserved
//e: reserved
//f: reserved
//g: func no
//h: func name
//t1~t10: tile property
//p1~p4: fun ptr
/* module sim check */
#define INIT_TILE_FUNC_MODULE_SIM(a, b, c, d, e, f, mx, my, g, h, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, p1, p2, p3, p4, r1, r2, m1, m2) \
    if (false == (b))\
    {\
        if ((f) == (g))\
		{\
			if (mx)\
			{\
				/* prevent corrupt memory */\
				if ((e) < MAX_TILE_FUNC_NO)\
				{\
					ISP_TILE_MESSAGE_ENUM (*init_func_ptr)(TILE_FUNC_BLOCK_STRUCT *ptr_func, TILE_REG_MAP_STRUCT* ptr_tile_reg_map) = p1;\
					ISP_TILE_MESSAGE_ENUM (*for_func_ptr)(TILE_FUNC_BLOCK_STRUCT *ptr_func, TILE_REG_MAP_STRUCT* ptr_tile_reg_map) = p2;\
					ISP_TILE_MESSAGE_ENUM (*back_func_ptr)(TILE_FUNC_BLOCK_STRUCT *ptr_func, TILE_REG_MAP_STRUCT* ptr_tile_reg_map) = p3;\
					ISP_TILE_MESSAGE_ENUM (*tdr_func_ptr)(TILE_FUNC_BLOCK_STRUCT *ptr_func, TILE_REG_MAP_STRUCT* ptr_tile_reg_map) = p4;\
					/* save memset time of overall buffer */\
					memset(((a) + (e)), 0x0, sizeof(TILE_FUNC_BLOCK_STRUCT));\
					if (sizeof(#h) <= MAX_TILE_FUNC_NAME_SIZE)\
					{\
						memcpy(((a) + (e))->func_name, #h, sizeof(#h));\
					}\
					else\
					{\
						memcpy(((a) + (e))->func_name, #h, MAX_TILE_FUNC_NAME_SIZE);\
					}\
					((a) + (e))->func_num = (f);\
					((a) + (e))->run_mode = TILE_RUN_MODE_MAIN;\
					((a) + (e))->type = (t1);\
					((a) + (e))->tdr_group = (TILE_TDR_EDGE_GROUP_ENUM)(t2);\
					((a) + (e))->l_tile_loss = (t3);\
					((a) + (e))->r_tile_loss = (t4);\
					((a) + (e))->t_tile_loss = (t5);\
					((a) + (e))->b_tile_loss = (t6);\
					((a) + (e))->in_const_x = (t7);\
					((a) + (e))->in_const_y = (t8);\
					((a) + (e))->out_const_x = (t9);\
					((a) + (e))->out_const_y = (t10);\
					((a) + (e))->func_ptr_flag = 0x0;\
					((a) + (e))->group_num = (d);\
					((a) + (e))->in_min_width = (m1);\
					((a) + (e))->in_min_height = (m2);\
					((a) + (e))->in_tile_width = 0;\
					((a) + (e))->in_tile_width_loss = 0;\
					((a) + (e))->in_max_width = 0;\
					((a) + (e))->in_tile_height = 0;\
					((a) + (e))->in_max_height = 0;\
					((a) + (e))->out_tile_width = 0;\
					((a) + (e))->out_tile_width_loss = 0;\
					((a) + (e))->out_max_width = 0;\
					((a) + (e))->out_tile_height = 0;\
					((a) + (e))->out_max_height = 0;\
					((a) + (e))->in_log_width = 0;\
					((a) + (e))->in_log_height = 0;\
					((a) + (e))->out_log_width = 0;\
					((a) + (e))->out_log_height = 0;\
					((a) + (e))->enable_flag = (mx);\
					if (init_func_ptr)\
					{\
						((a) + (e))->init_func_ptr = init_func_ptr;\
						((a) + (e))->func_ptr_flag |= TILE_INIT_FUNC_PTR_FLAG;\
						(my) = ((a) + (e))->init_func_ptr((a) + (e), c);\
					}\
					else\
					{\
						((a) + (e))->init_func_ptr = NULL;\
					}\
					if (for_func_ptr)\
					{\
						((a) + (e))->for_func_ptr = for_func_ptr;\
						((a) + (e))->func_ptr_flag |= TILE_FOR_FUNC_PTR_FLAG;\
					}\
					else\
					{\
						((a) + (e))->for_func_ptr = NULL;\
					}\
					if (back_func_ptr)\
					{\
						((a) + (e))->back_func_ptr = back_func_ptr;\
						((a) + (e))->func_ptr_flag |= TILE_BACK_FUNC_PTR_FLAG;\
					}\
					else\
					{\
						((a) + (e))->back_func_ptr = NULL;\
					}\
					if (tdr_func_ptr)\
					{\
						((a) + (e))->tdr_func_ptr = tdr_func_ptr;\
						((a) + (e))->func_ptr_flag |= TILE_TDR_FUNC_PTR_FLAG;\
					}\
					else\
					{\
						((a) + (e))->tdr_func_ptr = NULL;\
					}\
					(e)++;\
				}\
				else\
				{\
					(my) = ISP_MESSAGE_OVER_MAX_TILE_FUNC_NO_ERROR;\
					tile_driver_printf("Error: %s\r\n", tile_print_error_message(my));\
				}\
			}\
            (b) = true;\
        }\
    }\

/* init tile function */
//a: ptr of current func_subrdma_list
//b: found flag
//c: reserved
//d: reserved
//e: reserved
//f: reserved
//g: func no
//h: func name
//t1~t10: tile property
//p1~p4: fun ptr
#define INIT_TILE_SUBRDMA_TDR(a, b, c, d, e, f, mx, my, g, h, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, p1, p2, p3, p4, r1, r2, m1, m2) \
    if (false == (b))\
    {\
        if ((g) == (a)->func_num)\
        {\
            ISP_TILE_MESSAGE_ENUM (*tdr_func_ptr)(TILE_FUNC_BLOCK_STRUCT *ptr_func, TILE_REG_MAP_STRUCT* ptr_tile_reg_map) = p4;\
			(a)->func_ptr_flag = 0x0;\
			(a)->group_num = (c);\
            (b) = true;\
            if (tdr_func_ptr)\
            {\
	            (a)->tdr_func_ptr = tdr_func_ptr;\
				(a)->func_ptr_flag |= TILE_TDR_FUNC_PTR_FLAG;\
            }\
			else\
			{\
	            (a)->tdr_func_ptr = NULL;\
			}\
        }\
    }\

/* init tile function */
//a: ptr of current TILE_FUNC_BLOCK_STRUCT
//b: ptr of current TILE_CAL_FUNC_STRUCT
//c: found flag
//d: reserve
//e: reserve
//f: func no
//g: func name
//t1~t2: tile property
//p1~p4: fun ptr
#define TILE_INIT_PROPERTY_LUT_FUNC_NO_CHECK(a, b, c, d, e, f, mx, my, g, h, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, p1, p2, p3, p4, r1, r2, m1, m2) \
    int tile_init_property_lut_func_no_check_##g = g;

/* register to dump */
//a: ptr of register table
//b: word val to dump
//c: current id
//d: merge count per dump
//e: ptr of dump word
//f: word count or offset to dump
#define TILE_REG_TO_DUMP(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) TILE_REG_TO_DUMP_##m(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...)
#define TILE_REG_TO_DUMP_U(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if ((g) != (c))\
        {\
            /* last merge count > 0 */\
            if ((d) > 0)\
            {\
                /* prevent corrupt memory */\
				if (e)\
				{\
					if ((f) <  (max_count))\
					{\
						*((e) + (f)) = (b);\
					}\
					(b) = 0;\
				}\
                (f)++;\
                (d) = 0;\
            }\
            /* update current id */\
            (c) = (g);\
        }\
        /* valid reg */\
        if (true == (h))\
        {\
            if ((d) & (j))/* check duplicated mask with check flag */\
            {\
				(result) = ISP_MESSAGE_DUPLICATED_TDR_DUMP_MASK_ERROR;\
                tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
                tile_driver_printf("Duplicated register: %s, mask: %s\r\n", #i, #j);\
            }\
            else\
            {\
				if (e)\
				{\
					/* shift field & merge */\
					for (int count=0;count<32;count++)\
					{\
						/* found nonzero lsb */\
						if (0x1 & ((j)>>count))\
						{\
							/* check applied last tdr */\
							if (n)\
							{\
								if (p)\
								{\
									/* update last */\
									if (((int)(f) >= (word_no)*(p)) && ((int)(f) < (int)(max_count) + (word_no)*(p)))\
									{\
										*((e) + (f) - (word_no)*(p)) &= ~(j);\
										*((e) + (f) - (word_no)*(p)) |= ((a)->i << count) & (j);\
										/* tile_driver_printf("update last hex no: %d, dump name: %s\r\n", (f) - (word_no)*(p), #i); */\
									}\
									else\
									{\
										(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
										tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
										break;\
									}\
								}\
								else\
								{\
									break;\
								}\
							}\
							else\
							{\
								(b) |= ((a)->i << count) & (j);\
								/* tile_driver_printf("current hex no: %d, dump name: %s\r\n", (f), #i); */\
							}\
							if ((a)->i & (~((j)>>count)))\
							{\
								(result) = ISP_MESSAGE_INCONSISTENT_TDR_DUMP_MASK_ERROR;\
								tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
								tile_driver_printf("Error hex no: %d, dump name: %s, val: 0x%08X, mask: 0x%08X\r\n", (f), #i, (a)->i, j);\
							}\
							break;\
						}\
					}\
				}\
                /* or mask count */\
                (d) |= (j);\
            }\
        }\
    }\

#define TILE_REG_TO_DUMP_S(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if ((g) != (c))\
        {\
            /* last merge count > 0 */\
            if ((d) > 0)\
            {\
                /* prevent corrupt memory */\
				if (e)\
				{\
					if ((f) <  (max_count))\
					{\
						*((e) + (f)) = (b);\
					}\
					(b) = 0;\
				}\
                (f)++;\
                (d) = 0;\
            }\
            /* update current id */\
            (c) = (g);\
        }\
        /* valid reg */\
        if (true == (h))\
        {\
            if ((d) & (j))/* check duplicated mask with check flag */\
            {\
				(result) = ISP_MESSAGE_DUPLICATED_TDR_DUMP_MASK_ERROR;\
                tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
                tile_driver_printf("Duplicated register: %s, mask: %s\r\n", #i, #j);\
            }\
            else\
            {\
				if (e)\
				{\
					/* shift field & merge */\
					for (int count=0;count<32;count++)\
					{\
						/* found nonzero lsb */\
						if (0x1 & ((j)>>count))\
						{\
							/* check applied last tdr */\
							if (n)\
							{\
								if (p)\
								{\
									/* update last */\
									if (((int)(f) >= (word_no)*(p)) && ((int)(f) < (int)(max_count) + (word_no)*(p)))\
									{\
										*((e) + (f) - (word_no)*(p)) &= ~(j);\
										*((e) + (f) - (word_no)*(p)) |= ((a)->i << count) & (j);\
										/* tile_driver_printf("update last hex no: %d, dump name: %s\r\n", (f) - (word_no)*(p), #i); */\
									}\
									else\
									{\
										(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
										tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
										break;\
									}\
								}\
								else\
								{\
									break;\
								}\
							}\
							else\
							{\
								(b) |= ((a)->i << count) & (j);\
								/* tile_driver_printf("current hex no: %d, dump name: %s\r\n", (f), #i); */\
							}\
							if ((a)->i >= 0)\
							{\
								if ((a)->i & (~((j)>>count)))\
								{\
									(result) = ISP_MESSAGE_INCONSISTENT_TDR_DUMP_MASK_ERROR;\
									tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
									tile_driver_printf("Error hex no: %d, dump name: %s, val: 0x%08X, mask: 0x%08X\r\n", (f), #i, (a)->i, j);\
								}\
							}\
							else\
							{\
								if ((a)->i ^ ((~((j)>>count)) | ((a)->i & ((j)>>count)))\
								{\
									(result) = ISP_MESSAGE_INCONSISTENT_TDR_DUMP_MASK_ERROR;\
									tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
									tile_driver_printf("Error hex no: %d, dump name: %s, val: 0x%08X, mask: 0x%08X\r\n", (f), #i, (a)->i, j);\
								}\
							}\
							break;\
						}\
					}\
				}\
                /* or mask count */\
                (d) |= (j);\
            }\
        }\
    }\

/* register to dump */
//a: ptr of register table
//b: word val to dump
//c: current id
//d: merge count per dump
//e: ptr of dump word
//f: word count or offset to dump
#define TILE_MASK_TO_DUMP(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if ((g) != (c))\
        {\
			/* prevent corrupt memory */\
			if (d)\
			{\
				if ((e) <  (max_count))\
				{\
					*((d) + (e)) = (b);\
				}\
			}\
            (e)++;\
            /* update current id */\
            (c) = (g);\
			if (b)\
			{\
				(f)++;\
				(b) = 0;\
			}\
        }\
        /* valid reg */\
        if (true == (h))\
        {\
            if ((b) & (j))/* check duplicated mask with check flag */\
            {\
				(result) = ISP_MESSAGE_DUPLICATED_TDR_DUMP_MASK_ERROR;\
                tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
                tile_driver_printf("Duplicated register: %s, mask: 0x%08X\r\n", #i, j);\
            }\
            else\
            {\
                /* or mask count */\
                (b) |= (j);\
            }\
        }\
    }\

/* register to dump */
//a: ptr of register table
//b: mask_ptr
//c: mask_id
//d: mask_offset
//e: mask_val
//f: dump_file
#define TILE_MASK_VAL_DUMP(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if ((g) != (c))\
        {\
            /* update current id & offset */\
			fprintf(f, "\r\n");\
			(d)++;\
            (c) = (g);\
			(e) = 0;\
        }\
        /* valid reg */\
		if (0 == (e))\
		{\
			if ((d) < max_count)\
			{\
				fprintf(f, "(%d) 0x%08X", (d), *((b) + (d)));\
			}\
			else\
			{\
				(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
				tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
			}\
		}\
        /* or mask count */\
		if ((e) & (j))\
		{\
			(result) = ISP_MESSAGE_DUPLICATED_TDR_DUMP_MASK_ERROR;\
			tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
			tile_driver_printf("Duplicated register: %s, mask: 0x%08X\r\n", #i, j);\
		}\
		else\
		{\
			fprintf(f, " [%s][0x%X]", #i, j);\
			(e) |= j;\
			if ((d) != g)\
			{\
				tile_driver_printf("Warning: skipped tdr lut no, reg: %s, desired no: %d, curr no: %d \r\n", #i, (d), g);\
			}\
		}\
    }\

/* register to dump */
//a: ptr of register table
//b: word val to dump
//c: current id
//d: merge count per dump
//e: ptr of dump word
//f: word count or offset to dump
#define TILE_BACKUP_TO_DUMP(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) TILE_BACKUP_TO_DUMP_##m(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...)
#define TILE_BACKUP_TO_DUMP_U(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if (g != (a))\
        {\
            (b)++;\
            /* update current id */\
            (a) = g;\
        }\
		if ((b) <  (max_count))\
		{\
			/* valid reg */\
			if (*((c) + (b)))\
			{\
				if ((j) == (*((c) + (b)) & (j)))/* check duplicated mask with check flag */\
				{\
					int count;\
					/* shift field & merge */\
					for (count=0;count<32;count++)\
					{\
						/* found nonzero lsb */\
						if (0x1 & ((j)>>count))\
						{\
							int temp_reg = 0;\
							read_int_register_by_name(&temp_reg, k);\
							*((d) + (b)) &= ~(j);\
							*((d) + (b)) |= (temp_reg << count) & (j);\
							/* tile_driver_printf("hex no: %d, backup name: %s, val: %d\r\n", (a), #k, temp_reg); */\
							if (temp_reg & (~((j)>>count)))\
							{\
								(result) = ISP_MESSAGE_INCONSISTENT_TDR_DUMP_MASK_ERROR;\
								tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
								tile_driver_printf("Error hex no: %d, backup name: %s, val: 0x%08X, mask: 0x%08X\r\n", a, #i, temp_reg, j);\
							}\
							break;\
						}\
					}\
				}\
				else if (*((c) + (b)) & (j))\
				{\
					(result) = ISP_MESSAGE_INCONSISTENT_TDR_DUMP_MASK_ERROR;\
					tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
					tile_driver_printf("Inconsistent reg enable mask %s: 0x%08X, mask dump: 0x%08X\r\n", #i, *((c) + (b)), j);\
				}\
			}\
		}\
		else\
		{\
			(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
			tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
		}\
    }\

#define TILE_BACKUP_TO_DUMP_S(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if (g != (a))\
        {\
            (b)++;\
            /* update current id */\
            (a) = g;\
        }\
		if ((b) <  (max_count))\
		{\
			/* valid reg */\
			if (*((c) + (b)))\
			{\
				if ((j) == (*((c) + (b)) & (j)))/* check duplicated mask with check flag */\
				{\
					int count;\
					/* shift field & merge */\
					for (count=0;count<32;count++)\
					{\
						/* found nonzero lsb */\
						if (0x1 & ((j)>>count))\
						{\
							int temp_reg = 0;\
							read_int_register_by_name(&temp_reg, k);\
							*((d) + (b)) &= ~(j);\
							*((d) + (b)) |= (temp_reg << count) & (j);\
							/* tile_driver_printf("hex no: %d, backup name: %s, val: %d\r\n", (a), #k, temp_reg); */\
							if (temp_reg >= 0)\
							{\
								if (temp_reg & (~((j)>>count)))\
								{\
									(result) = ISP_MESSAGE_INCONSISTENT_TDR_DUMP_MASK_ERROR;\
									tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
									tile_driver_printf("Error hex no: %d, backup name: %s, val: 0x%08X, mask: 0x%08X\r\n", (a), #i, temp_reg, j);\
								}\
							}\
							else\
							{\
								if (temp_reg ^ ((~((j)>>count)) | (temp_reg & ((j)>>count)))\
								{\
									(result) = ISP_MESSAGE_INCONSISTENT_TDR_DUMP_MASK_ERROR;\
									tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
									tile_driver_printf("Error hex no: %d, backup name: %s, val: 0x%08X, mask: 0x%08X\r\n", (a), #i, temp_reg, j);\
								}\
							}\
							break;\
						}\
					}\
				}\
				else if (*((c) + (b)) & (j))\
				{\
					(result) = ISP_MESSAGE_INCONSISTENT_TDR_DUMP_MASK_ERROR;\
					tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
					tile_driver_printf("Inconsistent reg enable mask %s: 0x%08X, mask dump: 0x%08X\r\n", #i, *((c) + (b)), j);\
				}\
			}\
		}\
		else\
		{\
			(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
			tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
		}\
    }\

/* register to dump */
//a: ptr of register table
//b: word val to dump
//c: current id
//d: merge count per dump
//e: ptr of dump word
//f: word count or offset to dump
#define TILE_BACKUP_TO_DUMP_D(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) TILE_BACKUP_TO_DUMP_D_##m(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...)
#define TILE_BACKUP_TO_DUMP_D_U(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if (g != (a))\
        {\
            (b)++;\
            /* update current id */\
            (a) = g;\
        }\
		if ((b) <  (max_count))\
		{\
			/* valid reg */\
			if (*((c) + (b)))\
			{\
				if ((j) == (*((c) + (b)) & (j)))/* check duplicated mask with check flag */\
				{\
					int count;\
					/* shift field & merge */\
					for (count=0;count<32;count++)\
					{\
						/* found nonzero lsb */\
						if (0x1 & ((j)>>count))\
						{\
							int temp_reg = 0;\
							read_int_register_by_name(&temp_reg, l);\
							*((d) + (b)) &= ~(j);\
							*((d) + (b)) |= (temp_reg << count) & (j);\
							/* tile_driver_printf("hex no: %d, backup name: %s, val: %d\r\n", (a), #l, temp_reg);*/\
							if (temp_reg & (~((j)>>count)))\
							{\
								(result) = ISP_MESSAGE_INCONSISTENT_TDR_DUMP_MASK_ERROR;\
								tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
								tile_driver_printf("Error hex no: %d, backup name: %s, val: 0x%08X, mask: 0x%08X\r\n", a, #i, temp_reg, j);\
							}\
							break;\
						}\
					}\
				}\
				else if (*((c) + (b)) & (j))\
				{\
					(result) = ISP_MESSAGE_INCONSISTENT_TDR_DUMP_MASK_ERROR;\
					tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
					tile_driver_printf("Inconsistent reg enable mask %s: 0x%08X, mask dump: 0x%08X\r\n", #i, *((c) + (b)), j);\
				}\
			}\
		}\
		else\
		{\
			(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
			tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
		}\
    }\

#define TILE_BACKUP_TO_DUMP_D_S(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if (g != (a))\
        {\
            (b)++;\
            /* update current id */\
            (a) = g;\
        }\
		if ((b) <  (max_count))\
		{\
			/* valid reg */\
			if (*((c) + (b)))\
			{\
				if ((j) == (*((c) + (b)) & (j)))/* check duplicated mask with check flag */\
				{\
					int count;\
					/* shift field & merge */\
					for (count=0;count<32;count++)\
					{\
						/* found nonzero lsb */\
						if (0x1 & ((j)>>count))\
						{\
							int temp_reg = 0;\
							read_int_register_by_name(&temp_reg, l);\
							*((d) + (b)) &= ~(j);\
							*((d) + (b)) |= (temp_reg << count) & (j);\
							/* tile_driver_printf("hex no: %d, backup name: %s, val: %d\r\n", (a), #l, temp_reg);*/\
							if (temp_reg >= 0)\
							{\
								if (temp_reg & (~((j)>>count)))\
								{\
									(result) = ISP_MESSAGE_INCONSISTENT_TDR_DUMP_MASK_ERROR;\
									tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
									tile_driver_printf("Error hex no: %d, backup name: %s, val: 0x%08X, mask: 0x%08X\r\n", (a), #i, temp_reg, j);\
								}\
							}\
							else\
							{\
								if (temp_reg ^ ((~((j)>>count)) | (temp_reg & ((j)>>count)))\
								{\
									(result) = ISP_MESSAGE_INCONSISTENT_TDR_DUMP_MASK_ERROR;\
									tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
									tile_driver_printf("Error hex no: %d, backup name: %s, val: 0x%08X, mask: 0x%08X\r\n", (a), #i, temp_reg, j);\
								}\
							}\
							break;\
						}\
					}\
				}\
				else if (*((c) + (b)) & (j))\
				{\
					(result) = ISP_MESSAGE_INCONSISTENT_TDR_DUMP_MASK_ERROR;\
					tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
					tile_driver_printf("Inconsistent reg enable mask %s: 0x%08X, mask dump: 0x%08X\r\n", #i, *((c) + (b)), j);\
				}\
			}\
		}\
		else\
		{\
			(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
			tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
		}\
    }\

/* register to dump */
//a: ptr of register table
//b: word val to dump
//c: current id
//d: merge count per dump
//e: ptr of dump word
//f: word count or offset to dump
#define TILE_RESTORE_TO_REG(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) TILE_RESTORE_TO_REG_##m(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...)
#define TILE_RESTORE_TO_REG_U(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if (g != (a))\
        {\
            (b)++;\
            /* update current id */\
            (a) = g;\
        }\
		if ((b) <  (max_count))\
		{\
			/* valid reg */\
			if (*((c) + (b)))\
			{\
				if ((j) == (*((c) + (b)) & (j)))/* check mask */\
				{\
					int count;\
					/* shift field & merge */\
					for (count=0;count<32;count++)\
					{\
						/* found nonzero lsb */\
						if (0x1 & ((j)>>count))\
						{\
							int temp_reg = (*((d) + (b)) >> count) & ((j) >> count);\
							write_int_register_by_name(temp_reg, k);\
							/* tile_driver_printf("hex no: %d, restore name: %s, val: %d\r\n", (a), #k, temp_reg); */\
							break;\
						}\
					}\
				}\
			}\
		}\
		else\
		{\
			(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
			tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
		}\
    }\

#define TILE_RESTORE_TO_REG_S(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if (g != (a))\
        {\
            (b)++;\
            /* update current id */\
            (a) = g;\
        }\
		if ((b) <  (max_count))\
		{\
			/* valid reg */\
			if (*((c) + (b)))\
			{\
				if ((j) == (*((c) + (b)) & (j)))/* check mask */\
				{\
					int count;\
					/* shift field & merge */\
					for (count=0;count<32;count++)\
					{\
						/* found nonzero lsb */\
						if (0x1 & ((j)>>count))\
						{\
							int temp_reg = (*((d) + (b)) >> count) & ((j) >> count);\
							if (temp_reg & (0x1 + ((j) >>(count + 1))))\
							{\
								write_int_register_by_name(-(int)(((j) >> count) - (unsigned int)temp_reg + 1), k);\
							}\
							else\
							{\
								write_int_register_by_name(temp_reg, k);\
							}\
							/* tile_driver_printf("hex no: %d, restore name: %s, val: %d\r\n", (a), #k, temp_reg); */\
							break;\
						}\
					}\
				}\
			}\
		}\
		else\
		{\
			(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
			tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
		}\
    }\

/* register to dump */
//a: ptr of register table
//b: word val to dump
//c: current id
//d: merge count per dump
//e: ptr of dump word
//f: word count or offset to dump
#define TILE_RESTORE_TO_REG_D(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) TILE_RESTORE_TO_REG_D_##m(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...)
#define TILE_RESTORE_TO_REG_D_U(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if (g != (a))\
        {\
            (b)++;\
            /* update current id */\
            (a) = g;\
        }\
		if ((b) <  (max_count))\
		{\
			/* valid reg */\
			if (*((c) + (b)))\
			{\
				if ((j) == (*((c) + (b)) & (j)))/* check mask */\
				{\
					int count;\
					/* shift field & merge */\
					for (count=0;count<32;count++)\
					{\
						/* found nonzero lsb */\
						if (0x1 & ((j)>>count))\
						{\
							int temp_reg = (*((d) + (b)) >> count) & ((j) >> count);\
							write_int_register_by_name(temp_reg, l);\
							/* tile_driver_printf("hex no: %d, restore name: %s, val: %d\r\n", (a), #l, temp_reg); */\
							break;\
						}\
					}\
				}\
			}\
		}\
		else\
		{\
			(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
			tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
		}\
    }\

#define TILE_RESTORE_TO_REG_D_S(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if (g != (a))\
        {\
            (b)++;\
            /* update current id */\
            (a) = g;\
        }\
		if ((b) <  (max_count))\
		{\
			/* valid reg */\
			if (*((c) + (b)))\
			{\
				if ((j) == (*((c) + (b)) & j))/* check mask */\
				{\
					int count;\
					/* shift field & merge */\
					for (count=0;count<32;count++)\
					{\
						/* found nonzero lsb */\
						if (0x1 & ((j)>>count))\
						{\
							int temp_reg = (*((d) + (b)) >> count) & ((j) >> count);\
							if (temp_reg & (0x1 + ((j) >> (count + 1))))\
							{\
								write_int_register_by_name(-(int)(((j) >> count) - (unsigned int)temp_reg + 1), l);\
							}\
							else\
							{\
								write_int_register_by_name(temp_reg, l);\
							}\
							/* tile_driver_printf("hex no: %d, restore name: %s, val: %d\r\n", (a), #l, temp_reg); */\
							break;\
						}\
					}\
				}\
			}\
		}\
		else\
		{\
			(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
			tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
		}\
    }\

/* register to dump */
//a: ptr of register table
//b: word val to dump
//c: current id
//d: merge count per dump
//e: ptr of dump word
//f: word count or offset to dump
#define TILE_UPDATE_TO_REG(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) TILE_UPDATE_TO_REG_##m(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...)
#define TILE_UPDATE_TO_REG_U(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if (g != (a))\
        {\
			if ((c) < (max_count))\
			{\
				if (*((e) + (c)))\
				{\
					(b)++;\
				}\
			}\
            (c)++;\
            /* update current id */\
            (a) = g;\
        }\
		if ((c) < (max_count))\
		{\
			/* valid reg */\
			if (*((e) + (c)))\
			{\
				if ((b) < (f))\
				{\
					if ((j) == (*((e) + (c)) & (j)))/* check duplicated mask with check flag */\
					{\
						int count;\
						/* shift field & merge */\
						for (count=0;count<32;count++)\
						{\
							/* found nonzero lsb */\
							if (0x1 & ((j)>>count))\
							{\
								int temp_reg = (*((d) + (b)) >> count) & ((j) >> count);\
								write_int_register_by_name(temp_reg, k);\
								/*tile_driver_printf("hex id: %d, lut no: %d, config no: %d, mask no: %d, update tile: %s, val: %d\r\n", (a), g, (b), (c), #k, temp_reg);*/\
								break;\
							}\
						}\
					}\
					else if (*((e) + (c)) & (j))\
					{\
						(result) = ISP_MESSAGE_INCONSISTENT_TDR_DUMP_MASK_ERROR;\
						tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
						tile_driver_printf("Inconsistent reg enable mask %s: 0x%08X, mask dump: 0x%08X\r\n", #i, *((e) + (c)), j);\
					}\
				}\
				else\
				{\
					/*tile_driver_printf("hex id: %d, lut no: %d, config no: %d, mask no: %d\r\n", (a), g, (b), (c));*/\
					(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
					tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
				}\
			}\
		}\
		else\
		{\
			/*tile_driver_printf("hex id: %d, lut no: %d, config no: %d, mask no: %d\r\n", (a), g, (b), (c));*/\
			(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
			tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
		}\
    }\

#define TILE_UPDATE_TO_REG_S(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if (g != (a))\
        {\
			if ((c) < (max_count))\
			{\
				if (*((e) + (c)))\
				{\
					(b)++;\
				}\
			}\
            (c)++;\
            /* update current id */\
            (a) = g;\
        }\
		if ((c) < (max_count))\
		{\
			/* valid reg */\
			if (*((e) + (c)))\
			{\
				if ((b) < (f))\
				{\
					if ((j) == (*((e) + (c)) & (j)))/* check duplicated mask with check flag */\
					{\
						int count;\
						/* shift field & merge */\
						for (count=0;count<32;count++)\
						{\
							/* found nonzero lsb */\
							if (0x1 & ((j)>>count))\
							{\
								int temp_reg = (*((d) + (b)) >> count) & ((j) >> count);\
								if (temp_reg & (0x1 + ((j) >> (count + 1))))\
								{\
									write_int_register_by_name(-(int)(((j) >> count) - (unsigned int)temp_reg + 1), k);\
								}\
								else\
								{\
									write_int_register_by_name(temp_reg, k);\
								}\
								/*tile_driver_printf("hex id: %d, lut no: %d, config no: %d, mask no: %d, update tile: %s, val: %d\r\n", (a), g, (b), (c), #k, temp_reg);*/\
								break;\
							}\
						}\
					}\
					else if (*((e) + (c)) & (j))\
					{\
						(result) = ISP_MESSAGE_INCONSISTENT_TDR_DUMP_MASK_ERROR;\
						tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
						tile_driver_printf("Inconsistent reg enable mask %s: 0x%08X, mask dump: 0x%08X\r\n", #i, *((e) + (c)), j);\
					}\
				}\
				else\
				{\
					/*tile_driver_printf("hex id: %d, lut no: %d, config no: %d, mask no: %d\r\n", (a), g, (b), (c));*/\
					(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
					tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
				}\
			}\
		}\
		else\
		{\
			/*tile_driver_printf("hex id: %d, lut no: %d, config no: %d, mask no: %d\r\n", (a), g, (b), (c));*/\
			(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
			tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
		}\
    }\

/* register to dump */
//a: ptr of register table
//b: word val to dump
//c: current id
//d: merge count per dump
//e: ptr of dump word
//f: word count or offset to dump
#define TILE_UPDATE_TO_REG_D(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) TILE_UPDATE_TO_REG_D_##m(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...)
#define TILE_UPDATE_TO_REG_D_U(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if (g != (a))\
        {\
			if ((c) < (max_count))\
			{\
				if (*((e) + (c)))\
				{\
					(b)++;\
				}\
			}\
            (c)++;\
            /* update current id */\
            (a) = g;\
        }\
		if ((c) < (max_count))\
		{\
			/* valid reg */\
			if (*((e) + (c)))\
			{\
				if ((b) < (f))\
				{\
					if ((j) == (*((e) + (c)) & (j)))/* check duplicated mask with check flag */\
					{\
						int count;\
						/* shift field & merge */\
						for (count=0;count<32;count++)\
						{\
							/* found nonzero lsb */\
							if (0x1 & ((j)>>count))\
							{\
								int temp_reg = (*((d) + (b)) >> count) & ((j) >> count);\
								write_int_register_by_name(temp_reg, l);\
								/*tile_driver_printf("hex id: %d, lut no: %d, config no: %d, mask no: %d, update tile: %s, val: %d\r\n", (a), g, (b), (c), #k, temp_reg);*/\
								break;\
							}\
						}\
					}\
					else if (*((e) + (c)) & (j))\
					{\
						(result) = ISP_MESSAGE_INCONSISTENT_TDR_DUMP_MASK_ERROR;\
						tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
						tile_driver_printf("Inconsistent reg enable mask %s: 0x%08X, mask dump: 0x%08X\r\n", #i, *((e) + (c)), j);\
					}\
				}\
				else\
				{\
					/*tile_driver_printf("hex id: %d, lut no: %d, config no: %d, mask no: %d\r\n", (a), g, (b), (c));*/\
					(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
					tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
				}\
			}\
		}\
		else\
		{\
			/*tile_driver_printf("hex id: %d, lut no: %d, config no: %d, mask no: %d\r\n", (a), g, (b), (c));*/\
			(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
			tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
		}\
    }\

#define TILE_UPDATE_TO_REG_D_S(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if (g != (a))\
        {\
			if ((c) < (max_count))\
			{\
				if (*((e) + (c)))\
				{\
					(b)++;\
				}\
			}\
            (c)++;\
            /* update current id */\
            (a) = g;\
        }\
		if ((c) < (max_count))\
		{\
			/* valid reg */\
			if (*((e) + (c)))\
			{\
				if ((b) < (f))\
				{\
					if ((j) == (*((e) + (c)) & (j)))/* check duplicated mask with check flag */\
					{\
						int count;\
						/* shift field & merge */\
						for (count=0;count<32;count++)\
						{\
							/* found nonzero lsb */\
							if (0x1 & ((j)>>count))\
							{\
								int temp_reg = (*((d) + (b)) >> count) & ((j) >> count);\
								if (temp_reg & (0x1 + ((j) >> (count + 1))))\
								{\
									write_int_register_by_name(-(int)(((j) >> count) - (unsigned int)temp_reg + 1), l);\
								}\
								else\
								{\
									write_int_register_by_name(temp_reg, l);\
								}\
								/*tile_driver_printf("hex id: %d, lut no: %d, config no: %d, mask no: %d, update tile: %s, val: %d\r\n", (a), g, (b), (c), #k, temp_reg);*/\
								break;\
							}\
						}\
					}\
					else if (*((e) + (c)) & (j))\
					{\
						(result) = ISP_MESSAGE_INCONSISTENT_TDR_DUMP_MASK_ERROR;\
						tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
						tile_driver_printf("Inconsistent reg enable mask %s: 0x%08X, mask dump: 0x%08X\r\n", #i, *((e) + (c)), j);\
					}\
				}\
				else\
				{\
					/*tile_driver_printf("hex id: %d, lut no: %d, config no: %d, mask no: %d\r\n", (a), g, (b), (c));*/\
					(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
					tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
				}\
			}\
		}\
		else\
		{\
			/*tile_driver_printf("hex id: %d, lut no: %d, config no: %d, mask no: %d\r\n", (a), g, (b), (c));*/\
			(result) = ISP_MESSAGE_TDR_INV_TILE_NO_OVER_MAX_ERROR;\
			tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
		}\
    }\

#define TILE_TDR_INV_REG_COPY_PRINT_REG_BY_FLAG(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) \
    if (1 == (c)->i)\
    {\
        (a)->i = (b)->i;\
        fprintf(d, "%s%s%d\r\n", #i, TILE_DEBUG_SPACE_EQUAL_SYMBOL_STR, (b)->i);\
    }\

#define TILE_TCM_REG_COPY(a, b, c, d, e, f, g, h, i, j, k, m, n, p,...) (g) = (a)->i;

#define TILE_COPY_INV_REG(a, b, c, d, e, f, max_count, result, g, h, i, j, k) \
    /* valid reg */\
    if (true == (h))\
    {\
        (k) = (a)->i;\
    }\

/* register to dump */
//a: ptr of register table
//b: ptr of register flag
//c: current id
//d: merge count per dump
//e: ptr of dump word
//f: word count or offset to dump
#define TILE_DUMP_INV_REG(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) TILE_DUMP_INV_REG_##m(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...)
#define TILE_DUMP_INV_REG_U(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
	if (ISP_MESSAGE_TILE_OK == (result))\
	{\
		if ((g) != (c))\
		{\
			/* last merge count > 0 */\
			if ((d) > 0)\
			{\
				(f)++;\
				(d) = 0;\
			}\
			/* update current id */\
			(c) = (g);\
		}\
		/* valid reg */\
		if (true == (h))\
		{\
			if ((d) & (j))\
			{\
				(result) = ISP_MESSAGE_DUPLICATED_TDR_DUMP_MASK_ERROR;\
				tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
				tile_driver_printf("Duplicated register: %s, mask: 0x%08X\r\n", #i, j);\
			}\
			else\
			{\
				int count;\
				/* shift field & merge */\
				for (count=0;count<32;count++)\
				{\
					/* found nonzero lsb */\
					if (0x1 & ((j)>>count))\
					{\
						/* prevent corrupt memory */\
						if ((f) < (max_count))\
						{\
							(a)->i = (*((e) + (f)) >> count) & ((j) >> count);\
							(b)->i = 1;\
						}\
                        /* debug display */\
                        /* tile_driver_printf("hex no: %02d, inv dump name: %s\r\n", (f), #i);*/\
						break;\
					}\
				}\
				/* or mask count */\
				(d) |= (j);\
			}\
		}\
    }\

#define TILE_DUMP_INV_REG_S(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
	if (ISP_MESSAGE_TILE_OK == (result))\
	{\
		if ((g) != (c))\
		{\
			/* last merge count > 0 */\
			if ((d) > 0)\
			{\
				(f)++;\
				(d) = 0;\
			}\
			/* update current id */\
			(c) = (g);\
		}\
		/* valid reg */\
		if (true == (h))\
		{\
			if ((d) & (j))\
			{\
				(result) = ISP_MESSAGE_DUPLICATED_TDR_DUMP_MASK_ERROR;\
				tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
				tile_driver_printf("Duplicated register: %s, mask: 0x%08X\r\n", #i, j);\
			}\
			else\
			{\
				int count;\
				/* shift field & merge */\
				for (count=0;count<32;count++)\
				{\
					/* found nonzero lsb */\
					if (0x1 & ((j)>>count))\
					{\
						/* prevent corrupt memory */\
						if ((f) < (max_count))\
						{\
							int temp_reg = (*((e) + (f)) >> count) & ((j) >> count);\
							if (temp_reg & (0x1 + ((j) >> (count + 1))))\
							{\
								(a)->i = -(int)(((j) >> count) - (unsigned int)temp_reg + 1);\
							}\
							else\
							{\
								(a)->i = temp_reg;\
							}\
							(b)->i = 1;\
						}\
                        /* debug display */\
                        /* tile_driver_printf("hex no: %02d, inv dump name: %s\r\n", (f), #i);*/\
						break;\
					}\
				}\
				/* or mask count */\
				(d) |= (j);\
			}\
		}\
    }\

/* register to dump */
//a: file ptr
//b: not use
//c: current id
//d: merge count per dump
//e: ptr of dump word
//f: word count or offset to dump
#define TILE_FPRINT_TDR_DUMP_HEX(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) TILE_FPRINT_TDR_DUMP_HEX_##m(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...)
#define TILE_FPRINT_TDR_DUMP_HEX_U(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if ((g) != (c))\
        {\
            /* last merge count > 0 */\
            if ((d) > 0)\
            {\
                (f)++;\
                (d) = 0;\
				fprintf(b, "\r\n");\
            }\
            /* update current id */\
            (c) = (g);\
        }\
        /* valid reg */\
        if (true == (h))\
        {\
            if ((d) & (j))\
            {\
                (result) = ISP_MESSAGE_DUPLICATED_TDR_DUMP_MASK_ERROR;\
                tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
                tile_driver_printf("Duplicated register: %s, mask: 0x%08X\r\n", #i, j);\
            }\
            else\
            {\
                int count;\
                if (0 == (d))\
                    {\
                        /* prevent corrupt memory */\
                        if ((f) < (max_count))\
                        {\
                            fprintf(b, "(%d) 0x%08X", (f), *((e) + (f)));\
                        }\
                    }\
                /* shift field & merge */\
                for (count=0;count<32;count++)\
                {\
                    /* found nonzero lsb */\
                    if (0x1 & ((j)>>count))\
                    {\
                        /* prevent corrupt memory */\
                        if ((f) < (max_count))\
                        {\
                            int val = (*((e) + (f)) >> count) & ((j) >> count);\
                            fprintf(b, " [%s][0x%X]=%d", #i, (j), val);\
                        }\
                        /* tile_driver_printf("hex no: %d, inv dump name: %s\r\n", (f), #i);*/\
                        break;\
                    }\
                }\
                /* or mask count */\
                (d) |= (j);\
            }\
        }\
    }\

#define TILE_FPRINT_TDR_DUMP_HEX_S(a, b, c, d, e, f, max_count, result, word_no, g, h, i, j, k, l, m, n, p,...) \
    /* different id or word */\
    if (ISP_MESSAGE_TILE_OK == (result))\
    {\
        if ((g) != (c))\
        {\
            /* last merge count > 0 */\
            if ((d) > 0)\
            {\
                (f)++;\
                (d) = 0;\
				fprintf(b, "\r\n");\
            }\
            /* update current id */\
            (c) = (g);\
        }\
        /* valid reg */\
        if (true == (h))\
        {\
            if ((d) & (j))\
            {\
                (result) = ISP_MESSAGE_DUPLICATED_TDR_DUMP_MASK_ERROR;\
                tile_driver_printf("Error: %s\r\n", tile_print_error_message(result));\
                tile_driver_printf("Duplicated register: %s, mask: 0x%08X\r\n", #i, j);\
            }\
            else\
            {\
                int count;\
                if (0 == (d))\
                    {\
                        /* prevent corrupt memory */\
                        if ((f) < (max_count))\
                        {\
                            fprintf(b, "(%d) 0x%08X", (f), *((e) + (f)));\
                        }\
                    }\
                /* shift field & merge */\
                for (count=0;count<32;count++)\
                {\
                    /* found nonzero lsb */\
                    if (0x1 & ((j)>>count))\
                    {\
                        /* prevent corrupt memory */\
                        if ((f) < (max_count))\
                        {\
                            int val = (*((e) + (f)) >> count) & ((j) >> count);\
							if (val & (0x1 + ((j) >> (count + 1))))\
							{\
								fprintf(b, " [%s][0x%X]=%d", #i, j, -(int)(((j) >> count) - (unsigned int)val + 1));\
							}\
							else\
							{\
								fprintf(b, " [%s][0x%X]=%d", #i, j, val);\
							}\
                        }\
                        /* tile_driver_printf("hex no: %d, inv dump name: %s\r\n", (f), #i);*/\
                        break;\
                    }\
                }\
                /* or mask count */\
                (d) |= (j);\
            }\
        }\
    }\

#define TILE_INVERSE_FUNC_X_ORDER(a) \
    (a)->out_stream_order = ((a)->in_stream_order & TILE_ORDER_RIGHT_TO_LEFT)?\
    ((a)->in_stream_order & (~TILE_ORDER_RIGHT_TO_LEFT)):((a)->in_stream_order | TILE_ORDER_RIGHT_TO_LEFT);\
    (a)->out_cal_order = ((a)->in_cal_order & TILE_ORDER_RIGHT_TO_LEFT)?\
    ((a)->in_cal_order & (~TILE_ORDER_RIGHT_TO_LEFT)):((a)->in_cal_order | TILE_ORDER_RIGHT_TO_LEFT);\
    (a)->out_dump_order = ((a)->in_dump_order & TILE_ORDER_RIGHT_TO_LEFT)?\
    ((a)->in_dump_order & (~TILE_ORDER_RIGHT_TO_LEFT)):((a)->in_dump_order | TILE_ORDER_RIGHT_TO_LEFT);\

#define TILE_COPY_SRC_ORDER(a, b) \
    (a)->in_stream_order = (b)->src_stream_order;\
    (a)->in_cal_order = (b)->src_cal_order;\
    (a)->in_dump_order = (b)->src_dump_order;\
    (a)->out_stream_order = (b)->src_stream_order;\
    (a)->out_cal_order = (b)->src_cal_order;\
    (a)->out_dump_order = (b)->src_dump_order;\

#define TILE_COPY_PRE_ORDER(a, b) \
    (a)->in_stream_order = (b)->out_stream_order;\
    (a)->in_cal_order = (b)->out_cal_order;\
    (a)->in_dump_order = (b)->out_dump_order;\
    (a)->out_stream_order = (b)->out_stream_order;\
    (a)->out_cal_order = (b)->out_cal_order;\
    (a)->out_dump_order = (b)->out_dump_order;\

#define TILE_CHECK_RESULT(result) \
	{\
		if (ISP_MESSAGE_TILE_OK != (result))\
		{\
			return(result);\
		}\
	}\

#define TILE_ASSIGN_AND_CHECK_RESULT(result, func) \
	{\
		if (ISP_MESSAGE_TILE_OK == (result))\
		{\
    (result) = (func);\
			if (ISP_MESSAGE_TILE_OK != (result))\
			{\
				return(result);\
			}\
		}\
		else\
		{\
			func;\
		}\
	}\

/* TDR by register name */
typedef struct TILE_TDR_REG_STRUCT
{
    char name[MAX_TDR_REGISTER_STRING_LENGTH];
    unsigned int val;
    unsigned int tile_no;
}TILE_TDR_REG_STRUCT;

typedef struct TILE_HORZ_BACKUP_BUFFER
{
    TILE_FUNC_BLOCK_LUT(TILE_WRAPPER_HORZ_PARA_DECLARE,,,,,)
}TILE_HORZ_BACKUP_BUFFER;

typedef struct TILE_RESIZER_FORWARD_CAL_ARG_STRUCT
{
    int mode;
    int in_pos_start;
    int in_pos_end;
    int bias;
    int offset;
    int in_bias;
    int in_offset;
    int in_bias_c;
    int in_offset_c;
    int prec_bits;
    int config_bits;
    CAM_UV_ENUM align_flag;/* CAM_UV_444_FLAG (1), CAM_UV_422_FLAG (0) */
    CAM_UV_ENUM uv_flag;/* CAM_UV_444_FLAG (1), CAM_UV_422_FLAG (0) */
    int max_in_pos_end;
    int max_out_pos_end;
    int out_pos_start;/* output */
    int out_pos_end;/* output */
    CAM_DIR_ENUM dir_mode;/* CAM_DIR_X (0), CAM_DIR_Y (1) */
    int coeff_step;
    int offset_cal_start;
}TILE_RESIZER_FORWARD_CAL_ARG_STRUCT;

typedef struct TILE_RESIZER_BACKWARD_CAL_ARG_STRUCT
{
    int mode;
    int out_pos_start;
    int out_pos_end;
    int bias;
    int offset;
    int prec_bits;
    int config_bits;
    CAM_UV_ENUM align_flag;/* CAM_UV_444_FLAG (1), CAM_UV_422_FLAG (0) */
    CAM_UV_ENUM uv_flag;/* CAM_UV_444_FLAG (1), CAM_UV_422_FLAG (0) */
    int max_in_pos_end;
    int max_out_pos_end;
    int in_pos_start;/* output */
    int in_pos_end;/* output */
    CAM_DIR_ENUM dir_mode;/* CAM_DIR_X (0), CAM_DIR_Y (1) */
    int coeff_step;
}TILE_RESIZER_BACKWARD_CAL_ARG_STRUCT;

/* tile reg & variable */
typedef struct TILE_REG_MAP_STRUCT
{
    /* COMMON */
    TILE_INTERNAL_REG_LUT(COMMON, TILE_HW_REG_TYPE_DECLARE,,,,,)
    TILE_SW_REG_LUT(ISP, TILE_HW_REG_TYPE_DECLARE,,,,,)
    TILE_SW_REG_LUT(DIP, TILE_HW_REG_TYPE_DECLARE,,,,,)
    TILE_SW_REG_LUT(WPE, TILE_HW_REG_TYPE_DECLARE,,,,,)
    TILE_SW_REG_LUT(EAF, TILE_HW_REG_TYPE_DECLARE,,,,,)
    TILE_SW_REG_LUT(BLD, TILE_HW_REG_TYPE_DECLARE,,,,,)
    TILE_HW_REG_LUT(DIP, TILE_HW_REG_TYPE_DECLARE,,,,,)
    TILE_HW_REG_LUT(WPE, TILE_HW_REG_TYPE_DECLARE,,,,,)
    TILE_HW_REG_LUT(WPE2, TILE_HW_REG_TYPE_DECLARE,,,,,)
    TILE_HW_REG_LUT(EAF, TILE_HW_REG_TYPE_DECLARE,,,,,)
    TILE_HW_REG_LUT(BLD, TILE_HW_REG_TYPE_DECLARE,,,,,)
    TILE_INTERNAL_TDR_REG_LUT(ISP, TILE_HW_REG_TYPE_DECLARE,,,,,)
    TILE_INTERNAL_REG_LUT(ISP, TILE_HW_REG_TYPE_DECLARE,,,,,)
    TILE_CMODEL_REG_LUT(ISP, TILE_HW_REG_TYPE_DECLARE,,,,,)
    TILE_CMODEL_PATH_LUT(ISP, TILE_HW_REG_TYPE_DECLARE,,,,,)
    TILE_PLATFORM_REG_LUT(ISP, TILE_HW_REG_TYPE_DECLARE,,,,,)
    TILE_PLATFORM_DEBUG_REG_LUT(ISP, TILE_HW_REG_TYPE_DECLARE,,,,,)
    /* MDP */
    TILE_HW_REG_LUT(MDP, TILE_HW_REG_TYPE_DECLARE,,,,,)
    TILE_RESIZER_BACKWARD_CAL_ARG_STRUCT back_arg;
    TILE_RESIZER_FORWARD_CAL_ARG_STRUCT for_arg;
}TILE_REG_MAP_STRUCT;

struct TILE_FUNC_DATA_STRUCT;
/* self reference type */
typedef struct TILE_FUNC_BLOCK_STRUCT
{
	TILE_FUNC_BLOCK_LUT(TILE_WRAPPER_DATA_TYPE_DECLARE,,,,,)
	ISP_TILE_MESSAGE_ENUM (*init_func_ptr)(struct TILE_FUNC_BLOCK_STRUCT *ptr_func, TILE_REG_MAP_STRUCT* ptr_tile_reg_map);
    ISP_TILE_MESSAGE_ENUM (*for_func_ptr)(struct TILE_FUNC_BLOCK_STRUCT *ptr_func, TILE_REG_MAP_STRUCT* ptr_tile_reg_map);
    ISP_TILE_MESSAGE_ENUM (*back_func_ptr)(struct TILE_FUNC_BLOCK_STRUCT *ptr_func, TILE_REG_MAP_STRUCT* ptr_tile_reg_map);
    ISP_TILE_MESSAGE_ENUM (*tdr_func_ptr)(struct TILE_FUNC_BLOCK_STRUCT *ptr_func, TILE_REG_MAP_STRUCT* ptr_tile_reg_map);
    struct TILE_FUNC_DATA_STRUCT *func_data;
}TILE_FUNC_BLOCK_STRUCT;

typedef struct TILE_FUNC_ENABLE_STRUCT
{
    TILE_FUNC_ID_ENUM func_num;
    bool enable_flag;
    bool output_disable_flag;
}TILE_FUNC_ENABLE_STRUCT;

typedef struct TILE_FUNC_SUBRDMA_STRUCT
{
	TILE_FUNC_ID_ENUM func_num;
	TILE_FUNC_ID_ENUM master_func_num;
	bool enable_flag;
	unsigned int func_ptr_flag;
	ISP_TILE_MESSAGE_ENUM (*tdr_func_ptr)(TILE_FUNC_BLOCK_STRUCT *ptr_func, TILE_REG_MAP_STRUCT* ptr_tile_reg_map);
	TILE_GROUP_NUM_ENUM group_num;
}TILE_FUNC_SUBRDMA_STRUCT;

/* tile function interface to be compatiable with new c model */
typedef struct FUNC_DESCRIPTION_STRUCT
{
    unsigned char used_func_no;
    unsigned char used_en_func_no;
    unsigned char used_subrdma_func_no;
    unsigned int  valid_flag[(MAX_TILE_FUNC_NO+31)/32];
    unsigned int for_recursive_count;
    unsigned char scheduling_forward_order[MAX_TILE_FUNC_NO];
    unsigned char scheduling_backward_order[MAX_TILE_FUNC_NO];
	TILE_FUNC_BLOCK_STRUCT func_list[MAX_TILE_FUNC_NO];
    TILE_FUNC_ENABLE_STRUCT func_en_list[MAX_TILE_FUNC_EN_NO];
    TILE_FUNC_SUBRDMA_STRUCT func_subrdma_list[MAX_TILE_FUNC_SUBRDMA_NO];
}FUNC_DESCRIPTION_STRUCT;

/* struct size must be x4 bytes */
typedef struct TILE_INFORMATION_STRUCT
{
    unsigned int tdr_disable_flag;/* tdr disable flag */
	unsigned int in_pos_xs;/* tile start */
    unsigned int in_pos_xe;/* tile end */
    unsigned int in_pos_ys;/* tile start */
    unsigned int in_pos_ye;/* tile end */
    unsigned int tile_stop_flag;/* stop flag */
    unsigned int dump_offset_no;/* word offset */
}TILE_INFORMATION_STRUCT;

typedef struct ISP_TILE_HEX_DUMP_STRUCT
{
	unsigned int tile_sel_mode;
	unsigned int config_no_per_tile;
	unsigned int curr_horizontal_tile_no;
    unsigned int horizontal_tile_no;
	unsigned int curr_vertical_tile_no;
	unsigned int used_word_no;
	unsigned int used_tile_no;
	unsigned int tile_sel;
    unsigned int tdr_disable_flag[(MAX_TILE_TOT_NO+31)/32];
    unsigned int last_irq_flag[(MAX_TILE_TOT_NO+31)/32];
    unsigned int tile_config[MAX_ISP_TILE_TDR_HEX_NO];
    unsigned int tile_mask[MAX_ISP_MASK_HEX_PER_TILE];
    unsigned int tile_backup[MAX_ISP_MASK_HEX_PER_TILE];
    TILE_INFORMATION_STRUCT tile_info[MAX_TILE_TOT_NO];
	unsigned int used_word_no_d;
	unsigned int used_tile_no_d;
	unsigned int tile_sel_d;
    unsigned int tile_config_d[MAX_ISP_TILE_TDR_HEX_NO];
    TILE_INFORMATION_STRUCT tile_info_d[MAX_TILE_TOT_NO];
    unsigned int total_word_no;
    unsigned int total_tile_no;
	/* internal used */
	unsigned int config_no_per_tile_internal;
	unsigned int used_word_no_internal;
    unsigned int tile_config_internal[MAX_ISP_TILE_TDR_HEX_NO_INTERNAL];
    unsigned int tile_mask_internal[MAX_ISP_MASK_HEX_PER_TILE_INTERNAL];
    unsigned int tile_backup_internal[MAX_ISP_MASK_HEX_PER_TILE_INTERNAL];
	unsigned int used_word_no_internal_d;
    unsigned int tile_config_internal_d[MAX_ISP_TILE_TDR_HEX_NO_INTERNAL];
	unsigned int total_word_no_internal;
	/* wpe */
	unsigned int config_no_per_tile_wpe;
    unsigned int tile_config_wpe[MAX_ISP_TILE_TDR_HEX_NO_WPE];
    unsigned int tile_mask_wpe[MAX_ISP_MASK_HEX_PER_TILE_WPE];
    unsigned int tile_backup_wpe[MAX_ISP_MASK_HEX_PER_TILE_WPE];
    TILE_INFORMATION_STRUCT tile_info_wpe[MAX_TILE_TOT_NO];
	unsigned int used_word_no_wpe;
    unsigned int total_word_no_wpe;
	unsigned int tile_sel_wpe;
	/* wpe_d */
    unsigned int tile_config_d_wpe[MAX_ISP_TILE_TDR_HEX_NO_WPE];
    TILE_INFORMATION_STRUCT tile_info_d_wpe[MAX_TILE_TOT_NO];
	unsigned int used_word_no_d_wpe;
	unsigned int tile_sel_wpe_d;
	/* wpe internal used */
	unsigned int config_no_per_tile_internal_wpe;
	unsigned int used_word_no_internal_wpe;
    unsigned int tile_config_internal_wpe[MAX_ISP_TILE_TDR_HEX_NO_INTERNAL_WPE];
    unsigned int tile_mask_internal_wpe[MAX_ISP_MASK_HEX_PER_TILE_INTERNAL_WPE];
    unsigned int tile_backup_internal_wpe[MAX_ISP_MASK_HEX_PER_TILE_INTERNAL_WPE];
	unsigned int used_word_no_internal_d_wpe;
    unsigned int tile_config_internal_d_wpe[MAX_ISP_TILE_TDR_HEX_NO_INTERNAL_WPE];
	unsigned int total_word_no_internal_wpe;
	/* wpe2 */
	unsigned int config_no_per_tile_wpe2;
    unsigned int tile_config_wpe2[MAX_ISP_TILE_TDR_HEX_NO_WPE];
    unsigned int tile_mask_wpe2[MAX_ISP_MASK_HEX_PER_TILE_WPE];
    unsigned int tile_backup_wpe2[MAX_ISP_MASK_HEX_PER_TILE_WPE];
    TILE_INFORMATION_STRUCT tile_info_wpe2[MAX_TILE_TOT_NO];
	unsigned int used_word_no_wpe2;
    unsigned int total_word_no_wpe2;
	unsigned int tile_sel_wpe2;
	/* wpe2 internal used */
	unsigned int config_no_per_tile_internal_wpe2;
	unsigned int used_word_no_internal_wpe2;
    unsigned int tile_config_internal_wpe2[MAX_ISP_TILE_TDR_HEX_NO_INTERNAL_WPE];
    unsigned int tile_mask_internal_wpe2[MAX_ISP_MASK_HEX_PER_TILE_INTERNAL_WPE];
    unsigned int tile_backup_internal_wpe2[MAX_ISP_MASK_HEX_PER_TILE_INTERNAL_WPE];
	unsigned int total_word_no_internal_wpe2;
	/* eaf */
	unsigned int config_no_per_tile_eaf;
    unsigned int tile_config_eaf[MAX_ISP_TILE_TDR_HEX_NO_EAF];
    unsigned int tile_mask_eaf[MAX_ISP_MASK_HEX_PER_TILE_EAF];
    unsigned int tile_backup_eaf[MAX_ISP_MASK_HEX_PER_TILE_EAF];
    TILE_INFORMATION_STRUCT tile_info_eaf[MAX_TILE_TOT_NO];
    unsigned int total_word_no_eaf;
	unsigned int used_word_no_eaf;
	unsigned int tile_sel_eaf;
	/* eaf internal used */
	unsigned int config_no_per_tile_internal_eaf;
    unsigned int tile_config_internal_eaf[MAX_ISP_TILE_TDR_HEX_NO_INTERNAL_EAF];
    unsigned int tile_mask_internal_eaf[MAX_ISP_MASK_HEX_PER_TILE_INTERNAL_EAF];
    unsigned int tile_backup_internal_eaf[MAX_ISP_MASK_HEX_PER_TILE_INTERNAL_EAF];
	unsigned int total_word_no_internal_eaf;
	unsigned int used_word_no_internal_eaf;
	/* bld */
	unsigned int config_no_per_tile_bld;
    unsigned int tile_config_bld[MAX_ISP_TILE_TDR_HEX_NO_BLD];
    unsigned int tile_mask_bld[MAX_ISP_MASK_HEX_PER_TILE_BLD];
    unsigned int tile_backup_bld[MAX_ISP_MASK_HEX_PER_TILE_BLD];
    TILE_INFORMATION_STRUCT tile_info_bld[MAX_TILE_TOT_NO];
    unsigned int total_word_no_bld;
	unsigned int used_word_no_bld;
	unsigned int tile_sel_bld;
	/* bld internal used */
	unsigned int config_no_per_tile_internal_bld;
    unsigned int tile_config_internal_bld[MAX_ISP_TILE_TDR_HEX_NO_INTERNAL_BLD];
    unsigned int tile_mask_internal_bld[MAX_ISP_MASK_HEX_PER_TILE_INTERNAL_BLD];
    unsigned int tile_backup_internal_bld[MAX_ISP_MASK_HEX_PER_TILE_INTERNAL_BLD];
	unsigned int total_word_no_internal_bld;
	unsigned int used_word_no_internal_bld;
}ISP_TILE_HEX_DUMP_STRUCT;

typedef struct DIRECT_LINK_INFORMATION_STRUCT
{
    int out_pos_xs;/* tile start */
    int out_pos_xe;/* tile end */
    int out_pos_ys;/* tile start */
    int out_pos_ye;/* tile end */
    int h_end_flag;/* tile h_end_flag */
    int v_end_flag;/* tile v_end_flag */
	int min_tile_out_pos_xs;/* diff view min tile pos */
	int min_tile_out_pos_xe;/* diff view min tile pos */
	int min_tile_out_pos_ys;/* diff view min tile pos */
	int min_tile_out_pos_ye;/* diff view min tile pos */
	int tdr_h_disable_flag;/* diff view flag */
	int tdr_v_disable_flag;/* diff view flag */
}DIRECT_LINK_INFORMATION_STRUCT;

typedef struct DIRECT_LINK_DUMP_STRUCT
{
    int used_tile_no;
    int total_tile_no;
	int func_num;
	DIRECT_LINK_INFORMATION_STRUCT frame_info;
	DIRECT_LINK_INFORMATION_STRUCT tile_info[MAX_TILE_TOT_NO];
}DIRECT_LINK_DUMP_STRUCT;

typedef struct TILE_PARAM_CMODEL_STRUCT
{
    TILE_REG_MAP_STRUCT tile_reg_map;
    FUNC_DESCRIPTION_STRUCT tile_func_param;
    ISP_TILE_HEX_DUMP_STRUCT isp_tile_hex_dump_param;
	DIRECT_LINK_DUMP_STRUCT direct_link_dump_param;
}TILE_PARAM_CMODEL_STRUCT;

typedef struct TILE_PARAM_UT_STRUCT
{
    TILE_REG_MAP_STRUCT *ptr_tile_reg_map;
    FUNC_DESCRIPTION_STRUCT *ptr_tile_func_param;
    ISP_TILE_HEX_DUMP_STRUCT *ptr_isp_tile_hex_dump_param;
}TILE_PARAM_UT_STRUCT;

typedef struct ISP_TILE_WORKING_BUFFER_PARAM_STRUCT
{
    TILE_REG_MAP_STRUCT tile_reg_map;
    FUNC_DESCRIPTION_STRUCT tile_func_param;
}ISP_TILE_WORKING_BUFFER_PARAM_STRUCT;

#endif
