
/****************************************************************************
 *  (c) Copyright 2007 Wi-Fi Alliance.  All Rights Reserved
 *
 *
 *  LICENSE
 *
 *  License is granted only to Wi-Fi Alliance members and designated
 *  contractors (“Authorized Licensees”).N  Authorized Licensees are granted
 *  the non-exclusive, worldwide, limited right to use, copy, import, export
 *  and distribute this software:
 *  (i) solely for noncommercial applications and solely for testing Wi-Fi
 *  equipment; and
 *  (ii) solely for the purpose of embedding the software into Authorized
 *  Licensee’s proprietary equipment and software products for distribution to
 *  its customers under a license with at least the same restrictions as
 *  contained in this License, including, without limitation, the disclaimer of
 *  warranty and limitation of liability, below.N  The distribution rights
 *  granted in clause
 *  (ii), above, include distribution to third party companies who will
 *  redistribute the Authorized Licensee’s product to their customers with or
 *  without such third party’s private label. Other than expressly granted
 *  herein, this License is not transferable or sublicensable, and it does not
 *  extend to and may not be used with non-Wi-Fi applications.N  Wi-Fi Alliance
 *  reserves all rights not expressly granted herein.N
 *N
 *  Except as specifically set forth above, commercial derivative works of
 *  this software or applications that use the Wi-Fi scripts generated by this
 *  software are NOT AUTHORIZED without specific prior written permission from
 *  Wi-Fi Alliance.
 *N
 *  Non-Commercial derivative works of this software for internal use are
 *  authorized and are limited by the same restrictions; provided, however,
 *  that the Authorized Licensee shall provide Wi-Fi Alliance with a copy of
 *  such derivative works under a perpetual, payment-free license to use,
 *  modify, and distribute such derivative works for purposes of testing Wi-Fi
 *  equipment.
 *N
 *  Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 *  or promote products that are derived from or that use this software without
 *  specific prior written permission from Wi-Fi Alliance.
 *
 *  THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR AN PARTICULAR PURPOSE,
 *  ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
 *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ******************************************************************************
 */

/*
 *   File: wfa_cs.c -- configuration and setup
 *   This file contains all implementation for the dut setup and control
 *   functions, such as network interfaces, ip address and wireless specific
 *   setup with its supplicant.
 *
 *   The current implementation is to show how these functions
 *   should be defined in order to support the Agent Control/Test Manager
 *   control commands. To simplify the current work and avoid any GPL licenses,
 *   the functions mostly invoke shell commands by calling linux system call,
 *   system("<commands>").
 *
 *   It depends on the differnt device and platform, vendors can choice their
 *   own ways to interact its systems, supplicants and process these commands
 *   such as using the native APIs.
 *
 *   Revision History:
 *        2006/03/10  -- initially created by qhu
 *        2006/06/01  -- BETA Release by qhu
 *        2006/06/13  -- 00.02 Release by qhu
 *        2006/06/30  -- 00.10 Release by qhu
 *        2006/07/10  -- 01.00 Release by qhu
 *        2006/09/01  -- 01.05 Release by qhu
 *        2006/10/26  -- 01.06 Released by qhu
 *                       replace hardcoded buf size with macro
 *        2006/12/02  -- bugs: 1. fixes incorrect order of getipconfig.sh
 *                                input parameters reported by p.schwann
 *                             2. will add a new network for wap_cli command
 *                                in case the network id 0 not present,
 *                                recommended by c.benson
 *                                the solution is to reimplement with calling
 *                                native C API
 *        2007/01/11  -- 01.10 released by qhu
 *        2007/02/15  -- WMM Extension Beta released by qhu, mkaroshi
 *        2007/03/18  -- add file close statements
 *        2007/03/21  -- rename the file to avoid the confusion.
 *        2007/03/30  -- 01.40 WPA2 and Official WMM Beta Release by qhu
 *        2007/04/20  -- 02.00 WPA2 and Official WMM Release by qhu
 *        2007/08/15 --  02.10 WMM-Power Save release by qhu
 *        2007/10/10 --  02.20 Voice SOHO beta -- qhu
 *        2007/11/07 --  02.30 Voice HSO -- qhu
 *        2007/12/10 --  02.32 Add a function to upload test results.
 *        2008/01/03 --  02.34 Support the result upload command.
 *        2008/03/12 --  02.41 Bug #16, incorrect file descriptor used. Change
 *                       the "tmpfile" to "tmpfd" and a few places. Make a macro
 *                       WFA_STAUT_IF in file "inc/wfa_cs.h" for WLAN interface
 *                       name in the function "wfaDeviceListIF()
 *
 *                       Not A Bug. Put back to the function from
 *                       wfaSetEncryption1() to wfaSetEncryption() for
 *                       supporting WEP. Porting could select which should be
 *                       used according to WEP support or not.
 *
 *
 */
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>

#include <sys/socket.h>
#include <arpa/inet.h>
#if !defined (__CYGWIN__)
#include <linux/types.h>
#include <linux/socket.h>
#include <linux/if.h>
#else
#include <cygwin/types.h>
#include <cygwin/socket.h>
#endif
#include <poll.h>

#include "wfa_portall.h"
#include "wfa_debug.h"
#include "wfa_ver.h"
#include "wfa_main.h"
#include "wfa_types.h"
#include "wfa_ca.h"
#include "wfa_tlv.h"
#include "wfa_sock.h"
#include "wfa_tg.h"
#include "wfa_cmds.h"
#include "wfa_rsp.h"
#include "wfa_utils.h"
#include "wfa_miscs.h"
#include "wfa_stdincs.h"
#ifdef WFA_WMM_PS_EXT
#include "wfa_wmmps.h"
#endif

#ifdef MTK_P2P_SIGMA
#if defined (MTK_P2P_SUPPLICANT)

/*Global parameter for DHCP is on/off*/
static unsigned int fgIsDhcpOn;

#define MTK_TDLS_SIGMA 1
#define MTK_PMF_SIGMA 1

/*Modify this path based on your platform
  *For 11AC sigma, it usually output result to this path and then parse result from this path.
  *So this path must has read/write access right*/
#define TMP_ASEC_PATH "/tmp/asec/"

#ifdef MTK_SPECIFIC_PING_SIGMA
#define SIGMA_PING "/data/ping_sigma"
#define PING_NAME "ping_sigma"
#else
#define SIGMA_PING "ping"
#define PING_NAME "ping"
#endif


#define P2P_CTRL_SOCKET_DIR "/data/system/p2p_supplicant"
#define P2P_DEFAULT_IFNAME "p2p0"

#define WPA_CTRL_IF "/tmp/wpa_supplicant "

#define MTK_P2P_CMD(supp_cmd_fmt, ... )									\
	do {																\
		sprintf(gCmdStr, "p2p_cli -p/data/system/p2p_supplicant " supp_cmd_fmt, ##__VA_ARGS__); \
		puts("\n\t");													\
		puts(gCmdStr);													\
		if (system(gCmdStr)) printf("\t\tSYSYTEM CMD FAIL: \n\t\t\t%s \n", gCmdStr); \
	} while(0)
#endif //MTK_P2P_SUPPLICANT

#define CERTIFICATES_PATH    "/data/misc/wifi"
#else
#define CERTIFICATES_PATH    "/etc/wpa_supplicant"
#endif /* MTK_P2P_SIGMA */

#ifdef MTK_HS20_SIGMA

#define MTK_HS20_CMD(supp_cmd_fmt, ... )									\
	sprintf(gCmdStr, "wpa_cli -i wlan0 -p/tmp/wpa_supplicant " supp_cmd_fmt, ##__VA_ARGS__); \
	puts("\n\t");													\
	puts(gCmdStr);													\
	if (system(gCmdStr)) printf("\t\tSYSYTEM MTK_HS20_CMD FAIL: \n\t\t\t%s \n", gCmdStr);
#endif	/* MTK_HS20_SIGMA */

#ifdef MTK_TDLS_SIGMA
#define MTK_TDLS_CMD(supp_cmd_fmt, ... )									\
	sprintf(gCmdStr, "wpa_cli -iwlan0 -p/tmp/wpa_supplicant " supp_cmd_fmt, ##__VA_ARGS__); \
	puts("\n\t");													\
	puts(gCmdStr);													\
	if (system(gCmdStr)) printf("\t\tSYSYTEM MTK_AC_CMD FAIL: \n\t\t\t%s \n", gCmdStr);
#endif


#ifdef MTK_AC_SIGMA
#define MTK_AC_CMD(supp_cmd_fmt, ... )									\
	sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant " supp_cmd_fmt, ##__VA_ARGS__); \
	puts("\n\t");													\
	puts(gCmdStr);													\
	if (system(gCmdStr)) printf("\t\tSYSYTEM MTK_AC_CMD FAIL: \n\t\t\t%s \n", gCmdStr);
#endif	/* MTK_HS20_SIGMA */



/* Some device may only support UDP ECHO, activate this line */
//#define WFA_PING_UDP_ECHO_ONLY 1

extern unsigned short wfa_defined_debug;
extern char *remove_ext (char* , char);
int wfaExecuteCLI(char *CLI);

/* Since the two definitions are used all over the CA function */
char gCmdStr[WFA_CMD_STR_SZ];
dutCmdResponse_t gGenericResp;
int wfaTGSetPrio(int sockfd, int tgClass);
void create_apts_msg(int msg, unsigned int txbuf[],int id);

extern char e2eResults[];
//extern char *e2eResults;
FILE *e2efp = NULL;

// MTK_HS20_GLOBAL
int g_ipconfig_isSet;
caStaSetIpConfig_t g_ipconfig;
//
int gDhcpClient = 1;

#ifdef MTK_AC_SIGMA
char* const gShellCmdResult = gCmdStr;
int wfaShellCommand()   
{
	int res = 0;
	char *temp = gCmdStr;
	size_t remain_len = sizeof(gCmdStr);
     FILE *filep;
	//intf("command:%s\n", gCmdStr);
    if((filep=popen(gCmdStr, "r")) != NULL)   
    {   
        while (fgets(temp, remain_len, filep) != NULL)   
        {
			size_t len = strlen(temp);
			temp += len;
			remain_len -= len;
        }
        pclose(filep);
        filep = NULL;
		while (*(--temp) == '\n' || *temp == '\r');
		*(temp+1) = 0;
		//intf("command result:%s, remain_len=%d\n", gCmdStr, remain_len);
    }   
    else  
    {
        printf("popen error");
		return -1;
    }
    return res;  
}

#define MTK_EXEC_WPA_CLI(ifname, fmt, ...)	\
	do {	\
		sprintf(gCmdStr, "wpa_cli -i %s -p/tmp/wpa_supplicant "ifname, fmt, \
				##__VA_ARGS__);	\
		if (wfaShellCommand() < 0) \
			goto error; \
		if ((strncmp(gShellCmdResult, "FAIL", 4)==0 || 	\
				strncmp(gShellCmdResult, "UNKNOWN COMMAND", 15) == 0))	\
				goto error;	\
	} while(0)
	
#define MTK_EXEC_SHELL_CMD(fmt, ...)	\
	do {	\
		sprintf(gCmdStr, fmt, ##__VA_ARGS__);	\
		if (wfaShellCommand() < 0)	\
			goto error;	\
	} while(0)

#endif
int chk_ret_status()
{
    char *ret = getenv(WFA_RET_ENV);

    if(*ret == '1')
       return WFA_SUCCESS;
    else
       return WFA_FAILURE;
}

int wfaStaCheckIsConnected(char *ifname)
{
   int ret;

   FILE *tmpfile = NULL;
   char result[32];


   DPRINT_INFO(WFA_OUT, "Entering CheckIsConnected ...\n");

   sprintf(gCmdStr, "wpa_cli -p /tmp/wpa_supplicant -i%s status | grep ^wpa_state= | cut -f2- -d= > "TMP_ASEC_PATH"CheckIsConnected", ifname);
   system(gCmdStr);

   tmpfile = fopen(TMP_ASEC_PATH"CheckIsConnected", "r+");

   if(tmpfile == NULL)
   {
      DPRINT_ERR(WFA_ERR, "CheckIsConnected file open failed\n");
      return 0;
   }

   fscanf(tmpfile, "%s", result);

   if(strncmp(result, "COMPLETED", 9) == 0){
   	  DPRINT_INFO(WFA_OUT, "Now is connected ...\n");
      ret = 1;
   } else {
      DPRINT_INFO(WFA_OUT, "Now is NOT connected ...\n");
      ret = 0;
   }

   fclose(tmpfile);
   return ret;

}

int wfaGetIpConfig(char *ifname, char *ipaddr, char *hwaddr, char *netmask)
{
       struct ifreq ifr;
       int s;
       unsigned char macaddr[6];

       if (!ifname)
               return -1;

       memset(&ifr, 0, sizeof(struct ifreq));
       strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
       ifr.ifr_name[IFNAMSIZ-1] = 0;

      if((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
               DPRINT_INFO(WFA_OUT, "can't create socket AF_INET\n");
               return -1;
       }
       if (ipaddr) {
               if (ioctl(s, SIOCGIFADDR, &ifr) < 0) {
                       DPRINT_INFO(WFA_OUT, "get ip addr, %s:%s\n", ifname, strerror(errno));
                       return -1;
               }
               strncpy(ipaddr,
                          inet_ntoa(((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr),
                          WFA_IP_ADDR_STR_LEN);
       }
       if (netmask) {
               if (ioctl(s, SIOCGIFNETMASK, &ifr) < 0) {
                       DPRINT_INFO(WFA_OUT, "get net mask, %s:%s\n", ifname, strerror(errno));
                       return -1;
               }
               strncpy(netmask,
                          inet_ntoa(((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr),
                          WFA_IP_MASK_STR_LEN);
       }
       if (hwaddr) {
               if (ioctl(s, SIOCGIFHWADDR, &ifr) < 0) {
                       DPRINT_INFO(WFA_OUT, "get mac addr, %s:%s\n", ifname, strerror(errno));
                       return -1;
               }
               memcpy(macaddr, &ifr.ifr_hwaddr.sa_data, sizeof(macaddr));
               wSPRINTF(hwaddr, "%02x:%02x:%02x:%02x:%02x:%02x",
                       macaddr[0], macaddr[1], macaddr[2], macaddr[3],
                       macaddr[4], macaddr[5]);
               DPRINT_INFO(WFA_OUT, "get mac addr succeed, %02x:%02x:%02x:%02x:%02x:%02x\n",\
                       macaddr[0], macaddr[1], macaddr[2], macaddr[3], macaddr[4], macaddr[5]);
       }
       return 0;
}


/*
 * agtCmdProcGetVersion(): response "ca_get_version" command to controller
 *  input:  cmd --- not used
 *          valLen -- not used
 *  output: parms -- a buffer to store the version info response.
 */
int agtCmdProcGetVersion(int len, BYTE *parms, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *getverResp = &gGenericResp;

    DPRINT_INFO(WFA_OUT, "entering agtCmdProcGetVersion ...\n");
	
    getverResp->status = STATUS_COMPLETE;
#ifdef MTK_AC_SIGMA
	wSTRNCPY(getverResp->cmdru.version, "MTK_MOBILE_CA", 16);
#elif defined (MTK_HS20_SIGMA)
	wSTRNCPY(getverResp->cmdru.version, "MTK_HS20_R1_CA", 16);
#else
    wSTRNCPY(getverResp->cmdru.version, WFA_SYSTEM_VER, WFA_VERNAM_LEN);
#endif

    wfaEncodeTLV(WFA_GET_VERSION_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)getverResp, respBuf);

    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

    return WFA_SUCCESS;
}

/*
 * wfaStaAssociate():
 *    The function is to force the station wireless I/F to re/associate
 *    with the AP.
 */
int wfaStaAssociate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *assoc = (dutCommand_t *)caCmdBuf;
   char *ifname = assoc->intf;
   dutCmdResponse_t *staAssocResp = &gGenericResp;
   int i;

#if defined (MTK_AC_SIGMA)

	FILE *tmpfile = NULL;
	char ssid_id[8];
	char *tmpfilename = TMP_ASEC_PATH"ssid2id.txt";
	FILE *tmpfile1 = NULL;
	FILE *tmpfile2 = NULL;
	FILE *tmpfile3 = NULL;
	char ssid_str[WFA_SSID_NAME_LEN];
	char conn_bssid[64];
	char *tmpfilename1 = TMP_ASEC_PATH"bssid2ssid.txt";
	char *tmpfilename2 = TMP_ASEC_PATH"ssid2id.txt";
	char *tmpfilename3 = TMP_ASEC_PATH"conn_status.txt";	

	DPRINT_INFO(WFA_OUT, "entering wfaStaAssociate ...\n");
	/*
	* if bssid appears, station should associate with the specific
	* BSSID AP at its initial association.
	* If it is different to the current associating AP, it will be forced to
	* roam the new AP
	*/
	MTK_AC_CMD("-i %s ap_scan 1 ", ifname);
	buzz_time(1000000);
	MTK_AC_CMD("-i %s scan", ifname);
	buzz_time(5000000);
	MTK_AC_CMD("-i %s enable_network all\n", ifname);

	MTK_AC_CMD("-i %s list_networks | grep %s | tr \"\\t\" \",\" | cut -f 1 -d , > %s \n",
		ifname,
		assoc->cmdsu.assoc.ssid,
		tmpfilename);

	tmpfile = fopen(tmpfilename, "r+");
	if ((NULL == tmpfile) || (NULL == fgets(ssid_id, 8, tmpfile))) {
		printf("fail: %s \n", tmpfilename);
		staAssocResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;
		fclose(tmpfile);
		return WFA_FAILURE;
	}

	MTK_AC_CMD("-i %s select_network %s \n",
		ifname,
		ssid_id);

	//make sure connection
	for(i=0; i<30; i++){
		MTK_AC_CMD("-i %s status | grep ^wpa_state= | cut -f2- -d= > %s \n",
			ifname,
			tmpfilename3);
		
		tmpfile3 = fopen(tmpfilename3, "r+");
		if(fscanf(tmpfile3, "%s", conn_bssid) != EOF)
		{
			if(strncmp(conn_bssid, "COMPLETED", 9) == 0)
			{
				DPRINT_INFO(WFA_OUT, "MTK_MOBILE CONNECTED ...\n");
				break;
			}
		}
		else {
			DPRINT_INFO(WFA_OUT, "association times %d ...\n", i);
		}
		buzz_time(1000000);
	}	


	buzz_time(2000000);

	if(fgIsDhcpOn) {
		printf("Requesting DHCP IP!\n");
		system("netcfg wlan0 dhcp");
		printf("DHCP DONE!\n");
	}

	if(g_ipconfig_isSet == 1) {

#if (!defined MTK_P2P_SUPPLICANT) && (!defined MTK_HS20_SIGMA) && (!defined MTK_AC_SIGMA)
			   sprintf(gCmdStr, "/sbin/ifconfig %s %s netmask %s > /dev/null 2>&1 ", g_ipconfig.intf, g_ipconfig.ipaddr, g_ipconfig.mask);
#else
			   sprintf(gCmdStr, "ifconfig %s %s netmask %s > /dev/null 2>&1 ", g_ipconfig.intf, g_ipconfig.ipaddr, g_ipconfig.mask);
#endif
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
	
			   /* use command 'route add' to set set gatewway (linux specific) */
			   if(g_ipconfig.defGateway[0] != '\0')
			   {
#if (!defined MTK_P2P_SUPPLICANT) && (!defined MTK_HS20_SIGMA) && (!defined MTK_AC_SIGMA)
				  sprintf(gCmdStr, "/sbin/route add default gw %s > /dev/null 2>&1", g_ipconfig.defGateway);
#else
				  sprintf(gCmdStr, "/system/bin/route add default gw %s > /dev/null 2>&1", g_ipconfig.defGateway);
#endif
				  DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
				  system(gCmdStr);
			   }
	
#if (!defined MTK_P2P_SUPPLICANT) && (!defined MTK_HS20_SIGMA) && (!defined MTK_AC_SIGMA)
			   /* set dns (linux specific) */
			   sprintf(gCmdStr, "cp /etc/resolv.conf /tmp/resolv.conf.bk");
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
			   sprintf(gCmdStr, "echo nameserv %s > /etc/resolv.conf", g_ipconfig.pri_dns);
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
			   sprintf(gCmdStr, "echo nameserv %s >> /etc/resolv.conf", g_ipconfig.sec_dns);
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
#else
			   sprintf(gCmdStr, "setprop dhcp.%s.dns1 %s", g_ipconfig.intf, g_ipconfig.pri_dns);
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
			   sprintf(gCmdStr, "setprop dhcp.%s.dns2 %s", g_ipconfig.intf, g_ipconfig.sec_dns);
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
			   sprintf(gCmdStr, "setprop net.dns1 %s", g_ipconfig.pri_dns);
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
			   sprintf(gCmdStr, "setprop net.dns2 %s", g_ipconfig.sec_dns);
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
#endif
	}

#elif defined (MTK_HS20_SIGMA)
	FILE *tmpfile = NULL;
	char ssid_id[8];
	char *tmpfilename = TMP_ASEC_PATH"ssid2id.txt";
	FILE *tmpfile1 = NULL;
	FILE *tmpfile2 = NULL;
	FILE *tmpfile3 = NULL;
	char ssid_str[WFA_SSID_NAME_LEN];
	char conn_bssid[64];
	char *tmpfilename1 = TMP_ASEC_PATH"bssid2ssid.txt";
	char *tmpfilename2 = TMP_ASEC_PATH"ssid2id.txt";
	char *tmpfilename3 = TMP_ASEC_PATH"conn_status.txt";	

	DPRINT_INFO(WFA_OUT, "entering wfaStaAssociate ...\n");
	/*
	* if bssid appears, station should associate with the specific
	* BSSID AP at its initial association.
	* If it is different to the current associating AP, it will be forced to
	* roam the new AP
	*/
	MTK_HS20_CMD("-i %s ap_scan 1 ", ifname);
	MTK_HS20_CMD("-i %s enable_network all\n", ifname);

	MTK_HS20_CMD("-i %s list_networks | grep %s | tr \"\\t\" \",\" | cut -f 1 -d , > %s \n",
		ifname,
		assoc->cmdsu.assoc.ssid,
		tmpfilename);

	tmpfile = fopen(tmpfilename, "r+");
	if ((NULL == tmpfile) || (NULL == fgets(ssid_id, 8, tmpfile))) {
		printf("fail: %s \n", tmpfilename);
		staAssocResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;
		fclose(tmpfile);
		return WFA_FAILURE;
	}

	MTK_HS20_CMD("-i %s select_network %s \n",
		ifname,
		ssid_id);

	//make sure connection
	for(i=0; i<20; i++){
		MTK_HS20_CMD("-i %s status | grep ^wpa_state= | cut -f2- -d= > %s \n",
			ifname,
			tmpfilename3);
		
		tmpfile3 = fopen(tmpfilename3, "r+");
		if(fscanf(tmpfile3, "%s", conn_bssid) != EOF)
		{
			if(strncmp(conn_bssid, "COMPLETED", 9) == 0)
			{
				break;
			}
		}
		else {
			DPRINT_INFO(WFA_OUT, "association times %d ...\n", i);
		}
		buzz_time(1000000);
	}	


	buzz_time(2000000);

	if(fgIsDhcpOn) {
		printf("Requesting DHCP IP!\n");
		system("netcfg wlan0 dhcp");
		printf("DHCP DONE!\n");
	}

#else

   DPRINT_INFO(WFA_OUT, "entering wfaStaAssociate ...\n");
   /*
    * if bssid appears, station should associate with the specific
    * BSSID AP at its initial association.
    * If it is different to the current associating AP, it will be forced to
    * roam the new AP
    */

   if(assoc->cmdsu.assoc.bssid[0] != '\0')
   {
      /* if (the first association) */
      /* just do initial association to the BSSID */


      /* else (station already associate to an AP) */
      /* Do forced roaming */

   }
   else
   {
      /* use 'ifconfig' command to bring down the interface (linux specific) */
      sprintf(gCmdStr, "ifconfig %s down", ifname);
      system(gCmdStr);

      /* use 'ifconfig' command to bring up the interface (linux specific) */
      sprintf(gCmdStr, "ifconfig %s up", ifname);
      system(gCmdStr);

      /*
       *  use 'wpa_cli' command to force a 802.11 re/associate
       *  (wpa_supplicant specific)
       */
      sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i%s reassociate", ifname);
      system(gCmdStr);
   }

   /*
    * Then report back to control PC for completion.
    * This does not have failed/error status. The result only tells
    * a completion.
    */
#endif

   staAssocResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

	if(tmpfile != NULL)
   		fclose(tmpfile);
	if(tmpfile1 != NULL)
   		fclose(tmpfile1);
	if(tmpfile2 != NULL)
   		fclose(tmpfile2);
	if(tmpfile3 != NULL)
   		fclose(tmpfile3);
   return WFA_SUCCESS;
}

/*
 * wfaStaReAssociate():
 *    The function is to force the station wireless I/F to re/associate
 *    with the AP.
 */
int wfaStaReAssociate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *reassoc = (dutCommand_t *)caCmdBuf;
   char *ifname = reassoc->intf;
   dutCmdResponse_t *staReassocResp = &gGenericResp;
   int i;

#ifdef MTK_HS20_SIGMA
	FILE *tmpfile1 = NULL;
	FILE *tmpfile2 = NULL;
	FILE *tmpfile3 = NULL;
	char ssid_id[8];
	char ssid_str[WFA_SSID_NAME_LEN];
	char conn_bssid[64];
	char *tmpfilename1 = TMP_ASEC_PATH"bssid2ssid.txt";
	char *tmpfilename2 = TMP_ASEC_PATH"ssid2id.txt";
	char *tmpfilename3 = TMP_ASEC_PATH"conn_status.txt";

	DPRINT_INFO(WFA_OUT, "entering wfaStaReAssociate ...\n");
	/*
	* if bssid appears, station should associate with the specific
	* BSSID AP at its initial association.
	* If it is different to the current associating AP, it will be forced to
	* roam the new AP
	*/
	
#if 0
	//scan
	//MTK_HS20_CMD("-i %s scan", ifname);

	//bssid2ssid
	MTK_HS20_CMD("-i %s scan_results | grep %s | awk '{print $NF}' > %s \n",
		ifname,
		reassoc->cmdsu.assoc.bssid,
		tmpfilename1);

	tmpfile1 = fopen(tmpfilename1, "r+");
	if ((NULL == tmpfile1) || (fscanf(tmpfile1, "%s", ssid_str) == EOF)) {
		printf("fail: %s \n", tmpfilename1);
		staReassocResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_REASSOCIATE_RESP_TLV, 4, (BYTE *)staReassocResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;
		fclose(tmpfile1);
		return WFA_FAILURE;
	}

	fclose(tmpfile1);
// #endif	

	//ssid2id
	MTK_HS20_CMD("-i %s list_networks | grep %s | tr \"\\t\" \",\" | cut -f 1 -d , > %s \n",
		ifname,
		reassoc->cmdsu.assoc.bssid,
		tmpfilename2);

	tmpfile2 = fopen(tmpfilename2, "r+");
	if ((NULL == tmpfile2) || (NULL == fgets(ssid_id, 8, tmpfile2))) {
		printf("fail: %s \n", tmpfilename2);
		staReassocResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_REASSOCIATE_RESP_TLV, 4, (BYTE *)staReassocResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;
		fclose(tmpfile2);
		return WFA_FAILURE;
	}
	fclose(tmpfile2);

	MTK_HS20_CMD("-i %s disconnect \n", ifname);

	MTK_HS20_CMD("-i %s select_network %s \n",
		ifname,
		ssid_id);
#endif	

	MTK_HS20_CMD("-i %s ap_scan 1 ", ifname);
	MTK_HS20_CMD("-i %s ap_scan 1 ", ifname);
	MTK_HS20_CMD("-i %s ap_scan 1 ", ifname);

	MTK_HS20_CMD("-i %s reassociate \n", ifname);

	//make sure connection
	for(i=0; i<20; i++){
		MTK_HS20_CMD("-i %s status | grep ^wpa_state= | cut -f2- -d= > %s \n",
			ifname,
			tmpfilename3);
		
		tmpfile3 = fopen(tmpfilename3, "r+");
		if(fscanf(tmpfile3, "%s", conn_bssid) != EOF)
		{
			if(strncmp(conn_bssid, "COMPLETED", 9) == 0)
			{
				MTK_HS20_CMD("-i %s status | grep bssid | cut -f 2 -d = > %s \n",
					ifname,
					tmpfilename3);
				
				tmpfile3 = fopen(tmpfilename3, "r+");
				if(fscanf(tmpfile3, "%s", conn_bssid) != EOF)
				{
					if(strncmp(conn_bssid, reassoc->cmdsu.assoc.bssid, 17) == 0)
					{
						DPRINT_INFO(WFA_OUT, "Reassociation to %s is connected ...\n", conn_bssid);
						break;
					}
					else{
						DPRINT_INFO(WFA_OUT, "Reassociation to other target(tgt: %s)(ori: %s) ...\n", 
							conn_bssid, 
							reassoc->cmdsu.assoc.bssid);
					}
				}

				break;
			}
		}
		else {
			DPRINT_INFO(WFA_OUT, "Reassociation times %d ...\n", i);
		}
		buzz_time(1000000);

	}
	
	fclose(tmpfile3);
	buzz_time(2000000);

	if(fgIsDhcpOn) {
		printf("Requesting DHCP IP!\n");
		system("netcfg wlan0 dhcp");
		printf("DHCP DONE!\n");
	}

#else

   DPRINT_INFO(WFA_OUT, "entering wfaStaReAssociate ...\n");
   /*
    * if bssid appears, station should associate with the specific
    * BSSID AP at its initial association.
    * If it is different to the current associating AP, it will be forced to
    * roam the new AP
    */
   if(reassoc->cmdsu.assoc.bssid[0] != '\0')
   {
      /* if (the first association) */
      /* just do initial association to the BSSID */


      /* else (station already associate to an AP) */
      /* Do forced roaming */

   }
   else
   {
       /* use 'ifconfig' command to bring down the interface (linux specific) */
       sprintf(gCmdStr, "ifconfig %s down", ifname);
       system(gCmdStr);

       /* use 'ifconfig' command to bring up the interface (linux specific) */
       sprintf(gCmdStr, "ifconfig %s up", ifname);

       /*
        *  use 'wpa_cli' command to force a 802.11 re/associate
        *  (wpa_supplicant specific)
        */
       sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s reassociate", ifname);
       system(gCmdStr);
    }

    /*
     * Then report back to control PC for completion.
     * This does not have failed/error status. The result only tells
     * a completion.
     */
#endif
    staReassocResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_REASSOCIATE_RESP_TLV, 4, (BYTE *)staReassocResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}

/*
 * wfaStaIsConnected():
 *    The function is to check whether the station's wireless I/F has
 *    already connected to an AP.
 */
int wfaStaIsConnected(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *connStat = (dutCommand_t *)caCmdBuf;
   dutCmdResponse_t *staConnectResp = &gGenericResp;
   char *ifname = connStat->intf;
   FILE *tmpfile = NULL;
   char result[32];


   DPRINT_INFO(WFA_OUT, "Entering isConnected ...\n");

#ifdef WFA_NEW_CLI_FORMAT
   sprintf(gCmdStr, "wfa_chkconnect %s\n", ifname);
   system(gCmdStr);

   if(chk_ret_status() == WFA_SUCCESS)
      staConnectResp->cmdru.connected = 1;
   else
      staConnectResp->cmdru.connected = 0;
#else
   /*
    * use 'wpa_cli' command to check the interface status
    * none, scanning or complete (wpa_supplicant specific)
    */
#ifdef MTK_P2P_SIGMA
sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i%s status | grep ^wpa_state= | cut -f2- -d= > "TMP_ASEC_PATH"isConnected", ifname);
#else
sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i%s status | grep ^wpa_state= | cut -f2- -d= > /tmp/isConnected", ifname);
#endif
   system(gCmdStr);

   /*
    * the status is saved in a file.  Open the file and check it.
    */
#ifdef MTK_P2P_SIGMA
tmpfile = fopen(TMP_ASEC_PATH"isConnected", "r+");
#else
   tmpfile = fopen("/tmp/isConnected", "r+");
#endif
   if(tmpfile == NULL)
   {
      staConnectResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_IS_CONNECTED_RESP_TLV, 4, (BYTE *)staConnectResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return WFA_FAILURE;
   }

   fscanf(tmpfile, "%s", result);

   if(strncmp(result, "COMPLETED", 9) == 0)
      staConnectResp->cmdru.connected = 1;
   else
      staConnectResp->cmdru.connected = 0;
#endif

   /*
    * Report back the status: Complete or Failed.
    */
   staConnectResp->status = STATUS_COMPLETE;

   wfaEncodeTLV(WFA_STA_IS_CONNECTED_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)staConnectResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   fclose(tmpfile);
   return WFA_SUCCESS;
}

/*
 * wfaStaGetIpConfig():
 * This function is to retriev the ip info including
 *     1. dhcp enable
 *     2. ip address
 *     3. mask
 *     4. primary-dns
 *     5. secondary-dns
 *
 *     The current implementation is to use a script to find these information
 *     and store them in a file.
 */
int wfaStaGetIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    int slen, ret, i = 0;
    dutCommand_t *getIpConf = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *ipconfigResp = &gGenericResp;
    char *ifname = getIpConf->intf;
	int iptype = 0;
    caStaGetIpConfigResp_t *ifinfo = &ipconfigResp->cmdru.getIfconfig;

    FILE *tmpfd;
    char string[256];
    char *str;

    /*
     * check a script file (the current implementation specific)
     */
#if (!defined MTK_P2P_SUPPLICANT) && (!defined MTK_HS20_SIGMA) && (!defined MTK_AC_SIGMA)
    ret = access("/system/bin/getipconfig.sh", F_OK);
    if(ret == -1)
    {
       ipconfigResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;

       DPRINT_ERR(WFA_ERR, "file not exist\n");
       return WFA_FAILURE;

    }

    strcpy(ifinfo->dns[0], "0");
    strcpy(ifinfo->dns[1], "0");

    /*
     * Run the script file "getipconfig.sh" to check the ip status
     * (current implementation  specific).
     * note: "getipconfig.sh" is only defined for the current implementation
     */
    sprintf(gCmdStr, "getipconfig.sh "TMP_ASEC_PATH"ipconfig.txt %s\n", ifname);
	puts("\n\t");
	puts(gCmdStr);	

#elif defined (MTK_AC_SIGMA)
    /*
     * check a script file (the current implementation specific)
     */
    wMEMSET(ifinfo, 0, sizeof(*ifinfo));
    if (wfaGetIpConfig(ifname, ifinfo->ipaddr, ifinfo->mac, ifinfo->mask) < 0)
        goto error;

    ifinfo->isDhcp = gDhcpClient;

    MTK_EXEC_SHELL_CMD("getprop net.dns1");
    wSTRNCPY(ifinfo->dns[0], gShellCmdResult, WFA_IP_ADDR_STR_LEN);

    MTK_EXEC_SHELL_CMD("getprop net.dns2");
    wSTRNCPY(ifinfo->dns[1], gShellCmdResult, WFA_IP_ADDR_STR_LEN);
	
    /*
     * Report back the results
     */
    ipconfigResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)ipconfigResp, respBuf);   

    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
    return WFA_SUCCESS;

#elif defined (MTK_HS20_SIGMA)
	iptype = getIpConf->cmdsu.iftype;

    ret = access("/system/bin/mtk_hs20_getipconfig.sh", F_OK);
    if(ret == -1)
    {
       ipconfigResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;

       DPRINT_ERR(WFA_ERR, "file not exist\n");
       return WFA_FAILURE;

    }

    strcpy(ifinfo->dns[0], "0");
    strcpy(ifinfo->dns[1], "0");

    /*
     * Run the script file "getipconfig.sh" to check the ip status
     * (current implementation  specific).
     * note: "getipconfig.sh" is only defined for the current implementation
     */
    // ipv4
    if(iptype == 1){
    	sprintf(gCmdStr, "mtk_hs20_getipconfig.sh "TMP_ASEC_PATH"ipconfig.txt %s\n", ifname);
		puts("\n\t");
		puts(gCmdStr);
    }
	//ipv6
	else if(iptype == 2){
    	sprintf(gCmdStr, "/data/busybox-full ifconfig %s |grep inet6 | cut -d \" \" -f 13 > "TMP_ASEC_PATH"ipconfig.txt \n", ifname);
		puts("\n\t");
		puts(gCmdStr);
	}
	else {
		ipconfigResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;
		DPRINT_ERR(WFA_ERR, "ip type (%d) is not support\n", iptype);
		return WFA_FAILURE;
	}

#else
    ret = access("/data/mtk_p2p_getipconfig.sh", F_OK);
    if(ret == -1)
    {
       ipconfigResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;

       DPRINT_ERR(WFA_ERR, "file not exist\n");
       return WFA_FAILURE;

    }

    strcpy(ifinfo->dns[0], "0");
    //strcpy(ifinfo->dns[1], "0");
	ifinfo->dns[1][0] = 0;

    /*
     * Run the script file "getipconfig.sh" to check the ip status
     * (current implementation  specific).
     * note: "getipconfig.sh" is only defined for the current implementation
     */
    sprintf(gCmdStr, "sh /data/mtk_p2p_getipconfig.sh "TMP_ASEC_PATH"ipconfig.txt %s\n", ifname);
	puts("\n\t");
	puts(gCmdStr);

#endif /* !MTK_P2P_SUPPLICANT */

    system(gCmdStr);

    /* open the output result and scan/retrieve the info */
    tmpfd = fopen(TMP_ASEC_PATH"ipconfig.txt", "r+");


    if(tmpfd == NULL)
    {
      ipconfigResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return WFA_FAILURE;
    }

#if defined MTK_HS20_SIGMA
	if(iptype == 2){
		int idx, str_idx = 0;
		
		fgets(ifinfo->ipv6addr, WFA_IP_V6_ADDR_STR_LEN, tmpfd);

		DPRINT_INFO(WFA_OUT, "ipv6 %s\n", ifinfo->ipv6addr);

		ifinfo->ipv6addr[WFA_IP_V6_ADDR_STR_LEN-1] = '\0';
	
		 /*
		  * Report back the results
		  */
		 ipconfigResp->status = STATUS_COMPLETE;
		 wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)ipconfigResp, respBuf);
	
		 *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

		 fclose(tmpfd);
		 return WFA_SUCCESS;

	}
#endif

    for(;;)
    {
        if(fgets(string, 256, tmpfd) == NULL)
           break;

        /* check dhcp enabled */
        if(strncmp(string, "dhcpcli", 7) ==0)
        {
            str = strtok(string, "=");
            str = strtok(NULL, "=");
            //if(str != NULL)   // TODO: MTK_P2P
            if(strncmp(str, "running", 7) ==0)
               ifinfo->isDhcp = 1;
            else
               ifinfo->isDhcp = 0;
        }

        /* find out the ip address */
        if(strncmp(string, "ipaddr", 6) == 0)
        {
#if 1        
            char ttstr[16];
            char *ttp = ttstr;

            str = strtok_r(string, "=", &ttp);
            if(*ttp != '\0')
            {
               strcpy(ifinfo->ipaddr, ttp);
               slen = strlen(ifinfo->ipaddr);
               ifinfo->ipaddr[slen-1] = '\0';
            }
            else
               strcpy(ifinfo->ipaddr, "none");

#else	
            str = strtok(string, "=");
            str = strtok(NULL, " ");
            if(str != NULL)
            {
               wSTRNCPY(ifinfo->ipaddr, str, 15);
               ifinfo->ipaddr[15]='\0';
            }
            else
               wSTRNCPY(ifinfo->ipaddr, "none", 15);
#endif
        }

        /* check the mask */
        if(strncmp(string, "mask", 4) == 0)
        {
            char ttstr[16];
            char *ttp = ttstr;

            str = strtok_r(string, "=", &ttp);
            if(*ttp != '\0')
            {
               strcpy(ifinfo->mask, ttp);
               slen = strlen(ifinfo->mask);
               ifinfo->mask[slen-1] = '\0';
            }
            else
               strcpy(ifinfo->mask, "none");
        }

        /* find out the dns server ip address */
        if(strncmp(string, "nameserv", 8) == 0)
        {
            char ttstr[16];
            char *ttp = ttstr;

            str = strtok_r(string, " ", &ttp);
            if(str != NULL && i < 2)
            {
               strcpy(ifinfo->dns[i], ttp);
               slen = strlen(ifinfo->dns[i]);
               ifinfo->dns[i][slen-1] = '\0';
            }
#ifdef MTK_P2P_SIGMA
            else if (i < 2)
#else
            else
#endif
               strcpy(ifinfo->dns[i], "none");


            i++;
        }
     }

     /*
      * Report back the results
      */
     ipconfigResp->status = STATUS_COMPLETE;
     wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)ipconfigResp, respBuf);

     *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

#if 1
     DPRINT_INFO(WFA_OUT, "status[%i] isDhcp[%i] ipaddr[%s] mask[%s] dns0[%s] dns1[%s] %i\n", ipconfigResp->status,
        ifinfo->isDhcp, ifinfo->ipaddr, ifinfo->mask,
            ifinfo->dns[0], ifinfo->dns[1], *respLen);
#endif

     fclose(tmpfd);
     return WFA_SUCCESS;

error:
	printf("fail\n");
	ipconfigResp->status = STATUS_ERROR;
    wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);   

    *respLen = WFA_TLV_HDR_LEN + 4;
    return WFA_FAILURE;
}

/*
 * wfaStaSetIpConfig():
 *   The function is to set the ip configuration to a wireless I/F.
 *   1. IP address
 *   2. Mac address
 *   3. default gateway
 *   4. dns nameserver (pri and sec).
 */
int wfaStaSetIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *setIpConf = (dutCommand_t *)caCmdBuf;
   char *ifname = setIpConf->cmdsu.ipconfig.intf;   
   caStaSetIpConfig_t *ipconfig = &setIpConf->cmdsu.ipconfig;
   dutCmdResponse_t *staSetIpResp = &gGenericResp;

   char temp_str[256] = "";
   char *tmpfilename = TMP_ASEC_PATH"staHs2Assoc.txt";

   int curr_conn = wfaStaCheckIsConnected(ifname);

   DPRINT_INFO(WFA_OUT, "entering wfaStaSetIpConfig: %s, %d, %d...\n", ipconfig->ipaddr, ipconfig->type, ipconfig->isDhcp);

   if(ipconfig->isDhcp) {
   		//FILE *tmpfile = NULL;
		
   		//system("setprop mediatek.wlan.hs20.sigma 0");
		fgIsDhcpOn = 1;

#if 0
		
		MTK_HS20_CMD("-i %s get_curr_assoc > %s \n", ifname, tmpfilename);
		tmpfile = fopen(tmpfilename, "r+");
		if (tmpfile == NULL) {
			DPRINT_INFO(WFA_OUT, "Get current connection failed!!!");
			staSetIpResp->status = STATUS_INVALID;
			wfaEncodeTLV(WFA_STA_SET_IP_CONFIG_RESP_TLV, 4, (BYTE *)staSetIpResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			return WFA_FAILURE;
		}

		for(;;)
		{
			if(fscanf(tmpfile, "%s", temp_str) == EOF)
			{
				if(strncmp(temp_str, "FAIL", 4) == 0)
					curr_conn = 0;
				break;
			}
		}
#endif

		if(curr_conn == 0){
			DPRINT_INFO(WFA_OUT, "Currently no connection...\n");
   		}
   		else {
			if(ipconfig->type == 2){	//ipv6
				DPRINT_INFO(WFA_OUT, "Currently ipv6 dhcp connection...\n");
				;
			}
			else {
				int j;
				
				DPRINT_INFO(WFA_OUT, "Currently ipv4 dhcp connection...\n");
				system("netcfg wlan0 dhcp");	

				printf("Acquiring dhcp");
				for(j=1; j<=10; j++){
					printf(".", j);
					buzz_time(1500000);
				}
				printf("\n");

				
				/*
				DPRINT_INFO(WFA_OUT, "Invalid SetIpConfig type: %d\n", ipconfig->type);
				staSetIpResp->status = STATUS_INVALID;
				wfaEncodeTLV(WFA_STA_SET_IP_CONFIG_RESP_TLV, 4, (BYTE *)staSetIpResp, respBuf);
				*respLen = WFA_TLV_HDR_LEN + 4;
				return WFA_FAILURE;
				*/
			}
		}

		//fclose(tmpfile);
		
   }
   else {
		if(curr_conn == 1){ // Set ipconfig after association
   

   /*
    * Use command 'ifconfig' to configure the interface ip address, mask.
    * (Linux specific).
    */
    	if(ipconfig->type != 2){	//ipv4

#if (!defined MTK_P2P_SUPPLICANT) && (!defined MTK_HS20_SIGMA)
		   sprintf(gCmdStr, "/sbin/ifconfig %s %s netmask %s > /dev/null 2>&1 ", ipconfig->intf, ipconfig->ipaddr, ipconfig->mask);
#else
		   sprintf(gCmdStr, "ifconfig %s %s netmask %s > /dev/null 2>&1 ", ipconfig->intf, ipconfig->ipaddr, ipconfig->mask);
#endif
		   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
		   system(gCmdStr);

		   /* use command 'route add' to set set gatewway (linux specific) */
		   if(ipconfig->defGateway[0] != '\0')
		   {
#if (!defined MTK_P2P_SUPPLICANT) && (!defined MTK_HS20_SIGMA)
		      sprintf(gCmdStr, "/sbin/route add default gw %s > /dev/null 2>&1", ipconfig->defGateway);
#else
		      sprintf(gCmdStr, "/system/bin/route add default gw %s > /dev/null 2>&1", ipconfig->defGateway);
#endif
			  DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
		      system(gCmdStr);
		   }

#if (!defined MTK_P2P_SUPPLICANT) && (!defined MTK_HS20_SIGMA)
		   /* set dns (linux specific) */
		   sprintf(gCmdStr, "cp /etc/resolv.conf /tmp/resolv.conf.bk");
           DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
		   system(gCmdStr);
		   sprintf(gCmdStr, "echo nameserv %s > /etc/resolv.conf", ipconfig->pri_dns);
		   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
		   system(gCmdStr);
		   sprintf(gCmdStr, "echo nameserv %s >> /etc/resolv.conf", ipconfig->sec_dns);
		   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
		   system(gCmdStr);
#else
		   sprintf(gCmdStr, "setprop dhcp.%s.dns1 %s", ipconfig->intf, ipconfig->pri_dns);
           DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
		   system(gCmdStr);
		   sprintf(gCmdStr, "setprop dhcp.%s.dns2 %s", ipconfig->intf, ipconfig->sec_dns);
		   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
		   system(gCmdStr);
		   sprintf(gCmdStr, "setprop net.dns1 %s", ipconfig->pri_dns);
		   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
		   system(gCmdStr);
		   sprintf(gCmdStr, "setprop net.dns2 %s", ipconfig->sec_dns);
		   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
		   system(gCmdStr);

#endif
    	}
		else {	//ipv6
			//1 Format [busybox-full ifconfig wlan0 add fe80::8eb8:64ff:fe3c:7a77/64] 
			sprintf(gCmdStr, "/data/busybox-full ifconfig %s add %s", ipconfig->intf, ipconfig->ipaddr);
			DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
		   	system(gCmdStr);

		}
#if 0		
		else{	//wrong type
			DPRINT_INFO(WFA_OUT, "Invalid SetIpConfig type: %d\n", ipconfig->type);
			staSetIpResp->status = STATUS_INVALID;
			wfaEncodeTLV(WFA_STA_SET_IP_CONFIG_RESP_TLV, 4, (BYTE *)staSetIpResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			return WFA_FAILURE;
		}
#endif		
	}
	else { // Keep ipconfig before association
		memcpy(&g_ipconfig, ipconfig, sizeof(caStaSetIpConfig_t));
		DPRINT_INFO(WFA_OUT, "The preset ip[%s] netmask[%s]", g_ipconfig.ipaddr, g_ipconfig.mask);
		g_ipconfig_isSet = 1;
	}
}

   /*
    * report status
    */
   staSetIpResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_IP_CONFIG_RESP_TLV, 4, (BYTE *)staSetIpResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

/*
 * wfaStaVerifyIpConnection():
 * The function is to verify if the station has IP connection with an AP by
 * send ICMP/pings to the AP.
 */
int wfaStaVerifyIpConnection(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *verip = (dutCommand_t *)caCmdBuf;
   dutCmdResponse_t *verifyIpResp = &gGenericResp;

#ifndef WFA_PING_UDP_ECHO_ONLY
   char strout[64], *pcnt;
   FILE *tmpfile;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaVerifyIpConnection ...\n");

   /* set timeout value in case not set */
   if(verip->cmdsu.verifyIp.timeout <= 0)
   {
        verip->cmdsu.verifyIp.timeout = 10;
   }

   /* execute the ping command  and pipe the result to a tmp file */
#if defined MTK_HS20_SIGMA
	sprintf(gCmdStr, SIGMA_PING" -c 3 -W %u %s | grep loss | cut -f 2 -d ',' | cut -f 2 -d ' ' > "TMP_ASEC_PATH"pingout.txt", verip->cmdsu.verifyIp.timeout, verip->cmdsu.verifyIp.dipaddr);
#elif !defined (MTK_P2P_SUPPLICANT)
   sprintf(gCmdStr, SIGMA_PING" %s -c 3 -W %u | grep loss | cut -f3 -d, 1>& /tmp/pingout.txt", verip->cmdsu.verifyIp.dipaddr, verip->cmdsu.verifyIp.timeout);
#else
   sprintf(gCmdStr, SIGMA_PING" %s -c 3 -W %u | grep loss | cut -f3 -d, 1>& "TMP_ASEC_PATH"pingout.txt", verip->cmdsu.verifyIp.dipaddr, verip->cmdsu.verifyIp.timeout);
#endif
   system(gCmdStr);

   /* scan/check the output */
#if (!defined MTK_P2P_SUPPLICANT) && (!defined MTK_HS20_SIGMA)
   tmpfile = fopen("/tmp/pingout.txt", "r+");
#else
   tmpfile = fopen(TMP_ASEC_PATH"pingout.txt", "r+");
#endif
   if(tmpfile == NULL)
   {
      verifyIpResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, 4, (BYTE *)verifyIpResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return WFA_FAILURE;
   }

   verifyIpResp->status = STATUS_COMPLETE;
   if(fscanf(tmpfile, "%s", strout) == EOF)
       verifyIpResp->cmdru.connected = 0;
   else
   {
#ifdef MTK_HS20_SIGMA
	/* if packet received is 0, not able to connect */
	if(atoi(strout) == 0)
	   verifyIpResp->cmdru.connected = 0;
	else
	   verifyIpResp->cmdru.connected = 1;
#else
       pcnt = strtok(strout, "%");

       /* if the loss rate is 100%, not able to connect */
       if(atoi(pcnt) == 100)
          verifyIpResp->cmdru.connected = 0;
       else
          verifyIpResp->cmdru.connected = 1;
#endif
   }

   fclose(tmpfile);
#else
   int btSockfd;
   struct pollfd fds[2];
   int timeout = 2000;
   char anyBuf[64];
   struct sockaddr_in toAddr;
   int done = 1, cnt = 0, ret, nbytes;

   verifyIpResp->status = STATUS_COMPLETE;
   verifyIpResp->cmdru.connected = 0;

   btSockfd = wfaCreateUDPSock("127.0.0.1", WFA_UDP_ECHO_PORT);

   if(btSockfd == -1)
   {
      verifyIpResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, 4, (BYTE *)verifyIpResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;
      return WFA_FAILURE;;
   }

   toAddr.sin_family = AF_INET;
   toAddr.sin_addr.s_addr = inet_addr(verip->cmdsu.verifyIp.dipaddr);
   toAddr.sin_port = htons(WFA_UDP_ECHO_PORT);

   while(done)
   {
       wfaTrafficSendTo(btSockfd, (char *)anyBuf, 64, (struct sockaddr *)&toAddr);
       cnt++;

       fds[0].fd = btSockfd;
       fds[0].events = POLLIN | POLLOUT;

       ret = poll(fds, 1, timeout);
       switch(ret)
       {
           case 0:
             /* it is time out, count a packet lost*/
           break;
           case -1:
             /* it is an error */
           default:
           {
              switch(fds[0].revents)
              {
                  case POLLIN:
                  case POLLPRI:
                  case POLLOUT:
                  nbytes = wfaTrafficRecv(btSockfd, (char *)anyBuf, (struct sockaddr *)&toAddr);
                  if(nbytes != 0)
                      verifyIpResp->cmdru.connected = 1;
                      done = 0;
                  break;
                  default:
                  /* errors but not care */
                   ;
              }
           }
       }
       if(cnt == 3)
       {
          done = 0;
       }
   }

#endif

   wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)verifyIpResp, respBuf);

   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   return WFA_SUCCESS;
}

/*
 * wfaStaGetMacAddress()
 *    This function is to retrieve the MAC address of a wireless I/F.
 */
int wfaStaGetMacAddress(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *getMac = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *getmacResp = &gGenericResp;
    char *str;
    char *ifname = getMac->intf;

    FILE *tmpfd;
#if !defined (MTK_P2P_SUPPLICANT)
    char string[128];
#else
    char string[256];
#endif

    DPRINT_INFO(WFA_OUT, "Entering wfaStaGetMacAddress ...\n");
    /*
     * run the script "getipconfig.sh" to find out the mac
     */
#if !defined (MTK_P2P_SUPPLICANT)
    //sprintf(gCmdStr, "getipconfig.sh /tmp/ipconfig.txt %s", ifname);
    sprintf(gCmdStr, "ifconfig %s > /tmp/ipconfig.txt ", ifname);
    system(gCmdStr);

    tmpfd = fopen("/tmp/ipconfig.txt", "r+");
    if(tmpfd == NULL)
    {
      getmacResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_GET_MAC_ADDRESS_RESP_TLV, 4, (BYTE *)getmacResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return WFA_FAILURE;
    }

        if(fgets(string, 256, tmpfd) == NULL)
        {
           getmacResp->status = STATUS_ERROR;
        }

         str = strtok(string, " ");
         while(str && ((strcmp(str,"HWaddr")) != 0))
        {
            str = strtok(NULL, " ");
        }

        /* get mac */
        if(str)
            {
          str = strtok(NULL, " ");
          strcpy(getmacResp->cmdru.mac, str);
               getmacResp->status = STATUS_COMPLETE;
    }
#else
    wfaGetIpConfig(ifname, NULL, getmacResp->cmdru.mac, NULL);
    getmacResp->status = STATUS_COMPLETE;
    DPRINT_ERR(WFA_ERR, "getmacResp->cmdru.mac:%s\n", getmacResp->cmdru.mac);
#endif


    wfaEncodeTLV(WFA_STA_GET_MAC_ADDRESS_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)getmacResp, respBuf);

    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
#if !defined (MTK_P2P_SUPPLICANT)
    fclose(tmpfd);
#endif
    return WFA_SUCCESS;
}

/*
 * wfaStaGetStats():
 * The function is to retrieve the statistics of the I/F's layer 2 txFrames,
 * rxFrames, txMulticast, rxMulticast, fcsErrors/crc, and txRetries.
 * Currently there is not definition how to use these info.
 */
int wfaStaGetStats(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *statsResp = &gGenericResp;

   /* this is never used, you can skip this call */

   statsResp->status = STATUS_ERROR;
   wfaEncodeTLV(WFA_STA_GET_STATS_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)statsResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);


   return WFA_SUCCESS;
}

/*
 * wfaSetEncryption():
 *   The function is to set the wireless interface with WEP or none.
 *
 *   Since WEP is optional test, current function is only used for
 *   resetting the Security to NONE/Plaintext (OPEN). To test WEP,
 *   this function should be replaced by the next one (wfaSetEncryption1())
 *
 *   Input parameters:
 *     1. I/F
 *     2. ssid
 *     3. encpType - wep or none
 *     Optional:
 *     4. key1
 *     5. key2
 *     6. key3
 *     7. key4
 *     8. activeKey Index
 */

int wfaSetEncryption1(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
   dutCmdResponse_t *setEncrypResp = &gGenericResp;

   /*
    * disable the network first
    */
   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s disable_network 0", setEncryp->intf);
   system(gCmdStr);

   /*
    * set SSID
    */
   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 ssid '\"%s\"'", setEncryp->intf, setEncryp->ssid);
   system(gCmdStr);

   /*
    * Tell the supplicant for infrastructure mode (1)
    */
   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 mode 0", setEncryp->intf);
   system(gCmdStr);

   /*
    * set Key management to NONE (NO WPA) for plaintext or WEP
    */
   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 key_mgmt NONE", setEncryp->intf);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s enable_network 0", setEncryp->intf);
   system(gCmdStr);

   setEncrypResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

/*
 *  Since WEP is optional, this function could be used to replace
 *  wfaSetEncryption() if necessary.
 */
int wfaSetEncryption(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
   dutCmdResponse_t *setEncrypResp = &gGenericResp;
   int i;

#ifdef MTK_HS20_SIGMA
	char *filename = TMP_ASEC_PATH"net_idx.txt";   
	FILE *fd;
   	char idx[16];
   	int idx_i; 

	DPRINT_INFO(WFA_OUT, "Enter [%s]", __func__);

	// Add a profile
	MTK_HS20_CMD("-i %s add_network > %s", setEncryp->intf, filename);
	// Get network index
	fd = fopen(filename, "r+");
	
	if ((NULL == fd) || (NULL == fgets(idx, 16, fd))) {
		printf("fail: %s \n", filename);

		setEncrypResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;
		return WFA_FAILURE;
	}
	else {
		idx_i = atoi(idx);
		DPRINT_INFO(WFA_OUT, "[%s]The network index is [%d]\n", __func__, idx_i);
	}

	/*
		* disable the network first
		*/
	   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s disable_network %d", setEncryp->intf, idx_i);
	   system(gCmdStr);
	
	   /*
		* set SSID
		*/
	   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network %d ssid '\"%s\"'", setEncryp->intf, idx_i, setEncryp->ssid);
	   system(gCmdStr);
	
	   /*
		* Tell the supplicant for infrastructure mode (1)
		*/
	   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network %d mode 0", setEncryp->intf, idx_i);
	   system(gCmdStr);
	
	   /*
		* set Key management to NONE (NO WPA) for plaintext or WEP
		*/
	   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network %d key_mgmt NONE", setEncryp->intf, idx_i);
	   system(gCmdStr);
	
	   /* set keys */
	   if(setEncryp->encpType == 1)
	   {
		  for(i=0; i<4; i++)
		  {
			 if(setEncryp->keys[i][0] != '\0')
			 {
				 sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network %d wep_key%i %s",
					   setEncryp->intf, idx_i, i, setEncryp->keys[i]);
				 system(gCmdStr);
			 }
		  }
	
		  /* set active key */
		  i = setEncryp->activeKeyIdx;
		  if(setEncryp->keys[i][0] != '\0')
		  {
			  sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network %d wep_tx_keyidx %i",
				setEncryp->intf, idx_i, setEncryp->activeKeyIdx);
			  system(gCmdStr);
		  }
	   }
	   else /* clearly remove the keys -- reported by p.schwann */
	   {
	
		  for(i = 0; i < 4; i++)
		  {
			  sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network %d wep_key%i \"\"", setEncryp->intf, idx_i, i);
			  system(gCmdStr);
		  }
	   }
	
	   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s enable_network %d", setEncryp->intf, idx_i);
	   system(gCmdStr);


fclose(fd);


#else
   /*
    * disable the network first
    */
   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s disable_network 0", setEncryp->intf);
   system(gCmdStr);

   /*
    * set SSID
    */
   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 ssid '\"%s\"'", setEncryp->intf, setEncryp->ssid);
   system(gCmdStr);

   /*
    * Tell the supplicant for infrastructure mode (1)
    */
   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 mode 0", setEncryp->intf);
   system(gCmdStr);

   /*
    * set Key management to NONE (NO WPA) for plaintext or WEP
    */
   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 key_mgmt NONE", setEncryp->intf);
   system(gCmdStr);

   /* set keys */
   if(setEncryp->encpType == 1)
   {
      for(i=0; i<4; i++)
      {
         if(setEncryp->keys[i][0] != '\0')
         {
             sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 wep_key%i %s",
                   setEncryp->intf, i, setEncryp->keys[i]);
             system(gCmdStr);
         }
      }

      /* set active key */
      i = setEncryp->activeKeyIdx;
      if(setEncryp->keys[i][0] != '\0')
      {
          sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 wep_tx_keyidx %i",
            setEncryp->intf, setEncryp->activeKeyIdx);
          system(gCmdStr);
      }
   }
   else /* clearly remove the keys -- reported by p.schwann */
   {

      for(i = 0; i < 4; i++)
      {
          sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 wep_key%i \"\"", setEncryp->intf, i);
          system(gCmdStr);
      }
   }

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s enable_network 0", setEncryp->intf);
   system(gCmdStr);
#endif

   setEncrypResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

int wfaStaSetSecurity(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    int ret = WFA_SUCCESS;

    return ret;
}

/*
 * wfaStaSetEapTLS():
 *   This is to set
 *   1. ssid
 *   2. encrypType - tkip or aes-ccmp
 *   3. keyManagementType - wpa or wpa2
 *   4. trustedRootCA
 *   5. clientCertificate
 */
int wfaStaSetEapTLS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapTLS_t *setTLS = (caStaSetEapTLS_t *)caCmdBuf;
   char *ifname = setTLS->intf;
   dutCmdResponse_t *setEapTlsResp = &gGenericResp;
   FILE *fd;
   char *filename = TMP_ASEC_PATH"net_idx.txt";
   char idx[16];
   int idx_i;
   char *trustedRootCAStr;
   char *clientCertificateStr;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __func__);

   /*
    * need to store the trustedROOTCA and clientCertificate into a file first.
    */
#if defined(MTK_AC_SIGMA)

	// Add a profile
	MTK_AC_CMD("-i %s add_network > %s", setTLS->intf, filename);
	// Get network index
	fd = fopen(filename, "r+");

	if ((NULL == fd) || (NULL == fgets(idx, 16, fd))) {
		printf("fail: %s \n", filename);
		setEapTlsResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_SET_EAPTLS_RESP_TLV, 4, (BYTE *)setEapTlsResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;
		return WFA_FAILURE;
	}
	else {
		idx_i = atoi(idx);
		DPRINT_INFO(WFA_OUT, "[%s]The network index is [%d]", __func__, idx_i);
	}

	// Disable networok
	MTK_AC_CMD("-i %s disable_network %d", setTLS->intf, idx_i);
	// Set parameters to new profile

	MTK_AC_CMD("-i %s set_network %d ssid '\"%s\"'", setTLS->intf, idx_i, setTLS->ssid);
	MTK_AC_CMD("-i %s set_network %d key_mgmt 'WPA-EAP IEEE8021X'", setTLS->intf, idx_i);
    #if defined(MTK_PMF_SIGMA)
        if(setTLS->pmf == WFA_ENABLED || setTLS->pmf == WFA_OPTIONAL)
        {
            MTK_AC_CMD("-i %s set_network %d key_mgmt WPA-EAP IEEE8021X WPA-EAP-SHA256", setTLS->intf, idx_i);
            MTK_AC_CMD("-i %s set_network %d ieee80211w 1", setTLS->intf, idx_i);
        }
        else if(setTLS->pmf == WFA_REQUIRED)
        {
            MTK_AC_CMD("-i %s set_network %d key_mgmt WPA-EAP IEEE8021X WPA-EAP-SHA256", setTLS->intf,idx_i);
            MTK_AC_CMD("-i %s set_network %d ieee80211w 2", setTLS->intf, idx_i);
        } 
        else if(setTLS->pmf == WFA_F_REQUIRED)
        {   
            MTK_AC_CMD("-i %s set_network %d key_mgmt WPA-EAP IEEE8021X WPA-EAP-SHA256", setTLS->intf, idx_i);
            MTK_AC_CMD("-i %s set_network %d ieee80211w 2", setTLS->intf, idx_i);
        }
        else if(setTLS->pmf == WFA_F_DISABLED)
        {
            MTK_AC_CMD("-i %s set_network %d ieee80211w 0", setTLS->intf, idx_i);
        }
        else
        {   /* Disable PMF */
            //MTK_AC_CMD("-i %s set_network %d ieee80211w 0", setTLS->intf, idx_i);
        }
    #endif

	//Remove unintended file extension from UCC config
	trustedRootCAStr = remove_ext(setTLS->trustedRootCA, '.');
	clientCertificateStr = remove_ext(setTLS->clientCertificate, '.');

	MTK_AC_CMD("-i %s set_network %d eap TLS", setTLS->intf, idx_i);	
	MTK_AC_CMD("-i %s set_network %d ca_cert '\"%s/%s.pem\"'", setTLS->intf, idx_i, CERTIFICATES_PATH, trustedRootCAStr);
	MTK_AC_CMD("-i %s set_network %d identity '\"wifi-user\"'", setTLS->intf, idx_i);
	MTK_AC_CMD("-i %s set_network %d client_cert '\"%s/%s.pem\"'", setTLS->intf, idx_i, CERTIFICATES_PATH, clientCertificateStr);
	MTK_AC_CMD("-i %s set_network %d private_key '\"%s/%s.key\"'", setTLS->intf, idx_i, CERTIFICATES_PATH, clientCertificateStr);
	MTK_AC_CMD("-i %s set_network %d private_key_passwd '\"wifi\"'", setTLS->intf, idx_i);

	// Save config
	MTK_AC_CMD("-i %s save_config", setTLS->intf);

	MTK_AC_CMD("-i %s enable_network %d", setTLS->intf, idx_i);


#elif 0
//ToDO Add TLS for HS20
//#ifdef MTK_HS20_SIGMA
	   
		   if(strcasecmp(setTTLS->prog, "hs2") == 0){
			   DPRINT_INFO(WFA_OUT, "[%s]The Prog is [%s]", __func__, setTTLS->prog);
	   
			   // Add a profile
			   MTK_HS20_CMD("-i %s add_network > %s", setTTLS->intf, filename);
			   // Get network index
			   fd = fopen(filename, "r+");
			   
			   if ((NULL == fd) || (NULL == fgets(idx, 16, fd))) {
				   printf("fail: %s \n", filename);
				   setTTLS->status = STATUS_ERROR;
				   wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setTTLS, respBuf);
				   *respLen = WFA_TLV_HDR_LEN + 4;
				   return WFA_FAILURE;
			   }
			   else {
				   idx_i = atoi(idx);
				   DPRINT_INFO(WFA_OUT, "[%s]The network index is [%d]", __func__, idx_i);
			   }
	   
			   // Disable networok
			   MTK_HS20_CMD("-i %s disable_network %d", ifname, idx_i);
			   // Set parameters to new profile
			   
			   MTK_HS20_CMD("-i %s set_network %d ssid '\"%s\"'", ifname, idx_i, setTTLS->ssid);
			   MTK_HS20_CMD("-i %s set_network %d key_mgmt 'WPA-EAP IEEE8021X'", ifname, idx_i);
			   MTK_HS20_CMD("-i %s set_network %d priority %d", ifname, idx_i, setTTLS->prefer);
			   MTK_HS20_CMD("-i %s set_network %d eap TTLS", ifname, idx_i);
			   MTK_HS20_CMD("-i %s set_network %d phase2 '\"auth=MSCHAPV2\"'", ifname, idx_i);
			   MTK_HS20_CMD("-i %s set_network %d identity '\"%s\"'", ifname, idx_i, setTTLS->username);
			   MTK_HS20_CMD("-i %s set_network %d anonymous_identity %s", ifname, idx_i, anonymous_id);
			   MTK_HS20_CMD("-i %s set_network %d password '\"%s\"'", ifname, idx_i, setTTLS->passwd);
			   MTK_HS20_CMD("-i %s set_network %d client_cert NULL", ifname, idx_i);
			   MTK_HS20_CMD("-i %s set_network %d private_key NULL", ifname, idx_i);
			   MTK_HS20_CMD("-i %s set_network %d ca_cert NULL", ifname, idx_i);
			   MTK_HS20_CMD("-i %s set_network %d imsi '\"none\"'", ifname, idx_i);
			   MTK_HS20_CMD("-i %s set_network %d sim_slot '\"-1\"'", ifname, idx_i);
			   MTK_HS20_CMD("-i %s set_network %d pcsc '\"none\"'", ifname, idx_i); 	   
	   
			   // Save config
			   MTK_HS20_CMD("-i %s save_config", setPSK->intf);
		   }
	   
	   
#else

   
#ifdef WFA_NEW_CLI_FORMAT
   sprintf(gCmdStr, "wfa_set_eaptls -i %s %s %s %s", ifname, setTLS->ssid, setTLS->trustedRootCA, setTLS->clientCertificate);
   system(gCmdStr);
#else

   //sprintf(gCmdStr, "wpa_cli -p" WPA_CTRL_IF "-i %s disable_network 0", ifname);
   //system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s add_network", ifname, setTLS->ssid);
   system(gCmdStr);

   /* ssid */
   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 ssid '\"%s\"'", ifname, setTLS->ssid);
   system(gCmdStr);

   /* key management */
   if(strcasecmp(setTLS->keyMgmtType, "wpa2-sha256") == 0)
   {
   }
   else if(strcasecmp(setTLS->keyMgmtType, "wpa2-eap") == 0)
   {
   }
   else if(strcasecmp(setTLS->keyMgmtType, "wpa2-ft") == 0)
   {

   }
   else if(strcasecmp(setTLS->keyMgmtType, "wpa") == 0)
   {
      sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   }
   else if(strcasecmp(setTLS->keyMgmtType, "wpa2") == 0)
   {
      // to take all and device to pick any one supported.
   }
   else
   {
      // ??
   }
   system(gCmdStr);

   /* protocol WPA */
   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 proto WPA", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 eap TLS", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 ca_cert '\"%s\"'", ifname, setTLS->trustedRootCA);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 identity '\"wifi-user@wifilabs.local\"'", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 private_key '\"%s/%s\"'", ifname, CERTIFICATES_PATH, setTLS->clientCertificate);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 private_key_passwd '\"wifi\"'", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s enable_network 0", ifname);
   system(gCmdStr);
#endif

#endif /* MTK_HS20_SIGMA */

   setEapTlsResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_EAPTLS_RESP_TLV, 4, (BYTE *)setEapTlsResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

/*
 * The function is to set
 *   1. ssid
 *   2. passPhrase
 *   3. keyMangementType - wpa/wpa2
 *   4. encrypType - tkip or aes-ccmp
 */
int wfaStaSetPSK(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetPSK_t *setPSK = (caStaSetPSK_t *)caCmdBuf;
   dutCmdResponse_t *setPskResp = &gGenericResp;

   FILE *fd;
   char *filename = TMP_ASEC_PATH"net_idx.txt";
   char idx[16];
   int idx_i;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __func__);

#if defined(MTK_AC_SIGMA)

	// Add a profile
	MTK_AC_CMD("-i %s add_network > %s", setPSK->intf, filename);
	// Get network index
	fd = fopen(filename, "r+");
	
	if ((NULL == fd) || (NULL == fgets(idx, 16, fd))) {
		printf("fail: %s \n", filename);
		setPskResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setPskResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;
		return WFA_FAILURE;
	}
	else {
		idx_i = atoi(idx);
		DPRINT_INFO(WFA_OUT, "[%s]The network index is [%d]", __func__, idx_i);
	}

	// Disable networok
	MTK_AC_CMD("-i %s disable_network %d", setPSK->intf, idx_i);
	// Set parameters to new profile
	
	MTK_AC_CMD("-i %s set_network %d ssid '\"%s\"'", setPSK->intf, idx_i, setPSK->ssid);
	MTK_AC_CMD("-i %s set_network %d key_mgmt 'WPA-PSK'", setPSK->intf, idx_i);
    #if defined(MTK_PMF_SIGMA)
    if(setPSK->pmf == WFA_ENABLED || setPSK->pmf == WFA_OPTIONAL)
    {
        MTK_AC_CMD("-i %s set_network %d key_mgmt WPA-PSK WPA-PSK-SHA256", setPSK->intf, idx_i);
        MTK_AC_CMD("-i %s set_network %d ieee80211w 1", setPSK->intf, idx_i);
    }
    else if(setPSK->pmf == WFA_REQUIRED)
    {
        MTK_AC_CMD("-i %s set_network %d key_mgmt WPA-PSK WPA-PSK-SHA256", setPSK->intf,idx_i);
        MTK_AC_CMD("-i %s set_network %d ieee80211w 2", setPSK->intf, idx_i);
    }
    else if(setPSK->pmf == WFA_F_REQUIRED)
    {   
        MTK_AC_CMD("-i %s set_network %d key_mgmt WPA-PSK WPA-PSK-SHA256", setPSK->intf, idx_i);
        MTK_AC_CMD("-i %s set_network %d ieee80211w 2", setPSK->intf, idx_i);
    } 
    else if(setPSK->pmf == WFA_F_DISABLED)
    {
        MTK_AC_CMD("-i %s set_network %d ieee80211w 0", setPSK->intf, idx_i);
    } 
    else
    {   /* Disable PMF */
        //MTK_AC_CMD("-i %s set_network %d ieee80211w 0", setPSK->intf, idx_i);
    }
    #endif

	MTK_AC_CMD("-i %s set_network %d psk '\"%s\"'", setPSK->intf, idx_i, setPSK->passphrase);
	MTK_AC_CMD("-i %s set_network %d priority %d", setPSK->intf, idx_i, (setPSK->prefer==1?1:0));
	MTK_AC_CMD("-i %s set_network %d imsi '\"none\"'", setPSK->intf, idx_i);
	MTK_AC_CMD("-i %s set_network %d sim_slot '\"-1\"'", setPSK->intf, idx_i);
	MTK_AC_CMD("-i %s set_network %d pcsc '\"none\"'", setPSK->intf, idx_i);		

	// Save config
	MTK_AC_CMD("-i %s save_config", setPSK->intf);

	MTK_AC_CMD("-i %s enable_network %d", setPSK->intf, idx_i);

#elif defined (MTK_HS20_SIGMA)
	//if(strcasecmp(setPSK->prog, "hs2") == 0){
		DPRINT_INFO(WFA_OUT, "[%s]The Prog is [%s]", __func__, setPSK->prog);

		// Add a profile
		MTK_HS20_CMD("-i %s add_network > %s", setPSK->intf, filename);
		// Get network index
		fd = fopen(filename, "r+");
		
		if ((NULL == fd) || (NULL == fgets(idx, 16, fd))) {
			printf("fail: %s \n", filename);
			setPskResp->status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setPskResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			return WFA_FAILURE;
		}
		else {
			idx_i = atoi(idx);
			DPRINT_INFO(WFA_OUT, "[%s]The network index is [%d]", __func__, idx_i);
		}

		// Disable networok
		MTK_HS20_CMD("-i %s disable_network %d", setPSK->intf, idx_i);
		// Set parameters to new profile
		
		MTK_HS20_CMD("-i %s set_network %d ssid '\"%s\"'", setPSK->intf, idx_i, setPSK->ssid);
		MTK_HS20_CMD("-i %s set_network %d key_mgmt 'WPA-PSK'", setPSK->intf, idx_i);
		MTK_HS20_CMD("-i %s set_network %d psk '\"%s\"'", setPSK->intf, idx_i, setPSK->passphrase);
		MTK_HS20_CMD("-i %s set_network %d priority %d", setPSK->intf, idx_i, (setPSK->prefer==1?1:0));
		MTK_HS20_CMD("-i %s set_network %d imsi '\"none\"'", setPSK->intf, idx_i);
		MTK_HS20_CMD("-i %s set_network %d sim_slot '\"-1\"'", setPSK->intf, idx_i);
		MTK_HS20_CMD("-i %s set_network %d pcsc '\"none\"'", setPSK->intf, idx_i);		

		// Save config
		MTK_HS20_CMD("-i %s save_config", setPSK->intf);

		MTK_HS20_CMD("-i %s enable_network %d", setPSK->intf, idx_i);
	//}

#else   

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s add_network 0", setPSK->intf);
   system(gCmdStr);

#ifndef WFA_PC_CONSOLE

#ifdef WFA_NEW_CLI_FORMAT
   sprintf(gCmdStr, "wfa_set_psk %s %s %s", setPSK->intf, setPSK->ssid, setPSK->passphrase);
   system(gCmdStr);
#else
   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 ssid '\"%s\"'", setPSK->intf, setPSK->ssid);
   system(gCmdStr);

   if(strcasecmp(setPSK->keyMgmtType, "wpa2-sha256") == 0)
       sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 key_mgmt WPA2-SHA256", setPSK->intf);
   else if(strcasecmp(setPSK->keyMgmtType, "wpa2") == 0)
   {
     // take all and device to pick it supported.
   }
   else if(strcasecmp(setPSK->keyMgmtType, "wpa2-psk") == 0)
   {

   }
   else if(strcasecmp(setPSK->keyMgmtType, "wpa2-ft") == 0)
   {

   }
   else
       sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 key_mgmt WPA-PSK", setPSK->intf);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 psk '\"%s\"'", setPSK->intf, setPSK->passphrase);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s enable_network 0", setPSK->intf);
   system(gCmdStr);

   /* if PMF enable */
   if(setPSK->pmf == WFA_ENABLED || setPSK->pmf == WFA_OPTIONAL)
   {

   }
   else if(setPSK->pmf == WFA_REQUIRED)
   {

   }
   else if(setPSK->pmf == WFA_F_REQUIRED)
   {

   }
   else if(setPSK->pmf == WFA_F_DISABLED)
   {

   }
   else
   {   /* Disable PMF */

   }

#endif

#endif

#endif /* MTK_HS20_SIGMA */

   setPskResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setPskResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   fclose(fd);
   return WFA_SUCCESS;
}

/*
 * wfaStaGetInfo():
 * Get vendor specific information in name/value pair by a wireless I/F.
 */
int wfaStaGetInfo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   dutCommand_t *getInfo = (dutCommand_t *)caCmdBuf;

   /*
    * Normally this is called to retrieve the vendor information
    * from a interface, no implement yet
    */
#ifdef MTK_AC_SIGMA
	sprintf(infoResp.cmdru.info, "interface,%s,vendor,MediaTek Inc.,cardtype,802.11a/b/g/n/ac", getInfo->intf);
#elif defined(MTK_HS20_SIGMA)
	sprintf(infoResp.cmdru.info, "interface,%s,vendor,MediaTek Inc.,cardtype,802.11a/b/g/n", getInfo->intf);
#else
   sprintf(infoResp.cmdru.info, "interface,%s,vendor,XXX,cardtype,802.11a/b/g", getInfo->intf);
#endif

   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_GET_INFO_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}

/*
 * wfaStaSetEapTTLS():
 *   This is to set
 *   1. ssid
 *   2. username
 *   3. passwd
 *   4. encrypType - tkip or aes-ccmp
 *   5. keyManagementType - wpa or wpa2
 *   6. trustedRootCA
 */
int wfaStaSetEapTTLS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapTTLS_t *setTTLS = (caStaSetEapTTLS_t *)caCmdBuf;
   char *ifname = setTTLS->intf;
   dutCmdResponse_t *setEapTtlsResp = &gGenericResp;
   char *anonymous_id = "anonymous@mail.example.com";
   FILE *fd;
   char *filename = TMP_ASEC_PATH"net_idx.txt";
   char idx[16];
   int idx_i; 

#ifdef MTK_HS20_SIGMA

	//if(strcasecmp(setTTLS->prog, "hs2") == 0){
		DPRINT_INFO(WFA_OUT, "[%s]The Prog is [%s]", __func__, setTTLS->prog);

		// Add a profile
		MTK_HS20_CMD("-i %s add_network > %s", setTTLS->intf, filename);
		// Get network index
		fd = fopen(filename, "r+");
		
		if ((NULL == fd) || (NULL == fgets(idx, 16, fd))) {
			printf("fail: %s \n", filename);
			setEapTtlsResp->status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setEapTtlsResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			return WFA_FAILURE;
		}
		else {
			idx_i = atoi(idx);
			DPRINT_INFO(WFA_OUT, "[%s]The network index is [%d]", __func__, idx_i);
		}

		// Disable networok
		//MTK_HS20_CMD("-i %s disable_network %d", ifname, idx_i);
		// Set parameters to new profile
		
		MTK_HS20_CMD("-i %s set_network %d ssid '\"%s\"'", ifname, idx_i, setTTLS->ssid);
		MTK_HS20_CMD("-i %s set_network %d key_mgmt 'WPA-EAP IEEE8021X'", ifname, idx_i);
        #if defined(MTK_PMF_SIGMA)
        if(setTTLS->pmf == WFA_ENABLED || setTTLS->pmf == WFA_OPTIONAL)
        {
            MTK_AC_CMD("-i %s set_network %d key_mgmt WPA-EAP IEEE8021X WPA-EAP-SHA256", setTTLS->intf, idx_i);
            MTK_AC_CMD("-i %s set_network %d ieee80211w 1", setTTLS->intf, idx_i);
        }
        else if(setTTLS->pmf == WFA_REQUIRED)
        {
            MTK_AC_CMD("-i %s set_network %d key_mgmt WPA-EAP IEEE8021X WPA-EAP-SHA256", setTTLS->intf,idx_i);
            MTK_AC_CMD("-i %s set_network %d ieee80211w 2", setTTLS->intf, idx_i);
        } 
        else if(setTTLS->pmf == WFA_F_REQUIRED)
        {   
            MTK_AC_CMD("-i %s set_network %d key_mgmt WPA-EAP IEEE8021X WPA-EAP-SHA256", setTTLS->intf, idx_i);
            MTK_AC_CMD("-i %s set_network %d ieee80211w 2", setTTLS->intf, idx_i);
        } 
        else if(setTTLS->pmf == WFA_F_DISABLED)
        {
            MTK_AC_CMD("-i %s set_network %d ieee80211w 0", setTTLS->intf, idx_i);
        } 
        else
        {   /* Disable PMF */
            //MTK_AC_CMD("-i %s set_network %d ieee80211w 0", setTTLS->intf, idx_i);
        }
        #endif
		MTK_HS20_CMD("-i %s set_network %d priority %d", ifname, idx_i, (setTTLS->prefer==1?1:0));
		MTK_HS20_CMD("-i %s set_network %d eap TTLS", ifname, idx_i);
		MTK_HS20_CMD("-i %s set_network %d phase2 '\"auth=MSCHAPV2\"'", ifname, idx_i);
		MTK_HS20_CMD("-i %s set_network %d identity '\"%s\"'", ifname, idx_i, setTTLS->username);
		MTK_HS20_CMD("-i %s set_network %d anonymous_identity %s", ifname, idx_i, anonymous_id);
		MTK_HS20_CMD("-i %s set_network %d password '\"%s\"'", ifname, idx_i, setTTLS->passwd);
		MTK_HS20_CMD("-i %s set_network %d client_cert NULL", ifname, idx_i);
		MTK_HS20_CMD("-i %s set_network %d private_key NULL", ifname, idx_i);
		MTK_HS20_CMD("-i %s set_network %d ca_cert '\"/data/misc/wifi/%s.pem\"'", ifname, idx_i, setTTLS->trustedRootCA);		
		MTK_HS20_CMD("-i %s set_network %d imsi '\"none\"'", ifname, idx_i);
		MTK_HS20_CMD("-i %s set_network %d sim_slot '\"-1\"'", ifname, idx_i);
		MTK_HS20_CMD("-i %s set_network %d pcsc '\"none\"'", ifname, idx_i);		

		// Save config
		MTK_HS20_CMD("-i %s save_config", setTTLS->intf);

		MTK_HS20_CMD("-i %s enable_network %d", ifname, idx_i);
	//}

	fclose(fd);

#else
#ifdef WFA_NEW_CLI_FORMAT
   sprintf(gCmdStr, "wfa_set_eapttls %s %s %s %s %s", ifname, setTTLS->ssid, setTTLS->username, setTTLS->passwd, setTTLS->trustedRootCA);
   system(gCmdStr);
#else

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s disable_network 0", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 ssid '\"%s\"'", ifname, setTTLS->ssid);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 identity '\"%s\"'", ifname, setTTLS->username);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 password '\"%s\"'", ifname, setTTLS->passwd);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   system(gCmdStr);

/* This may not need to set. if it is not set, default to take all */
//   sprintf(cmdStr, "wpa_cli -i %s set_network 0 pairwise '\"%s\"", ifname, setTTLS->encrptype);
   if(strcasecmp(setTTLS->keyMgmtType, "wpa2-sha256") == 0)
   {
   }
   else if(strcasecmp(setTTLS->keyMgmtType, "wpa2-eap") == 0)
   {
   }
   else if(strcasecmp(setTTLS->keyMgmtType, "wpa2-ft") == 0)
   {

   }
   else if(strcasecmp(setTTLS->keyMgmtType, "wpa") == 0)
   {

   }
   else if(strcasecmp(setTTLS->keyMgmtType, "wpa2") == 0)
   {
      // to take all and device to pick one it supported
   }
   else
   {
      // ??
   }
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 eap TTLS", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 ca_cert '\"%s/%s\"'", ifname, CERTIFICATES_PATH, setTTLS->trustedRootCA);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 proto WPA", ifname);
   system(gCmdStr);

//   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 anonymous_identity '\"anonymous\"'", ifname);
//   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 phase2 '\"auth=MSCHAPV2\"'", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s enable_network 0", ifname);
   system(gCmdStr);
#endif
#endif /* MTK_HS20_SIGMA */

   setEapTtlsResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_EAPTTLS_RESP_TLV, 4, (BYTE *)setEapTtlsResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

/*
 * wfaStaSetEapSIM():
 *   This is to set
 *   1. ssid
 *   2. user name
 *   3. passwd
 *   4. encrypType - tkip or aes-ccmp
 *   5. keyMangementType - wpa or wpa2
 */
int wfaStaSetEapSIM(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapSIM_t *setSIM = (caStaSetEapSIM_t *)caCmdBuf;
   char *ifname = setSIM->intf;
   dutCmdResponse_t *setEapSimResp = &gGenericResp;

#ifdef WFA_NEW_CLI_FORMAT
   sprintf(gCmdStr, "wfa_set_eapsim %s %s %s %s", ifname, setSIM->ssid, setSIM->username, setSIM->encrptype);
   system(gCmdStr);
#else

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s disable_network 0", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 ssid '\"%s\"'", ifname, setSIM->ssid);
   system(gCmdStr);


   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 identity '\"%s\"'", ifname, setSIM->username);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 pairwise '\"%s\"'", ifname, setSIM->encrptype);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 eap SIM", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 proto WPA", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s enable_network 0", ifname);
   system(gCmdStr);

   if(strcasecmp(setSIM->keyMgmtType, "wpa2-sha256") == 0)
   {
      sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 key_mgmt WPA-SHA256", ifname);
   }
   else if(strcasecmp(setSIM->keyMgmtType, "wpa2-eap") == 0)
   {
      sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   }
   else if(strcasecmp(setSIM->keyMgmtType, "wpa2-ft") == 0)
   {
      sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 key_mgmt WPA-FT", ifname);
   }
   else if(strcasecmp(setSIM->keyMgmtType, "wpa") == 0)
   {
      sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   }
   else if(strcasecmp(setSIM->keyMgmtType, "wpa2") == 0)
   {
      // take all and device to pick one which is supported.
   }
   else
   {
      // ??
   }
   system(gCmdStr);

#endif

   setEapSimResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_EAPSIM_RESP_TLV, 4, (BYTE *)setEapSimResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

/*
 * wfaStaSetPEAP()
 *   This is to set
 *   1. ssid
 *   2. user name
 *   3. passwd
 *   4. encryType - tkip or aes-ccmp
 *   5. keyMgmtType - wpa or wpa2
 *   6. trustedRootCA
 *   7. innerEAP
 *   8. peapVersion
 */
int wfaStaSetPEAP(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapPEAP_t *setPEAP = (caStaSetEapPEAP_t *)caCmdBuf;
   char *ifname = setPEAP->intf;
   dutCmdResponse_t *setPeapResp = &gGenericResp;

#ifdef WFA_NEW_CLI_FORMAT
   sprintf(gCmdStr, "wfa_set_peap %s %s %s %s %s %s %i %s", ifname, setPEAP->ssid, setPEAP->username,
                                                          setPEAP->passwd, setPEAP->trustedRootCA,
							  setPEAP->encrptype, setPEAP->peapVersion,
							  setPEAP->innerEAP);
   system(gCmdStr);
#else

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s disable_network 0", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 ssid '\"%s\"'", ifname, setPEAP->ssid);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 eap PEAP", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 anonymous_identity '\"anonymous\"' ", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 identity '\"%s\"'", ifname, setPEAP->username);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 password '\"%s\"'", ifname, setPEAP->passwd);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 ca_cert '\"%s/%s\"'", ifname, CERTIFICATES_PATH, setPEAP->trustedRootCA);
   system(gCmdStr);

   /* if this not set, default to set support all */
   //sprintf(gCmdStr, "wpa_cli -i %s set_network 0 pairwise '\"%s\"'", ifname, setPEAP->encrptype);
   //system(gCmdStr);

   if(strcasecmp(setPEAP->keyMgmtType, "wpa2-sha256") == 0)
   {
      sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 key_mgmt WPA-SHA256", ifname);
   }
   else if(strcasecmp(setPEAP->keyMgmtType, "wpa2-eap") == 0)
   {
      sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   }
   else if(strcasecmp(setPEAP->keyMgmtType, "wpa2-ft") == 0)
   {
      sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 key_mgmt WPA-FT", ifname);
   }
   else if(strcasecmp(setPEAP->keyMgmtType, "wpa") == 0)
   {
      sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   }
   else if(strcasecmp(setPEAP->keyMgmtType, "wpa2") == 0)
   {
      // take all and device to pick one which is supported.
   }
   else
   {
      // ??
   }
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 phase1 '\"peaplabel=%i\"'", ifname, setPEAP->peapVersion);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 phase2 '\"auth=%s\"'", ifname, setPEAP->innerEAP);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s enable_network 0", ifname);
   system(gCmdStr);
#endif

   setPeapResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PEAP_RESP_TLV, 4, (BYTE *)setPeapResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}


#if !defined (MTK_P2P_SUPPLICANT)

/*
 * wfaStaSetUAPSD()
 *    This is to set
 *    1. acBE
 *    2. acBK
 *    3. acVI
 *    4. acVO
 */
int wfaStaSetUAPSD(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *setUAPSDResp = &gGenericResp;
#if 0 /* used for only one specific device, need to update to reflect yours */
   caStaSetUAPSD_t *setUAPSD = (caStaSetUAPSD_t *)caCmdBuf;
   char *ifname = setUAPSD->intf;
   char tmpStr[10];
   char line[100];
   char *pathl="/etc/Wireless/RT61STA";
   BYTE acBE=1;
   BYTE acBK=1;
   BYTE acVO=1;
   BYTE acVI=1;
   BYTE APSDCapable;
   FILE *pipe;

   /*
    * A series of setting need to be done before doing WMM-PS
    * Additional steps of configuration may be needed.
    */

   /*
    * bring down the interface
    */
   sprintf(gCmdStr, "ifconfig %s down",ifname);
   system(gCmdStr);
   /*
    * Unload the Driver
    */
   sprintf(gCmdStr, "rmmod rt61");
   system(gCmdStr);
#ifndef WFA_WMM_AC
   if(setUAPSD->acBE != 1)
     acBE=setUAPSD->acBE = 0;
   if(setUAPSD->acBK != 1)
     acBK=setUAPSD->acBK = 0;
   if(setUAPSD->acVO != 1)
     acVO=setUAPSD->acVO = 0;
   if(setUAPSD->acVI != 1)
     acVI=setUAPSD->acVI = 0;
#else
     acBE=setUAPSD->acBE;
     acBK=setUAPSD->acBK;
     acVO=setUAPSD->acVO;
     acVI=setUAPSD->acVI;
#endif

   APSDCapable = acBE||acBK||acVO||acVI;
   /*
    * set other AC parameters
    */

   sprintf(tmpStr,"%d;%d;%d;%d",setUAPSD->acBE,setUAPSD->acBK,setUAPSD->acVI,setUAPSD->acVO);
   sprintf(gCmdStr, "sed -e \"s/APSDCapable=.*/APSDCapable=%d/g\" -e \"s/APSDAC=.*/APSDAC=%s/g\" %s/rt61sta.dat >/tmp/wfa_tmp",APSDCapable,tmpStr,pathl);
   system(gCmdStr);

   sprintf(gCmdStr, "mv /tmp/wfa_tmp %s/rt61sta.dat",pathl);
   system(gCmdStr);
  pipe = popen("uname -r", "r");
  /* Read into line the output of uname*/
       fscanf(pipe,"%s",line);
       pclose(pipe);

   /*
    * load the Driver
    */
   sprintf(gCmdStr, "insmod /lib/modules/%s/extra/rt61.ko",line);
   system(gCmdStr);

   sprintf(gCmdStr, "ifconfig %s up",ifname);
   system(gCmdStr);
#endif

   setUAPSDResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_UAPSD_RESP_TLV, 4, (BYTE *)setUAPSDResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;
   return WFA_SUCCESS;
}

#else //MTK_P2P_SUPPLICANT

/*
 * wfaStaSetUAPSD()
 *    This is to set
 *    1. acBE
 *    2. acBK
 *    3. acVI
 *    4. acVO
 */
int wfaStaSetUAPSD(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetUAPSD_t *setUAPSD = (caStaSetUAPSD_t *)caCmdBuf;
   caStaSetUAPSD_t *c = setUAPSD;
   char *ifname = setUAPSD->intf;
   dutCmdResponse_t *setUAPSDResp = &gGenericResp;


   MTK_P2P_CMD("p2p_set_uapsd %u %u %u %u %u \n",
				c->maxSPLength, c->acBE, c->acBK, c->acVI, c->acVO);

   setUAPSDResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_UAPSD_RESP_TLV, 4, (BYTE *)setUAPSDResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}
#endif //MTK_P2P_SUPPLICANT
int wfaDeviceGetInfo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *dutCmd = (dutCommand_t *)caCmdBuf;
   caDevInfo_t *devInfo = &dutCmd->cmdsu.dev;
   dutCmdResponse_t *infoResp = &gGenericResp;
   /*a vendor can fill in the proper info or anything non-disclosure */
   
   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __func__);
   
#if defined MTK_HS20_SIGMA
	caDeviceGetInfoResp_t dinfo = {"MediaTek Inc.", "MT7668", "III-II-VI-IX"};

	/*{
		FILE *tmpfile = NULL;
		char string[32];
		char *tmpfilename = "/mnt/asec/dev_info";

		sprintf(gCmdStr, "getprop | grep ro.product.device | cut -f2 -d ' ' | tr -d '\[\]' > %s \n", tmpfilename);
   		system(gCmdStr);

		tmpfile = fopen(tmpfilename, "r+");
		if ((NULL == tmpfile) || (fscanf(tmpfile, "%s", string) == EOF)) {
			printf("fail: %s \n", tmpfilename);
			infoResp->status = STATUS_ERROR;
			wfaEncodeTLV(WFA_DEVICE_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return WFA_FAILURE;
		}

		DPRINT_INFO(WFA_OUT, "[%s] The Device model is : %s!\n", __func__, string);

		strcpy(dinfo.model, string);
		fclose(tmpfile);
	}

	memcpy(&infoResp->cmdru.devInfo, &dinfo, sizeof(caDeviceGetInfoResp_t));*/

#elif defined MTK_P2P_SIGMA
    caDeviceGetInfoResp_t dinfo = {"MTK", "mt6620", WFA_SYSTEM_VER};
#elif defined MTK_AC_SIGMA
    caDeviceGetInfoResp_t dinfo = {"MediaTek Inc.", "MT66xx", WFA_SYSTEM_VER" "WFA_DUT_VER, ""};
    //MTK_EXEC_SHELL_CMD("getprop ro.product.device");
    //wSTRNCPY(dinfo.model, gShellCmdResult, sizeof(dinfo.model));

    //MTK_EXEC_SHELL_CMD("getprop persist.mtk.wcn.combo.chipid");
    /* chip id is prefix with 0x, skip it */
    //wSTRNCPY(&dinfo.firmware[2], gShellCmdResult+2, sizeof(dinfo.firmware)-2);
    //DPRINT_INFO(WFA_OUT, "model=%s, firmware=%s\n", dinfo.model, gShellCmdResult+2);
#else
   caDeviceGetInfoResp_t dinfo = {"WFA Lab", "DemoUnit", WFA_SYSTEM_VER};
#endif

   infoResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_DEVICE_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   return WFA_SUCCESS;
error:
	printf("fail\n");
	infoResp->status = STATUS_ERROR;
    wfaEncodeTLV(WFA_DEVICE_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
    return WFA_FAILURE;

}

/*
 * This funciton is to retrieve a list of interfaces and return
 * the list back to Agent control.
 * ********************************************************************
 * Note: We intend to make this WLAN interface name as a hardcode name.
 * Therefore, for a particular device, you should know and change the name
 * for that device while doing porting. The MACRO "WFA_STAUT_IF" is defined in
 * the file "inc/wfa_ca.h". If the device OS is not linux-like, this most
 * likely is hardcoded just for CAPI command responses.
 * *******************************************************************
 *
 */
int wfaDeviceListIF(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *infoResp = &gGenericResp;
   dutCommand_t *ifList = (dutCommand_t *)caCmdBuf;
   caDeviceListIFResp_t *ifListResp = &infoResp->cmdru.ifList;

   DPRINT_INFO(WFA_OUT, "Entering wfaDeviceListIF ...\n");

   switch(ifList->cmdsu.iftype)
   {
      case IF_80211:
      infoResp->status = STATUS_COMPLETE;
      ifListResp->iftype = IF_80211;
      strcpy(ifListResp->ifs[0], WFA_STAUT_IF);
      strcpy(ifListResp->ifs[1], "NULL");
      strcpy(ifListResp->ifs[2], "NULL");
      break;
      case IF_ETH:
      infoResp->status = STATUS_COMPLETE;
      ifListResp->iftype = IF_ETH;
      strcpy(ifListResp->ifs[0], "eth0");
      strcpy(ifListResp->ifs[1], "NULL");
      strcpy(ifListResp->ifs[2], "NULL");
      break;
      default:
      {
         infoResp->status = STATUS_ERROR;
         wfaEncodeTLV(WFA_DEVICE_LIST_IF_RESP_TLV, 4, (BYTE *)infoResp, respBuf);
         *respLen = WFA_TLV_HDR_LEN + 4;

         return WFA_SUCCESS;
      }
   }

   wfaEncodeTLV(WFA_DEVICE_LIST_IF_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   return WFA_SUCCESS;
}

int wfaStaDebugSet(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *debugResp = &gGenericResp;
   dutCommand_t *debugSet = (dutCommand_t *)caCmdBuf;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaDebugSet ...\n");

   if(debugSet->cmdsu.dbg.state == 1) /* enable */
      wfa_defined_debug |= debugSet->cmdsu.dbg.level;
   else
      wfa_defined_debug = (~debugSet->cmdsu.dbg.level & wfa_defined_debug);

   debugResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)debugResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);


   return WFA_SUCCESS;
}


/*
 *   wfaStaGetBSSID():
 *     This function is to retrieve BSSID of a specific wireless I/F.
 */
int wfaStaGetBSSID(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   char string[64];
   char *str;
   FILE *tmpfd;
   dutCmdResponse_t *bssidResp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaGetBSSID ...\n");
   /* retrieve the BSSID */
#if (!defined MTK_P2P_SUPPLICANT) && (!defined MTK_HS20_SIGMA) && (!defined MTK_AC_SIGMA)
   sprintf(gCmdStr, "wpa_cli -iwlan0 -p/tmp/wpa_supplicant status > "TMP_ASEC_PATH"bssid.txt");
#else
   sprintf(gCmdStr, "wpa_cli -iwlan0 -p/tmp/wpa_supplicant status > "TMP_ASEC_PATH"bssid.txt");
#endif

   system(gCmdStr);

#if (!defined MTK_P2P_SUPPLICANT) && (!defined MTK_HS20_SIGMA) && (!defined MTK_AC_SIGMA)
   tmpfd = fopen(TMP_ASEC_PATH"bssid.txt", "r+");
#else
   tmpfd = fopen(TMP_ASEC_PATH"bssid.txt", "r+");
#endif
   if(tmpfd == NULL)
   {
      bssidResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_GET_BSSID_RESP_TLV, 4, (BYTE *)bssidResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return WFA_FAILURE;
   }

   for(;;)
   {
      if(fscanf(tmpfd, "%s", string) == EOF)
      {
         bssidResp->status = STATUS_COMPLETE;
         strcpy(bssidResp->cmdru.bssid, "00:00:00:00:00:00");
         break;
      }

      if(strncmp(string, "bssid", 5) == 0)
      {
         str = strtok(string, "=");
         str = strtok(NULL, "=");
         if(str != NULL)
         {
            strcpy(bssidResp->cmdru.bssid, str);
            bssidResp->status = STATUS_COMPLETE;
            break;
         }
      }
   }

   wfaEncodeTLV(WFA_STA_GET_BSSID_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)bssidResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   fclose(tmpfd);
   return WFA_SUCCESS;
}

/*
 * wfaStaSetIBSS()
 *    This is to set
 *    1. ssid
 *    2. channel
 *    3. encrypType - none or wep
 *    optional
 *    4. key1
 *    5. key2
 *    6. key3
 *    7. key4
 *    8. activeIndex - 1, 2, 3, or 4
 */
int wfaStaSetIBSS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetIBSS_t *setIBSS = (caStaSetIBSS_t *)caCmdBuf;
   dutCmdResponse_t *setIbssResp = &gGenericResp;
   int i;

   /*
    * disable the network first
    */
   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s disable_network 0", setIBSS->intf);
   system(gCmdStr);

   /*
    * set SSID
    */
   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 ssid '\"%s\"'", setIBSS->intf, setIBSS->ssid);
   system(gCmdStr);

   /*
    * Set channel for IBSS
    */
   sprintf(gCmdStr, "iwconfig %s channel %i", setIBSS->intf, setIBSS->channel);
   system(gCmdStr);

   /*
    * Tell the supplicant for IBSS mode (1)
    */
   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 mode 1", setIBSS->intf);
   system(gCmdStr);

   /*
    * set Key management to NONE (NO WPA) for plaintext or WEP
    */
   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 key_mgmt NONE", setIBSS->intf);
   system(gCmdStr);

   if(setIBSS->encpType == 1)
   {
      for(i=0; i<4; i++)
      {
         if(strlen(setIBSS->keys[i]) ==5 || strlen(setIBSS->keys[i]) == 13)
         {
             sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 wep_key%i \"%s\"",
                setIBSS->intf, i, setIBSS->keys[i]);
             system(gCmdStr);
         }
      }

      i = setIBSS->activeKeyIdx;
      if(strlen(setIBSS->keys[i]) ==5 || strlen(setIBSS->keys[i]) == 13)
      {
         sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 wep_tx_keyidx %i",
            setIBSS->intf, setIBSS->activeKeyIdx);
         system(gCmdStr);
      }
   }

   sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s enable_network 0", setIBSS->intf);
   system(gCmdStr);

   setIbssResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_IBSS_RESP_TLV, 4, (BYTE *)setIbssResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

/*
 *  wfaSetMode():
 *  The function is to set the wireless interface with a given mode (possible
 *  adhoc)
 *  Input parameters:
 *    1. I/F
 *    2. ssid
 *    3. mode adhoc or managed
 *    4. encType
 *    5. channel
 *    6. key(s)
 *    7. active  key
 */
int wfaStaSetMode(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetMode_t *setmode = (caStaSetMode_t *)caCmdBuf;
   dutCmdResponse_t *SetModeResp = &gGenericResp;
   int i;

   /*
    * bring down the interface
    */
   sprintf(gCmdStr, "ifconfig %s down",setmode->intf);
   system(gCmdStr);

   /*
    * distroy the interface
    */
   sprintf(gCmdStr, "wlanconfig %s destroy",setmode->intf);
   system(gCmdStr);


   /*
    * re-create the interface with the given mode
    */
   if(setmode->mode == 1)
        sprintf(gCmdStr, "wlanconfig %s create wlandev wifi0 wlanmode adhoc",setmode->intf);
   else
        sprintf(gCmdStr, "wlanconfig %s create wlandev wifi0 wlanmode managed",setmode->intf);

   system(gCmdStr);
   if(setmode->encpType == ENCRYPT_WEP)
    {
      int j = setmode->activeKeyIdx;
      for(i=0; i<4; i++)
      {
         if(setmode->keys[i][0] != '\0')
         {
             sprintf(gCmdStr, "iwconfig  %s key  s:%s",
                   setmode->intf, setmode->keys[i]);
             system(gCmdStr);
         }
      /* set active key */
         if(setmode->keys[j][0] != '\0')
             sprintf(gCmdStr, "iwconfig  %s key  s:%s",
                   setmode->intf, setmode->keys[j]);
         system(gCmdStr);
      }

    }
   /*
    * Set channel for IBSS
    */
    if(setmode->channel)
    {
      sprintf(gCmdStr, "iwconfig %s channel %i", setmode->intf, setmode->channel);
      system(gCmdStr);
    }


   /*
    * set SSID
    */
   sprintf(gCmdStr, "iwconfig %s essid %s", setmode->intf, setmode->ssid);
   system(gCmdStr);

   /*
    * bring up the interface
    */
   sprintf(gCmdStr, "ifconfig %s up",setmode->intf);
   system(gCmdStr);

   SetModeResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_MODE_RESP_TLV, 4, (BYTE *)SetModeResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

int wfaStaSetPwrSave(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetPwrSave_t *setps = (caStaSetPwrSave_t *)caCmdBuf;
   dutCmdResponse_t *SetPSResp = &gGenericResp;

#if !defined (MTK_P2P_SUPPLICANT)
   sprintf(gCmdStr, "iwconfig %s power %s", setps->intf, setps->mode);
   system(gCmdStr);
#else
   enum MTK_PWR_TOK {OFF=0, PSPOLL=1, FAST=2, PSNONPOLL=3} pwr_set = OFF;

   if (strncmp("off", setps->mode, 3) == 0)
	   pwr_set = OFF;
   else if (strncmp("PSPoll", setps->mode, 6) == 0)
	   pwr_set = PSPOLL;
   else if (strncmp("Fast", setps->mode, 4) == 0)
	   pwr_set = PSPOLL;
   else if (strncmp("PSNonPoll", setps->mode, 9) == 0)    /* Buffer not enough issue. */
	   pwr_set = PSNONPOLL;

   MTK_P2P_CMD("p2p_set_power_save %d \n", pwr_set);
#endif //MTK_P2P_SUPPLICANT

   SetPSResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PWRSAVE_RESP_TLV, 4, (BYTE *)SetPSResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

int wfaStaUpload(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaUpload_t *upload = &((dutCommand_t *)caCmdBuf)->cmdsu.upload;
   dutCmdResponse_t *upLoadResp = &gGenericResp;
   caStaUploadResp_t *upld = &upLoadResp->cmdru.uld;

   if(upload->type == WFA_UPLOAD_VHSO_RPT)
   {
       int rbytes;
       /*
        * if asked for the first packet, always to open the file
        */
       if(upload->next == 1)
       {
          if(e2efp != NULL)
          {
              fclose(e2efp);
              e2efp = NULL;
          }

          e2efp = fopen(e2eResults, "r");
       }

       if(e2efp == NULL)
       {
           upLoadResp->status = STATUS_ERROR;
           wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, 4, (BYTE *)upLoadResp, respBuf);
           *respLen = WFA_TLV_HDR_LEN + 4;
           return WFA_FAILURE;
       }

       rbytes = fread(upld->bytes, 1, 256, e2efp);

       if(rbytes < 256)
       {
           /*
            * this means no more bytes after this read
            */
           upld->seqnum = 0;
           fclose(e2efp);
           e2efp=NULL;
       }
       else
       {
           upld->seqnum = upload->next;
       }

       upld->nbytes = rbytes;

       upLoadResp->status = STATUS_COMPLETE;
       wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)upLoadResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
   }
   else
   {
       upLoadResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, 4, (BYTE *)upLoadResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;
   }

   return WFA_SUCCESS;
}
/*
 * wfaStaSetWMM()
 *  TO be ported on a specific plaform for the DUT
 *  This is to set the WMM related parameters at the DUT.
 *  Currently the function is used for GROUPS WMM-AC and WMM general configuration for setting RTS Threshhold, Fragmentation threshold and wmm (ON/OFF)
 *  It is expected that this function will set all the WMM related parametrs for a particular GROUP .
 */
int wfaStaSetWMM(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
#ifdef WFA_WMM_AC
    caStaSetWMM_t *setwmm = (caStaSetWMM_t *)caCmdBuf;
    char *ifname = setwmm->intf;
    dutCmdResponse_t *setwmmResp = &gGenericResp;
    //IEEEtypes_WMM_TSPEC_t tspec;

    switch(setwmm->group)
    {
    case GROUP_WMMAC:
	if (setwmm->send_trig)
	{
	    int Sockfd;
	    struct sockaddr_in psToAddr;
	    unsigned int TxMsg[512];

            Sockfd = wfaCreateUDPSock(setwmm->dipaddr, 12346);
	    memset(&psToAddr, 0, sizeof(psToAddr));
	    psToAddr.sin_family = AF_INET;
	    psToAddr.sin_addr.s_addr = inet_addr(setwmm->dipaddr);
	    psToAddr.sin_port = htons(12346);


	    switch (setwmm->trig_ac)
	    {
	    case WMMAC_AC_VO:
	        wfaTGSetPrio(Sockfd, 7);
	        create_apts_msg(APTS_CK_VO, TxMsg, 0);
	        printf("\r\nSending AC_VO trigger packet\n");
	        break;

	    case WMMAC_AC_VI:
	        wfaTGSetPrio(Sockfd, 5);
	        create_apts_msg(APTS_CK_VI, TxMsg, 0);
	        printf("\r\nSending AC_VI trigger packet\n");
	        break;

	    case WMMAC_AC_BK:
	        wfaTGSetPrio(Sockfd, 2);
	        create_apts_msg(APTS_CK_BK, TxMsg, 0);
	        printf("\r\nSending AC_BK trigger packet\n");
	        break;

	    default:
            case WMMAC_AC_BE:
	        wfaTGSetPrio(Sockfd, 0);
	        create_apts_msg(APTS_CK_BE, TxMsg, 0);
	        printf("\r\nSending AC_BE trigger packet\n");
	        break;
            }

	    sendto(Sockfd, TxMsg, 256, 0, (struct sockaddr *)&psToAddr,
	           sizeof(struct sockaddr));
	    close(Sockfd);
	    usleep(1000000);
	}
	else if (setwmm->action == WMMAC_ADDTS)
        {
	    //wmmtspec_t* pCmdTspec = &(setwmm->actions.addts.tspec);
            printf("ADDTS AC PARAMS: dialog id: %d, TID: %d, "
	           "DIRECTION: %d, PSB: %d, UP: %d, INFOACK: %d BURST SIZE DEF: %d"
		   "Fixed %d, MSDU Size: %d, Max MSDU Size %d, "
		   "MIN SERVICE INTERVAL: %d, MAX SERVICE INTERVAL: %d, "
		   "INACTIVITY: %d, SUSPENSION %d, SERVICE START TIME: %d, "
		   "MIN DATARATE: %d, MEAN DATA RATE: %d, PEAK DATA RATE: %d, "
	           "BURSTSIZE or MSDU Aggreg: %d, DELAY BOUND: %d, PHYRATE: %d, SPLUSBW: %f, "
		   "MEDIUM TIME: %d, ACCESSCAT: %d\n",
		   setwmm->actions.addts.dialog_token,
		   setwmm->actions.addts.tspec.tsinfo.TID,
		   setwmm->actions.addts.tspec.tsinfo.direction,
		   setwmm->actions.addts.tspec.tsinfo.PSB,
		   setwmm->actions.addts.tspec.tsinfo.UP,
		   setwmm->actions.addts.tspec.tsinfo.infoAck,
		   setwmm->actions.addts.tspec.tsinfo.bstSzDef,
		   setwmm->actions.addts.tspec.Fixed,
		   setwmm->actions.addts.tspec.size,
		   setwmm->actions.addts.tspec.maxsize,
		   setwmm->actions.addts.tspec.min_srvc,
		   setwmm->actions.addts.tspec.max_srvc,
		   setwmm->actions.addts.tspec.inactivity,
		   setwmm->actions.addts.tspec.suspension,
		   setwmm->actions.addts.tspec.srvc_strt_tim,
		   setwmm->actions.addts.tspec.mindatarate,
		   setwmm->actions.addts.tspec.meandatarate,
		   setwmm->actions.addts.tspec.peakdatarate,
		   setwmm->actions.addts.tspec.burstsize,
		   setwmm->actions.addts.tspec.delaybound,
		   setwmm->actions.addts.tspec.PHYrate,
		   setwmm->actions.addts.tspec.sba,
		   setwmm->actions.addts.tspec.medium_time,
		   setwmm->actions.addts.accesscat);

            // you should set your tspec here.

            system(gCmdStr);
        }
        else if (setwmm->action == WMMAC_DELTS)
	{
             // send del tspec
        }

        setwmmResp->status = STATUS_COMPLETE;
        break;

    case GROUP_WMMCONF:
        sprintf(gCmdStr, "iwconfig %s rts %d",
                ifname,setwmm->actions.config.rts_thr);

        system(gCmdStr);
        sprintf(gCmdStr, "iwconfig %s frag %d",
                ifname,setwmm->actions.config.frag_thr);

        system(gCmdStr);
        sprintf(gCmdStr, "iwpriv %s wmmcfg %d",
                ifname, setwmm->actions.config.wmm);

        system(gCmdStr);
        setwmmResp->status = STATUS_COMPLETE;
        break;

    default:
        DPRINT_ERR(WFA_ERR, "The group %d is not supported\n",setwmm->group);
        setwmmResp->status = STATUS_ERROR;
        break;

    }

    wfaEncodeTLV(WFA_STA_SET_WMM_RESP_TLV, 4, (BYTE *)setwmmResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
#endif

    return WFA_SUCCESS;
}

int wfaStaSendNeigReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   //dutCommand_t *sendNeigReq = (dutCommand_t *)caCmdBuf;
   dutCmdResponse_t *sendNeigReqResp = &gGenericResp;

   /*
    *  run your device to send NEIGREQ
    */

   sendNeigReqResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SEND_NEIGREQ_RESP_TLV, 4, (BYTE *)sendNeigReqResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

int wfaStaSetEapFAST(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetEapFAST_t *setFAST= (caStaSetEapFAST_t *)caCmdBuf;
    char *ifname = setFAST->intf;
    dutCmdResponse_t *setEapFastResp = &gGenericResp;

#ifdef WFA_NEW_CLI_FORMAT
    sprintf(gCmdStr, "wfa_set_eapfast %s %s %s %s %s %s", ifname, setFAST->ssid, setFAST->username,
                                                          setFAST->passwd, setFAST->pacFileName,
                                                          setFAST->innerEAP);
    system(gCmdStr);
#else

    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s disable_network 0", ifname);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 ssid '\"%s\"'", ifname, setFAST->ssid);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 identity '\"%s\"'", ifname, setFAST->username);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 password '\"%s\"'", ifname, setFAST->passwd);
    system(gCmdStr);

    if(strcasecmp(setFAST->keyMgmtType, "wpa2-sha256") == 0)
    {
    }
    else if(strcasecmp(setFAST->keyMgmtType, "wpa2-eap") == 0)
    {
    }
    else if(strcasecmp(setFAST->keyMgmtType, "wpa2-ft") == 0)
    {

    }
    else if(strcasecmp(setFAST->keyMgmtType, "wpa") == 0)
    {
       sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 key_mgmt WPA-EAP", ifname);
    }
    else if(strcasecmp(setFAST->keyMgmtType, "wpa2") == 0)
    {
      // take all and device to pick one which is supported.
    }
    else
    {
      // ??
    }
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 eap FAST", ifname);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 pac_file '\"%s/%s\"'", ifname, CERTIFICATES_PATH,     setFAST->pacFileName);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 anonymous_identity '\"anonymous\"'", ifname);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 phase1 '\"fast_provisioning=1\"'", ifname);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 phase2 '\"auth=%s\"'", ifname,setFAST->innerEAP);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s enable_network 0", ifname);
    system(gCmdStr);
#endif

    setEapFastResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_EAPFAST_RESP_TLV, 4, (BYTE *)setEapFastResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}

int wfaStaSetEapAKA(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetEapAKA_t *setAKA= (caStaSetEapAKA_t *)caCmdBuf;
    char *ifname = setAKA->intf;
    dutCmdResponse_t *setEapAkaResp = &gGenericResp;

#ifdef WFA_NEW_CLI_FORMAT
    sprintf(gCmdStr, "wfa_set_eapaka %s %s %s %s", ifname, setAKA->ssid, setAKA->username, setAKA->passwd);
    system(gCmdStr);
#else

    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s disable_network 0", ifname);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 ssid '\"%s\"'", ifname, setAKA->ssid);
    system(gCmdStr);

    if(strcasecmp(setAKA->keyMgmtType, "wpa2-sha256") == 0)
    {
    }
    else if(strcasecmp(setAKA->keyMgmtType, "wpa2-eap") == 0)
    {
    }
    else if(strcasecmp(setAKA->keyMgmtType, "wpa2-ft") == 0)
    {

    }
    else if(strcasecmp(setAKA->keyMgmtType, "wpa") == 0)
    {
       sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 key_mgmt WPA-EAP", ifname);
    }
    else if(strcasecmp(setAKA->keyMgmtType, "wpa2") == 0)
    {
      // take all and device to pick one which is supported.
    }
    else
    {
       // ??
    }
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 proto WPA2", ifname);
    system(gCmdStr);
    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 proto CCMP", ifname);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 eap AKA", ifname);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 phase1 \"result_ind=1\"", ifname);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 identity '\"%s\"'", ifname, setAKA->username);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s set_network 0 password '\"%s\"'", ifname, setAKA->passwd);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -p/tmp/wpa_supplicant -i %s enable_network 0", ifname);
    system(gCmdStr);
#endif

    setEapAkaResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_EAPAKA_RESP_TLV, 4, (BYTE *)setEapAkaResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

int wfaStaSetSystime(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetSystime_t *systime = (caStaSetSystime_t *)caCmdBuf;
   dutCmdResponse_t *setSystimeResp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetSystime ...\n");

   sprintf(gCmdStr, "date %d-%d-%d",systime->month,systime->date,systime->year);
   system(gCmdStr);

   sprintf(gCmdStr, "time %d:%d:%d", systime->hours,systime->minutes,systime->seconds);
   system(gCmdStr);

   setSystimeResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_SYSTIME_RESP_TLV, 4, (BYTE *)setSystimeResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

#ifdef WFA_STA_TB
int wfaStaPresetParams(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *PresetParamsResp = &gGenericResp;
   caStaPresetParameters_t *presetParams = (caStaPresetParameters_t *)caCmdBuf;
   //int ret;
   //char *intfname = presetParams->intf;
   BYTE presetDone = 1;
   int st = 0;

   DPRINT_INFO(WFA_OUT, "Inside wfaStaPresetParameters function ...\n");

#if defined MTK_HS20_SIGMA // R2
	if(strcasecmp(presetParams->prog, "HS2-R2") == 0)
	{
		if(presetParams->ppsmo > 0){
			DPRINT_INFO(WFA_OUT, "%s, PPSMO %d ...\n", __func__, presetParams->ppsmo);	
			MTK_HS20_CMD("-i %s sta_install_ppsmo %d\n",
				presetParams->intf,
				presetParams->ppsmo);
		}

		if(strcasecmp(presetParams->filetype, "PPSMO") == 0){
			DPRINT_INFO(WFA_OUT, "%s, Try to install PPSMO ...\n", __func__);

			if(strcasecmp(presetParams->filepath, "VendorSpecific") == 0){
				DPRINT_INFO(WFA_OUT, "%s, Install (%s) from Local_Database ...\n", __func__, presetParams->filename);	
				MTK_HS20_CMD("-i %s sta_install_ppsmo %s\n",
					presetParams->intf,
					presetParams->filename);
			}else {
				DPRINT_INFO(WFA_OUT, "%s, Install (%s) from %s ...\n", __func__, presetParams->filename, presetParams->filepath);
				MTK_HS20_CMD("-i %s sta_install_webppsmo %s\n",
					presetParams->intf,
					presetParams->filename);
			}
		}

		if(strcasecmp(presetParams->filetype, "CERT") == 0){
			DPRINT_INFO(WFA_OUT, "%s, CERT FILENAME %s ...\n", __func__, presetParams->filename);	
			// Todo install CERT
		}

		switch(presetParams->provprot){
			case eOMADM:
				DPRINT_INFO(WFA_OUT, "%s, Provisioning Protocol (OMADM) ...\n", __func__);
				MTK_HS20_CMD("-i %s set_prov_protocol OMADM\n",
					presetParams->intf);
				break;
				
			case eSOAP:
				DPRINT_INFO(WFA_OUT, "%s, Provisioning Protocol (SOAP) ...\n", __func__);
				MTK_HS20_CMD("-i %s set_prov_protocol SOAP\n",
					presetParams->intf);
				break;
				
			default:
				DPRINT_INFO(WFA_OUT, "%s, Provisioning Protocol (%d) !!! \n", __func__, presetParams->provprot);
				//PresetParamsResp->status = STATUS_ERROR;
				//wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_RESP_TLV, 4, (BYTE *)PresetParamsResp, respBuf);
				//*respLen = WFA_TLV_HDR_LEN + 4;
				//return WFA_FAILURE;
		}

		if(presetParams->qosmap == 0){
			MTK_HS20_CMD("-i %s set_qos_map %d\n",
				presetParams->intf,
				presetParams->qosmap);
		}
		else {
			MTK_HS20_CMD("-i %s set_qos_map 1\n",
				presetParams->intf);
		}

		if(presetParams->certname[0] != '\0'){
			DPRINT_INFO(WFA_OUT, "%s, Install WEB ROOT_CA(%s) ...\n", __func__, presetParams->certname);
			MTK_HS20_CMD("-i %s sta_install_webcert %s %s\n",
				presetParams->intf,
				presetParams->certname,
				presetParams->certfp);
		}

	}
#endif   

   if(presetParams->wmmFlag)
   {
      st = wfaExecuteCLI(gCmdStr);
      switch(st)
      {
         case 0:
         presetDone = 1;
         break;
         case 1:
         presetDone = 0;
         break;
         case 2:
         presetDone = 0;
         break;
      }
   }

   if(presetParams->modeFlag != 0)
   {
      switch(presetParams->wirelessMode)
      {
         default:
         printf("other mode does not need to support\n");
      }

      //st = wfaExecuteCLI(gCmdStr);
      switch(st)
      {
         case 0:
         presetDone = 1;
         break;
         case 1:
         presetDone = 0;
         case 2:
         presetDone = 0;
         break;
      }
   }


   if(presetParams->psFlag)
   {

      printf("%s\n", gCmdStr);
      system(gCmdStr);
   }

   /************the followings are used for Voice Enterprise **************/
   if(presetParams->ftoa == eEnable)
   {
      // enable Fast BSS Transition Over the Air
   }
   else
   {
      // disable Fast BSS Transition Over the Air

   }

   if(presetParams->ftds == eEnable)
   {
      // enable Fast BSS Transition Over the DS

   }
   else
   {
      // disable Fast BSS Transition Over the DS

   }

   if(presetParams->activescan == eEnable)
   {
      // Enable Active Scan on STA

   }
   else
   {
      // disable Active Scan on STA

   }


   if (presetDone)
   {
      PresetParamsResp->status = STATUS_COMPLETE;
   }
   else
   {
      PresetParamsResp->status = STATUS_INVALID;
   }

   wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_RESP_TLV, 4, (BYTE *)PresetParamsResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

int wfaStaSet11n(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *v11nParamsResp = &gGenericResp;

    v11nParamsResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, 4, (BYTE *)v11nParamsResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    return WFA_SUCCESS;
}
int wfaStaSetWireless(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *dutCmd = (dutCommand_t *)caCmdBuf;
    caStaSetWireless_t *setWireless = &dutCmd->cmdsu.setWireless;
    dutCmdResponse_t *staWirelessResp = &gGenericResp;
    char *intf = setWireless->intf;

    staWirelessResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_WIRELESS_RESP_TLV, 4, (BYTE *)staWirelessResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    DPRINT_INFO(WFA_OUT, "Inside wfaStaSetWireless function ...\n");

#if 0
    if (setWireless->rts_force == WFA_ENABLED) {
	sprintf(gCmdStr, "iwpriv %s driver \"set_chip forceRtsEn 1\" ", intf);
	printf(" %s\n", gCmdStr);
	system(gCmdStr);
    }
#endif

    if (setWireless->bw_sgnl== WFA_ENABLED) {
	sprintf(gCmdStr, "iwpriv %s driver \"set_cfg SigTaRts 1\" ", intf);
	printf(" %s\n", gCmdStr);
	system(gCmdStr);
	 //forceCca (band0 sec40) disable
	sprintf(gCmdStr, "iwpriv %s driver \"set_chip forceCca 2 2\" ", intf);
	printf(" %s\n", gCmdStr);
	system(gCmdStr);
	//forceCca (band0 sec20) disable
	sprintf(gCmdStr, "iwpriv %s driver \"set_chip forceCca 1 2\" ", intf);
	printf(" %s\n", gCmdStr);
	system(gCmdStr);
    }
	
    if (setWireless->dyn_bw_sgnl == WFA_ENABLED) {
	sprintf(gCmdStr, "iwpriv %s driver \"set_cfg DynBwRts 1\" ", intf);
	printf(" %s\n", gCmdStr);
	system(gCmdStr);
	sprintf(gCmdStr, "iwpriv %s driver \"set_chip dynBwRts 1\" ", intf);
	printf(" %s\n", gCmdStr);
	system(gCmdStr);
    }
	
    return WFA_SUCCESS;
}

int wfaStaSendADDBA(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staSendADDBAResp = &gGenericResp;

    wfaEncodeTLV(WFA_STA_SET_SEND_ADDBA_RESP_TLV, 4, (BYTE *)staSendADDBAResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    return WFA_SUCCESS;
}

int wfaStaSetRIFS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
        dutCmdResponse_t *staSetRIFSResp = &gGenericResp;

        wfaEncodeTLV(WFA_STA_SET_RIFS_TEST_RESP_TLV, 4, (BYTE *)staSetRIFSResp, respBuf);
        *respLen = WFA_TLV_HDR_LEN + 4;

        return WFA_SUCCESS;

}

int wfaStaSendCoExistMGMT(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staSendMGMTResp = &gGenericResp;

    wfaEncodeTLV(WFA_STA_SEND_COEXIST_MGMT_RESP_TLV, 4, (BYTE *)staSendMGMTResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;

}

int wfaStaCheckSupplicantStatus(void){
	int running = TRUE;

	FILE *tmpfile = NULL;
	char string[128];
	char *tmpfilename = TMP_ASEC_PATH"wpa_supplicant_status";

	system("getprop | grep supplicant | cut -f2 -d ']' | cut -f2 -d '[' > "TMP_ASEC_PATH"wpa_supplicant_status");

	tmpfile = fopen(tmpfilename, "r+");
	if ((NULL == tmpfile) || (NULL == fgets(string, 128, tmpfile))) {
		DPRINT_INFO(WFA_OUT, "fail: %s \n", tmpfilename);
		running = FALSE;
	}

	if(strncmp(string, "running", 6) == 0){
		running = TRUE;
	} else {
		running = FALSE;
	}

        if (tmpfile != NULL)
	    fclose(tmpfile);

	return running;

}

int wfaStaResetDefault(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaResetDefault_t *reset = (caStaResetDefault_t *)caCmdBuf;
   dutCmdResponse_t *ResetResp = &gGenericResp;
   int round;

#if (!defined MTK_P2P_SUPPLICANT) && (!defined MTK_HS20_SIGMA) && (!defined MTK_AC_SIGMA)
   // need to make your own command available for this, here is only an example
   sprintf(gCmdStr, "myresetdefault %s program %s", reset->intf, reset->prog);
   system(gCmdStr);
#elif defined MTK_AC_SIGMA

	DPRINT_INFO(WFA_OUT, "Entering wfaStaResetDefault ...%s\n", reset->prog);

	if(strncmp(reset->prog, "VHT", 3) == 0 
#ifdef	MTK_PMF_SIGMA
           || strncmp(reset->prog, "PMF", 3) == 0
#endif
#ifdef	MTK_TDLS_SIGMA
               || strncmp(reset->prog, "TDLS", 4) == 0
#endif

	){
#if 0
		if(wfaStaCheckSupplicantStatus() == FALSE){	//Wi-Fi off
			system("svc wifi enable");

			for(round = 0; round < 10; round ++){
				if(wfaStaCheckSupplicantStatus() == TRUE){
					break;
				}
				buzz_time(1000000);
			}
		}
#endif

		MTK_AC_CMD("-i %s remove_network all", reset->intf);
		
		MTK_AC_CMD("-i %s save_config", reset->intf);
#if 0		
   		system("svc wifi disable");
		buzz_time(1000000);
   		system("svc wifi enable");

		if(wfaStaCheckSupplicantStatus() == FALSE){
			for(round = 0; round < 10; round ++){
				if(wfaStaCheckSupplicantStatus() == TRUE){
					break;
				}
				buzz_time(1000000);
			}
		}

		system("setprop mediatek.wlan.ac.sigma 1");
#endif

		// Disable framework scan
		//MTK_HS20_CMD("-i %s ap_scan 0 ", reset->intf);
		//buzz_time(1000000);
		//MTK_HS20_CMD("-i %s ap_scan 0 ", reset->intf);
		//buzz_time(1000000);
		//MTK_HS20_CMD("-i %s ap_scan 0 ", reset->intf);
		//buzz_time(1000000);

#if 0
                //forceRtsEn 0               
		sprintf(gCmdStr, "iwpriv %s driver \"set_chip forceRtsEn 0\" ", reset->intf);
		printf(" %s\n", gCmdStr);
		system(gCmdStr);
#endif
		//SigTaRts 0
		sprintf(gCmdStr, "iwpriv %s driver \"set_cfg SigTaRts 0\" ", reset->intf);
		printf(" %s\n", gCmdStr);
		system(gCmdStr);
                //DynBwRts 0
		sprintf(gCmdStr, "iwpriv %s driver \"set_cfg DynBwRts 0\" ", reset->intf);
		printf(" %s\n", gCmdStr);
		system(gCmdStr);

		 //forceCca (band0 sec40) 0
		sprintf(gCmdStr, "iwpriv %s driver \"set_chip forceCca 2 0\" ", reset->intf);
		printf(" %s\n", gCmdStr);
		system(gCmdStr);
		//forceCca (band0 sec20) 0
		sprintf(gCmdStr, "iwpriv %s driver \"set_chip forceCca 1 0\" ", reset->intf);
		printf(" %s\n", gCmdStr);
		system(gCmdStr);

		/*Force to keep full power*/
		sprintf(gCmdStr, "iwpriv %s driver \"set_chip KeepFullPwr 1\" ", reset->intf);
		printf(" %s\n", gCmdStr);
		system(gCmdStr);
		
		fgIsDhcpOn = 0;

		g_ipconfig_isSet = 0;
		memset(&g_ipconfig, 0, sizeof(caStaSetIpConfig_t));

		/* Disable auto connect from supplicant for PMF*/
#ifdef	MTK_PMF_SIGMA
        if (strncmp(reset->prog, "PMF", 3) == 0) {
			MTK_AC_CMD("-i %s sta_autoconnect 0\n", reset->intf);
        }
#endif

	}
	else {
		DPRINT_INFO(WFA_OUT, "Wrong prog parameter !!!\n");

		ResetResp->status = STATUS_INVALID;
		wfaEncodeTLV(WFA_STA_RESET_DEFAULT_RESP_TLV, 4, (BYTE *)ResetResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;

		return WFA_FAILURE;
	}


#elif defined MTK_HS20_SIGMA

	DPRINT_INFO(WFA_OUT, "Entering wfaStaResetDefault ...\n");

	if(strncmp(reset->prog, "HS2", 3) == 0 || strncmp(reset->prog, "HS2-R2", 6) == 0){

		if(wfaStaCheckSupplicantStatus() == FALSE){	//Wi-Fi off
			system("svc wifi enable");

			for(round = 0; round < 10; round ++){
				if(wfaStaCheckSupplicantStatus() == TRUE){
					if(strncmp(reset->prog, "HS2-R2", 6) == 0){
						MTK_HS20_CMD("sta_default_reset\n");
					}
					break;
				}
				buzz_time(1000000);
			}
		}
		else {	// Wi-Fi On
			if(strncmp(reset->prog, "HS2-R2", 6) == 0){
				MTK_HS20_CMD("sta_default_reset\n");
			}
		}
		
		//MTK_HS20_CMD("sigma_hs20_reset \n");
		MTK_HS20_CMD("-i %s remove_network all", reset->intf);
		MTK_HS20_CMD("-i %s remove_cred all", reset->intf);
		
		MTK_HS20_CMD("-i %s save_config", reset->intf);
		
		//MTK_HS20_CMD("-i %s ap_scan 1 ", reset->intf);
		//MTK_HS20_CMD("-i %s scan", reset->intf);
		
		//MTK_HS20_CMD("disconnect \n");
		
   		system("svc wifi disable");
		buzz_time(1000000);
   		system("svc wifi enable");

		if(wfaStaCheckSupplicantStatus() == FALSE){
			for(round = 0; round < 10; round ++){
				if(wfaStaCheckSupplicantStatus() == TRUE){
					break;
				}
				buzz_time(1000000);
			}
		}

		buzz_time(5000000);

		// Disable framework scan
		MTK_HS20_CMD("-i %s ap_scan 0 ", reset->intf);
		buzz_time(1000000);
		MTK_HS20_CMD("-i %s ap_scan 0 ", reset->intf);
		buzz_time(1000000);
		MTK_HS20_CMD("-i %s ap_scan 0 ", reset->intf);
		buzz_time(1000000);

		MTK_HS20_CMD("-i %s set interworking 1 \n", reset->intf);
		MTK_HS20_CMD("-i %s set auto_interworking 0 \n", reset->intf);
		MTK_HS20_CMD("-i %s set hs20 1 \n", reset->intf);
		MTK_HS20_CMD("-i %s save_config", reset->intf);

		//system("setprop mediatek.wlan.hs20.sigma 1");


		fgIsDhcpOn = 0;

		g_ipconfig_isSet = 0;
		memset(&g_ipconfig, 0, sizeof(caStaSetIpConfig_t));

	}
	else {
		DPRINT_INFO(WFA_OUT, "Wrong prog parameter !!!\n");

		ResetResp->status = STATUS_INVALID;
		wfaEncodeTLV(WFA_STA_RESET_DEFAULT_RESP_TLV, 4, (BYTE *)ResetResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;

		return WFA_FAILURE;
	}
#else
	MTK_P2P_CMD("p2p_reset \n");
#endif


   ResetResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_RESET_DEFAULT_RESP_TLV, 4, (BYTE *)ResetResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

#else

int wfaStaTestBedCmd(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staCmdResp = &gGenericResp;

    wfaEncodeTLV(WFA_STA_DISCONNECT_RESP_TLV, 4, (BYTE *)staCmdResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}
#endif

/*
 * This is used to send a frame or action frame
 */
int wfaStaSendFrame(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *cmd = (dutCommand_t *)caCmdBuf;
   /* uncomment it if needed */
   // char *ifname = cmd->intf;
   dutCmdResponse_t *staCmdResp = &gGenericResp;
   caStaSendFrame_t *sf = &cmd->cmdsu.sf;

   /* processing the frame */

   switch(sf->frame)
   {
       case FM_TYPE_PMF:
       {
          pmfFrame_t *pmf = &sf->frameType.pmf;
          switch(pmf->type)
          {
              case PMF_TYPE_DISASSOC:
              {
              /* use the protected to set what type of key to send */

              }
              break;
              case PMF_TYPE_DEAUTH:
              {

              }
              break;
              case PMF_TYPE_SAQUERY:
              {

              }
              break;
              case PMF_TYPE_AUTH:
              {
              }
              break;
              case PMF_TYPE_ASSOCREQ:
              {
              }
              break;
              case PMF_TYPE_REASSOCREQ:
              {
              }
              break;
          }
       }
       break;
       case FM_TYPE_TDLS:
       {
          tdlsFrame_t *tdls = &sf->frameType.tdls;
          switch(tdls->type)
          {
              case TDLS_TYPE_DISCOVERY:
              /* use the peer mac address to send the frame */
                MTK_TDLS_CMD( " TDLS_DISCOVER %s", tdls->peer);
              break;
              case TDLS_TYPE_SETUP:
                MTK_TDLS_CMD( " TDLS_TYPE_SETUP %s", tdls->peer);
              break;
              case TDLS_TYPE_TEARDOWN:
                MTK_TDLS_CMD( " TDLS_TYPE_TEARDOWN %s", tdls->peer);
              break;
              case TDLS_TYPE_CHANNELSWITCH:
              break;
              case TDLS_TYPE_NULLFRAME:
              break;
          }
       }
       break;
       case FM_TYPE_VENT:
       {
          ventFrame_t *vent = &sf->frameType.vent;
          switch(vent->type)
          {
              case VENT_TYPE_NEIGREQ:
              break;
              case VENT_TYPE_TRANSMGMT:
              break;
          }
       }
   }

   wfaEncodeTLV(WFA_STA_SENDFRAME_RESP_TLV, 4, (BYTE *)staCmdResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

/*
 * This is used to set a temporary MAC address of an interface
 */
int wfaStaSetMacAddr(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   // Uncomment it if needed
   //dutCommand_t *cmd = (dutCommand_t *)caCmdBuf;
   // char *ifname = cmd->intf;
   dutCmdResponse_t *staCmdResp = &gGenericResp;
   // Uncomment it if needed
   //char *macaddr = &cmd->cmdsu.macaddr[0];

   wfaEncodeTLV(WFA_STA_SET_MAC_ADDRESS_RESP_TLV, 4, (BYTE *)staCmdResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}


int wfaStaDisconnect(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *disc = (dutCommand_t *)caCmdBuf;
    char *intf = disc->intf;
    dutCmdResponse_t *staDiscResp = &gGenericResp;

    // stop the supplicant
#ifdef MTK_HS20_SIGMA
	DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __func__);

	MTK_HS20_CMD("set auto_interworking 0 \n");

	MTK_HS20_CMD("remove_network all \n");
	//MTK_HS20_CMD("disconnect \n");
#elif defined(MTK_PMF_SIGMA)

    DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __func__);

    MTK_HS20_CMD("remove_network all \n");
#endif

    staDiscResp->status = STATUS_COMPLETE;

    wfaEncodeTLV(WFA_STA_DISCONNECT_RESP_TLV, 4, (BYTE *)staDiscResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}

/* Execute CLI, read the status from Environment variable */
int wfaExecuteCLI(char *CLI)
{
   char *retstr;

   system(CLI);

   retstr = getenv("WFA_CLI_STATUS");
   printf("cli status %s\n", retstr);
   return atoi(retstr);
}

/* Supporting Functions */

void wfaSendV4Ping(tgPingStart_t *staPing, float *interval, int streamid)
{
    int totalpkts;
    char cmdStr[1024];
//    char *addr = staPing->dipaddr;
#ifdef WFA_PC_CONSOLE
    char addr[20];
    char bflag[] = "-b";
    char *tmpstr;
    int inum=0;
#else
    char bflag[] = "  ";
#endif
    totalpkts = staPing->duration * staPing->frameRate;
#ifdef WFA_PC_CONSOLE

    printf("\nCS : The Stream ID is %d",streamid);
    printf("\nCS :the addr is %s ",addr);
    strcpy(addr,staPing->dipaddr);
    printf("\nCS :Inside the WFA_PC_CONSLE BLOCK");
    printf("\nCS :the addr is %s ",addr);
    tmpstr = strtok(addr, ".");

    inum = atoi(tmpstr);

    printf("interval %f\n", *interval);

    if(inum >= 224 && inum <= 239) // multicast
    {
    }
    else // if not MC, check if it is BC address
    {
       printf("\nCS :Inside the BC address BLOCK");
       printf("\nCS :the inum %d",inum);
       strtok(NULL, ".");
       //strtok(NULL, ".");
       tmpstr = strtok(NULL, ".");
       printf("tmpstr %s\n", tmpstr);
       inum = atoi(tmpstr);
       printf("\nCS : The string is %s",tmpstr);
       if(inum != 255)
          memset(bflag, 0, strlen(bflag));
    }
#endif
    printf("\nCS : The Stream ID is %d",streamid);

#ifdef MTK_HS20_SIGMA

	if(staPing->dscp == 0){
	    sprintf(cmdStr, "echo streamid=%i > "TMP_ASEC_PATH"spout_%d.txt;sh /data/wfaping.sh %s -i %f -c %i -s %i %s>> "TMP_ASEC_PATH"spout_%d.txt 2>/dev/null",
	          streamid,streamid,bflag, *interval, totalpkts, staPing->frameSize, staPing->dipaddr ,streamid);
	}
	else{
	    sprintf(cmdStr, "echo streamid=%i > "TMP_ASEC_PATH"spout_%d.txt;sh /data/wfaping.sh %s -i %f -c %i -s %i -Q %d %s>> "TMP_ASEC_PATH"spout_%d.txt 2>/dev/null",
	          streamid,streamid,bflag, *interval, totalpkts, staPing->frameSize, (staPing->dscp << 2) ,staPing->dipaddr ,streamid);
	}
		
    system(cmdStr);
    printf("\nCS : The command string is %s",cmdStr);


    sprintf(cmdStr, "sh /data/updatepid.sh "TMP_ASEC_PATH"spout_%d.txt",streamid);
    system(cmdStr);
    printf("\nCS : The command string is %s",cmdStr);

#else

#if !defined (MTK_P2P_SUPPLICANT)
    sprintf(cmdStr, "echo streamid=%i > /tmp/spout_%d.txt;sh /data/wfaping.sh %s -i %f -c %i -s %i %s>> /tmp/spout_%d.txt 2>/dev/null",
          streamid,streamid,bflag, *interval, totalpkts, staPing->frameSize, staPing->dipaddr, streamid);
#else
    sprintf(cmdStr, "echo streamid=%i > "TMP_ASEC_PATH"spout_%d.txt;sh /data/wfaping.sh %s -i %f -c %i -s %i %s>> "TMP_ASEC_PATH"spout_%d.txt 2>/dev/null",
          streamid,streamid,bflag, *interval, totalpkts, staPing->frameSize, staPing->dipaddr ,streamid);
#endif
    system(cmdStr);
    printf("\nCS : The command string is %s",cmdStr);

#if !defined (MTK_P2P_SUPPLICANT)
    sprintf(cmdStr, "sh /data/updatepid.sh /tmp/spout_%d.txt",streamid);
#else
    sprintf(cmdStr, "sh /data/updatepid.sh "TMP_ASEC_PATH"spout_%d.txt",streamid);
#endif
    system(cmdStr);
    printf("\nCS : The command string is %s",cmdStr);
	
#endif	

}

void wfaSendV6Ping(tgPingStart_t *staPing, float *interval, int streamid)
{
    int totalpkts;
    char cmdStr[512];
//    char *addr = staPing->dipaddr;
#ifdef WFA_PC_CONSOLE
    char addr[WFA_IP_V6_ADDR_STR_LEN];
    char bflag[] = "-b";
    char *tmpstr;
    int inum=0;
#else
    char bflag[] = "  ";
#endif
    totalpkts = staPing->duration * staPing->frameRate;
#ifdef WFA_PC_CONSOLE

    printf("\nCS : The Stream ID is %d",streamid);
    printf("\nCS :the addr is %s ",addr);
    strcpy(addr,staPing->dipaddr);
    printf("\nCS :Inside the WFA_PC_CONSLE BLOCK");
    printf("\nCS :the addr is %s ",addr);
    tmpstr = strtok(addr, ".");

    inum = atoi(tmpstr);

    printf("interval %f\n", *interval);

    if(inum >= 224 && inum <= 239) // multicast
    {
    }
    else // if not MC, check if it is BC address
    {
       printf("\nCS :Inside the BC address BLOCK");
       printf("\nCS :the inum %d",inum);
       strtok(NULL, ".");
       //strtok(NULL, ".");
       tmpstr = strtok(NULL, ".");
       printf("tmpstr %s\n", tmpstr);
       inum = atoi(tmpstr);
       printf("\nCS : The string is %s",tmpstr);
       if(inum != 255)
          memset(bflag, 0, strlen(bflag));
    }
#endif
    printf("%s : The Stream ID is %d\n",__func__,streamid);

#if defined (MTK_HS20_SIGMA)
	sprintf(cmdStr, "echo streamid=%i > "TMP_ASEC_PATH"spout_%d.txt;sh /data/wfav6ping.sh -q -i %d -c %d -s %d %s >> "TMP_ASEC_PATH"spout_%d.txt 2>/dev/null",
		  streamid,streamid,(int)((*interval)*1000),(staPing->frameRate*staPing->duration),staPing->frameSize,staPing->dipaddr,streamid);
#elif !defined (MTK_P2P_SUPPLICANT)
    sprintf(cmdStr, "echo streamid=%i > /tmp/spout_%d.txt;sh /data/wfav6ping.sh %s %s -i %f -c %i -s %i -q >> /tmp/spout_%d.txt 2>/dev/null",
          streamid,streamid,bflag, staPing->dipaddr, *interval, totalpkts, staPing->frameSize,streamid);
#else
    sprintf(cmdStr, "echo streamid=%i > "TMP_ASEC_PATH"spout_%d.txt;sh /data/wfav6ping.sh %s %s -c %i -s %i -q >> "TMP_ASEC_PATH"spout_%d.txt 2>/dev/null",
          streamid, streamid,bflag, staPing->dipaddr, totalpkts, staPing->frameSize, streamid);
#endif

	printf("%s : The command string is %s\n",__func__,cmdStr);
    system(cmdStr);
    

#if !defined (MTK_P2P_SUPPLICANT) && !defined (MTK_HS20_SIGMA)
    sprintf(cmdStr, "sh /data/updatepid.sh /tmp/spout_%d.txt",streamid);
#else
    sprintf(cmdStr, "sh /data/updatepid.sh "TMP_ASEC_PATH"spout_%d.txt",streamid);
#endif
	printf("%s : The command string is %s\n",__func__,cmdStr);
    system(cmdStr);

}


int wfaStopPing(dutCmdResponse_t *stpResp, int streamid)
{
    char strout[256];
    FILE *tmpfile = NULL;
    char cmdStr[1024];
    printf("Ping stop id %d\n", streamid);
#if !defined (MTK_P2P_SUPPLICANT)
    sprintf(cmdStr, "sh /data/getpid.sh /tmp/spout_%d.txt /tmp/pid.txt",streamid);
#else
    sprintf(cmdStr, "sh /data/getpid.sh "TMP_ASEC_PATH"spout_%d.txt "TMP_ASEC_PATH"pid.txt",streamid);
#endif
    system(cmdStr);

    printf("\nCS : The command string is %s",cmdStr);

#if !defined (MTK_P2P_SUPPLICANT)
    system("sh /data/stoping.sh /tmp/pid.txt ; sleep 2");
    sprintf(cmdStr, "sh /data/getpstats.sh /tmp/spout_%d.txt",streamid);
#else
    //system("sh /data/stoping.sh /data/asec/pid.txt ; sleep 2");
    system("killall "PING_NAME"; sleep 2");
    sprintf(cmdStr, "sh /data/getpstats.sh "TMP_ASEC_PATH"spout_%d.txt",streamid);
#endif


    system(cmdStr);

    printf("\nCS : The command string is %s",cmdStr);

#if !defined (MTK_P2P_SUPPLICANT)
    tmpfile = fopen("/tmp/stpsta.txt", "r+");
#else
    tmpfile = fopen(TMP_ASEC_PATH"stpsta.txt", "r+");
#endif

    if(tmpfile == NULL)
    {
        return WFA_FAILURE;
    }

    if(fscanf(tmpfile, "%s", strout) != EOF)
    {
        if(*strout == '\0')
        {
            stpResp->cmdru.pingStp.sendCnt = 0;
        }

        else
            stpResp->cmdru.pingStp.sendCnt = atoi(strout);
    }

    printf("after scan sent count %i\n", stpResp->cmdru.pingStp.sendCnt);


    if(fscanf(tmpfile, "%s", strout) != EOF)
    {
        if(*strout == '\0')
        {
            stpResp->cmdru.pingStp.repliedCnt = 0;
        }
        else
            stpResp->cmdru.pingStp.repliedCnt = atoi(strout);
    }
	
    printf("after scan replied count %i\n", stpResp->cmdru.pingStp.repliedCnt);

    fclose(tmpfile);

    return WFA_SUCCESS;
}

int wfaStaSetRadio(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *setRadio = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *staCmdResp = &gGenericResp;
    char *str;
    caStaSetRadio_t *sr = &setRadio->cmdsu.sr;

    if(sr->mode == WFA_OFF)
    {
       // turn radio off
    }
    else
    {
       // always turn the radio on
    }

    staCmdResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_RADIO_RESP_TLV, 4, (BYTE *)staCmdResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}


////workaround sigma ca ahiu 0604
int sig_index = 0 ;

////
int wfaStaSetRFeature(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *dutCmd = (dutCommand_t *)caCmdBuf;
   caStaRFeat_t *rfeat = &dutCmd->cmdsu.rfeat;
   dutCmdResponse_t *caResp = &gGenericResp;
   char *intf = dutCmd->intf;

#if 0 //defined MTK_HS20_SIGMA
	if(strcasecmp(rfeat->prog, "HS2-R2") == 0)
	{
		if((strlen(rfeat->username) > 0) && (strlen(rfeat->password) > 0)){
			DPRINT_INFO(WFA_OUT, "%s, Set Username(%s) Password(%s) for User remediation ...\n", 
				__func__, 
				rfeat->username,
				rfeat->password);
			MTK_HS20_CMD("-i %s set_uname_passwd %s %s\n",
				dutCmd->intf,
				rfeat->username,
				rfeat->password);
		}

	
		DPRINT_INFO(WFA_OUT, "%s, Policy Update %d ...\n", __func__, rfeat->policyupdate);	
		MTK_HS20_CMD("-i %s set_policy_update %d\n",
			dutCmd->intf,
			rfeat->policyupdate);
	}
#endif

#ifdef MTK_TDLS_SIGMA

   if(strcasecmp(rfeat->prog, "tdls") == 0)
   {

        printf("\n \n !!!!!  sig_index = %d  !!!!  \n \n", sig_index);
        printf("wfaStaSetRFeature: tdls command (ch enable=%d)\n", rfeat->chSwitch);
		if (rfeat->uapsd == eEnable || rfeat->uapsd == eDisable) {
			sprintf(gCmdStr, "iwpriv wlan0 set_power_mode %d", (int)rfeat->uapsd);
			system(gCmdStr);
		}

        
		if (rfeat->chSwitch == eEnable) {
			sprintf(gCmdStr, "iwpriv wlan0 set_str_cmd 0_9_%s_0_1_1_12_%d_%d_1", 
					rfeat->peer, rfeat->offChNum, rfeat->secChOffset);
            printf("wfaStaSetRFeature: %s\n", gCmdStr);
			system(gCmdStr);
		}

	   if (rfeat->chSwitch == eDisable) {
		   sprintf(gCmdStr, "iwpriv wlan0 set_str_cmd 0_9_%s_0_1_0_0_%d_%d_0", 
				   rfeat->peer, rfeat->offChNum, rfeat->secChOffset);
           printf("wfaStaSetRFeature: %s\n", gCmdStr);
		   system(gCmdStr);
	   }

	   if (rfeat->chSwitch == eEnable) 
       {
           sprintf(gCmdStr," iwpriv.hex wlan0 driver \"set_chip tdls 1  %s  %d 0 %d  0 0 \" ", 
               rfeat->peer, 
               rfeat->offChNum, rfeat->secChOffset);
               //11, 0);
           printf("wfaStaSetRFeature: %s\n", gCmdStr);
           system(gCmdStr);
       }

       if (rfeat->chSwitch == eDisable) {
           sprintf(gCmdStr," iwpriv.hex wlan0 driver \" set_chip tdls 0  %s  %d 0 %d  0 0\" ", 
               rfeat->peer, rfeat->offChNum, rfeat->secChOffset);
           printf("wfaStaSetRFeature: %s\n", gCmdStr);
           system(gCmdStr);
       }


       
   }

#endif


   caResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_RFEATURE_RESP_TLV, 4, (BYTE *)caResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}


#ifdef MTK_P2P_SIGMA
/*
 * wfaStaGetP2pDevAddress():
 */
int wfaStaGetP2pDevAddress(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* dutCommand_t *getInfo = (dutCommand_t *)caCmdBuf; */

	printf("\n Entry wfaStaGetP2pDevAddress... ");

#if !defined (MTK_P2P_SUPPLICANT)
	// Fetch the device ID and store into 	infoResp->cmdru.devid
	//strcpy(infoResp->cmdru.devid, str);
	strcpy(&infoResp.cmdru.devid[0], "ABCDEFGH");
#else
	{
		FILE *tmpfile = NULL;
		char *tmpfilename = TMP_ASEC_PATH"p2p_get_dev_addr.log";
		char string[256];

		MTK_P2P_CMD("p2p_get_dev_addr | grep return | cut -f2 -d\' \' > %s \n", tmpfilename);

		tmpfile = fopen(tmpfilename, "r+");
		if (tmpfile == NULL || fgets(string, WFA_P2P_DEVID_LEN, tmpfile) == NULL) {
			printf("fail to get dev addr \n");
			infoResp.status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_P2P_GET_DEV_ADDRESS_RESP_TLV, 4, (BYTE *)&infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;

			return WFA_FAILURE;
		}

		strncpy(&infoResp.cmdru.devid[0], string, WFA_P2P_DEVID_LEN);
		infoResp.cmdru.devid[WFA_P2P_DEVID_LEN - 1] = 0;
		printf("success! addr:%s\n", string);
		fclose(tmpfile);
	}
#endif //MTK_P2P_SUPPLICANT

	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_P2P_GET_DEV_ADDRESS_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

	return WFA_SUCCESS;
}



/*
 * wfaStaSetP2p():
 */
int wfaStaSetP2p(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	caStaSetP2p_t *c, *getStaSetP2p = (caStaSetP2p_t *)caCmdBuf;
	enum P2P_MODE_E { MODE_LISTEN, MODE_DISCOVER, MODE_IDLE, MODE_DISABLE };
	int p2p_mode = -1;

	c = getStaSetP2p;
	printf("\n Entry wfaStaSetP2p... ");

	// Implement the function and this does not return any thing back.
#if defined (MTK_P2P_SUPPLICANT)
	{

#define STA_SET_P2P(param_flag, param_value, param_fmt_str)			\
		if (param_flag) {											\
			MTK_P2P_CMD("p2p_set " param_fmt_str, param_value);		\
		}															\
		else {														\
			printf("p2p_set flag==0 " param_fmt_str "\n", param_value);	\
		}

		STA_SET_P2P(c->listen_chn_flag, c->listen_chn, "Listen_chan %u");

		if (0 == strcmp(c->p2p_mode, "Listen"))
			p2p_mode = MODE_LISTEN;
		if (0 == strcmp(c->p2p_mode, "Discover"))
			p2p_mode = MODE_DISCOVER;
		if (0 == strcmp(c->p2p_mode, "Idle"))
			p2p_mode = MODE_IDLE;
		if (0 == strcmp(c->p2p_mode, "Disable"))
			p2p_mode = MODE_DISABLE;

		STA_SET_P2P(c->p2p_mode_flag, c->p2p_mode, "P2p_mode %s");

		STA_SET_P2P(c->presistent_flag, c->presistent, "Persistence %u");

		STA_SET_P2P(c->intra_bss_flag, c->intra_bss, "Intra_bss %u");

		STA_SET_P2P(c->noa_duration_flag, c->noa_duration, "Noa_duration %u");

		STA_SET_P2P(c->noa_interval_flag, c->noa_interval, "Noa_interval %u");

		STA_SET_P2P(c->noa_count_flag, c->noa_count, "Noa_count %u");

		STA_SET_P2P(c->concurrency_flag, c->concurrency, "Concurrency %u");

		STA_SET_P2P(c->p2p_invitation_flag, c->p2p_invitation, "Invitation %u");

		STA_SET_P2P(c->bcn_int_flag, c->bcn_int, "bcn_count %u");

		STA_SET_P2P(c->ext_listen_time_int_flag, c->ext_listen_time_int, "Ext_listen_time_interval %u");

		STA_SET_P2P(c->ext_listen_time_period_flag, c->ext_listen_time_period, "Ext_listen_time_period %u");
		STA_SET_P2P(c->discoverability_flag, c->discoverability, "Discoverability %u");

		STA_SET_P2P(c->service_discovry_flag, c->service_discovery, "Service_discovery %u");

		STA_SET_P2P(c->crossconnection_flag, c->crossconnection, "CrossConnection %u");

		STA_SET_P2P(c->p2pmanaged_flag, c->p2pmanaged, "Managed %u");

		STA_SET_P2P(c->go_apsd_flag, c->go_apsd, "GO_APSD %u");

	}
#endif   // MTK_P2P_SUPPLICANT

   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_SETP2P_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}

/*
 * wfaStaP2pDissolve():
 */
int wfaStaP2pDissolve(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaP2pDissolve_t *getStap2pDissolve= (caStaP2pDissolve_t *)caCmdBuf;

	printf("\n Entry wfaStaP2pDissolve... ");

	// Implement the function and this does not return any thing back.
#if defined (MTK_P2P_SUPPLICANT)
	MTK_P2P_CMD("p2p_dissolve %s \n", getStap2pDissolve->grpId);

#endif //MTK_P2P_SUPPLICANT

   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_DISSOLVE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}

/*
 * wfaStaAcceptP2pInvReq():
 */
int wfaStaAcceptP2pInvReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	caStaAcceptP2pInvReq_t *getStaP2pInvReq= (caStaAcceptP2pInvReq_t *)caCmdBuf;
	caStaAcceptP2pInvReq_t *c = getStaP2pInvReq;

	printf("\n Entry wfaStaAcceptP2pInvReq... ");

	// Implement the function and this does not return any thing back.
#if defined (MTK_P2P_SUPPLICANT)
	MTK_P2P_CMD("p2p_accept_invitation %s %s %u \n", c->devId, c->grpId, c->reinvoke);

#endif //MTK_P2P_SUPPLICANT

   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_ACCEPT_INV_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}


/*
 * wfaStaSendP2pProvDisReq():
 */
int wfaStaSendP2pProvDisReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	caStaSendP2pProvDisReq_t *getStaP2pProvDisReq= (caStaSendP2pProvDisReq_t *)caCmdBuf;
	caStaSendP2pProvDisReq_t *c = getStaP2pProvDisReq;

	printf("\n Entry wfaStaSendP2pProvDisReq... ");

	// Implement the function and this does not return any thing back.
#if defined (MTK_P2P_SUPPLICANT)
	MTK_P2P_CMD("p2p_send_provision_dis %s %s \n", c->confMethod, c->devId);

#endif //MTK_P2P_SUPPLICANT

   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_SEND_PROV_DIS_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}

/*
 * wfaStaSetWpsPbc():
 */
int wfaStaSetWpsPbc(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* uncomment and use it
    * caStaSetWpsPbc_t *getStaSetWpsPbc= (caStaSetWpsPbc_t *)caCmdBuf;
    */

	printf("\n Entry wfaStaSetWpsPbc... ");

	// Implement the function and this does not return any thing back.
#if defined (MTK_P2P_SUPPLICANT)
	MTK_P2P_CMD("p2p_config_ready PBC \n");

#endif //MTK_P2P_SUPPLICANT


   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_WPS_SETWPS_PBC_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}

/*
 * wfaStaWpsReadPin():
 */
int wfaStaWpsReadPin(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* uncomment and use it
    * caStaWpsReadPin_t *getStaWpsReadPin= (caStaWpsReadPin_t *)caCmdBuf;
    */

	printf("\n Entry wfaStaWpsReadPin... ");

	// Fetch the device PIN and put in 	infoResp->cmdru.wpsPin
	//strcpy(infoResp->cmdru.wpsPin, "12345678");
#if !defined (MTK_P2P_SUPPLICANT)
	strcpy(&infoResp.cmdru.wpsPin[0], "1234456");
#else
	{
		FILE *tmpfile = NULL;
		char string[256];
		char *tmpfilename = TMP_ASEC_PATH"p2p_pin_for_display_sigma";

		MTK_P2P_CMD("p2p_pin_for_display_sigma | grep return | cut -f2- -d\' \' > %s \n", tmpfilename);

		tmpfile = fopen(tmpfilename, "r+");
		if ((NULL == tmpfile) || (NULL == fgets(string, 256, tmpfile))) {
			printf("fail: %s \n", tmpfilename);
			infoResp.status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_WPS_READ_PIN_RESP_TLV, 4, (BYTE *)&infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			return WFA_FAILURE;
		}

		strncpy(infoResp.cmdru.wpsPin, string, WFA_WPS_PIN_LEN);
	}
#endif //MTK_P2P_SUPPLICANT


   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_WPS_READ_PIN_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}



/*
 * wfaStaWpsReadLabel():
 */
int wfaStaWpsReadLabel(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* uncomment and use it
    * caStaWpsReadLabel_t *getStaWpsReadLabel= (caStaWpsReadLabel_t *)caCmdBuf;
    */

	printf("\n Entry wfaStaWpsReadLabel... ");

	// Fetch the device Label and put in	infoResp->cmdru.wpsPin
	//strcpy(infoResp->cmdru.wpsPin, "12345678");

#if !defined (MTK_P2P_SUPPLICANT)
	strcpy(&infoResp.cmdru.wpsPin[0], "1234456");
#else
	// FIXME, the following is to read PIN not LABEL, that is not yet implemented.
	{
		FILE *tmpfile = NULL;
		char string[256];
		char *tmpfilename = TMP_ASEC_PATH"p2p_pin_for_display";

		MTK_P2P_CMD("p2p_pin_for_display  | grep return | cut -f2- -d\' \' > %s \n", tmpfilename);

		tmpfile = fopen(tmpfilename, "r+");
		if ((NULL == tmpfile) || (NULL == fgets(string, 256, tmpfile))) {
			printf("fail: %s \n", tmpfilename);
			infoResp.status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_WPS_READ_PIN_RESP_TLV, 4, (BYTE *)&infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			return WFA_FAILURE;
		}

		strncpy(infoResp.cmdru.wpsPin, string, WFA_WPS_PIN_LEN);
	}
#endif //MTK_P2P_SUPPLICANT


   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_WPS_READ_PIN_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}


/*
 * wfaStaWpsEnterPin():
 */
int wfaStaWpsEnterPin(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
    caStaWpsEnterPin_t *getStaWpsEnterPin= (caStaWpsEnterPin_t *)caCmdBuf;

	printf("\n Entry wfaStaWpsEnterPin... ");

   // Implement the function and this does not return any thing back.
#if defined (MTK_P2P_SUPPLICANT)
	MTK_P2P_CMD("p2p_config_ready KEYPAD %s \n", getStaWpsEnterPin->wpsPin);

#endif //MTK_P2P_SUPPLICANT

   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_WPS_ENTER_PIN_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}



/*
 * wfaStaP2pReset():
 */
int wfaStaP2pReset(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* dutCommand_t *getStaP2pReset= (dutCommand_t *)caCmdBuf; */

	printf("\n Entry wfaStaP2pReset... ");
	// Implement the function and this does not return any thing back.
#if defined (MTK_P2P_SUPPLICANT)
	MTK_P2P_CMD("p2p_reset \n");

#endif //MTK_P2P_SUPPLICANT

   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_RESET_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}



/*
 * wfaStaGetP2pIpConfig():
 */
int wfaStaGetP2pIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{

	dutCmdResponse_t infoResp;
    int slen, ret, i = 0;
    dutCommand_t *getIpConf = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *ipconfigResp = &infoResp;
    char *ifname = getIpConf->intf;
    caStaGetP2pIpConfigResp_t *ifinfo = &ipconfigResp->cmdru.getIfconfig;

    FILE *tmpfd;
    char string[256];
    char *str;


	printf("\n Entry wfaStaGetP2pIpConfig... ");


	// Fetch the device IP config  and put in 	infoResp->cmdru
	//strcpy(infoResp->cmdru.wpsPin, "12345678");
#if defined (MTK_P2P_SUPPLICANT)
    /*
     * check a script file (the current implementation specific)
     */
    ret = access("/data/mtk_p2p_getipconfig.sh", F_OK);
    if(ret == -1)
    {
       ipconfigResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_P2P_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;

       DPRINT_ERR(WFA_ERR, "file not exist\n");
       return WFA_FAILURE;

    }

    strcpy(ifinfo->dns[0], "0");
    strcpy(ifinfo->dns[1], "0");

    /*
     * Run the script file "getipconfig.sh" to check the ip status
     * (current implementation  specific).
     * note: "getipconfig.sh" is only defined for the current implementation
     */
    sprintf(gCmdStr, "sh /data/mtk_p2p_getipconfig.sh "TMP_ASEC_PATH"ipconfig.txt %s\n", ifname);
	puts("\n\t");
	puts(gCmdStr);

    system(gCmdStr);

    /* open the output result and scan/retrieve the info */
    tmpfd = fopen(TMP_ASEC_PATH"ipconfig.txt", "r+");

    if(tmpfd == NULL)
    {
      ipconfigResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_P2P_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return WFA_FAILURE;
    }

    for(;;)
    {
        if(fgets(string, 256, tmpfd) == NULL)
           break;

        /* check dhcp enabled */
        if(strncmp(string, "dhcpcli", 7) ==0)
        {
            str = strtok(string, "=");
            str = strtok(NULL, "=");
            if(str != NULL && strncmp("running", str, 7)==0)
               ifinfo->isDhcp = 1;
            else
               ifinfo->isDhcp = 0;
        }

        /* find out the ip address */
        if(strncmp(string, "ipaddr", 6) == 0)
        {
            str = strtok(string, "=");
            str = strtok(NULL, " ");
            if(str != NULL)
            {
               wSTRNCPY(ifinfo->ipaddr, str, WFA_IP_ADDR_STR_LEN);
               ifinfo->ipaddr[WFA_IP_ADDR_STR_LEN-1]='\0';
            }
            else
               wSTRNCPY(ifinfo->ipaddr, "none", WFA_IP_ADDR_STR_LEN);
        }

        /* find out the mac address */
        if(strncmp(string, "mac", 3) == 0)
        {
            str = strtok(string, "=");
            str = strtok(NULL, " ");
            if(str != NULL)
            {
               wSTRNCPY(ifinfo->mac, str, WFA_MAC_ADDR_STR_LEN);
               ifinfo->mac[WFA_MAC_ADDR_STR_LEN-1]='\0';
            }
            else
               wSTRNCPY(ifinfo->mac, "none", WFA_MAC_ADDR_STR_LEN);
        }

        /* check the mask */
        if(strncmp(string, "mask", 4) == 0)
        {
            char ttstr[16];
            char *ttp = ttstr;

            str = strtok_r(string, "=", &ttp);
            if(*ttp != '\0')
            {
				strncpy(ifinfo->mask, ttp, WFA_IP_MASK_STR_LEN);
				//slen = strlen(ifinfo->mask);
				ifinfo->mask[WFA_IP_MASK_STR_LEN-1] = '\0';
            }
            else
               strcpy(ifinfo->mask, "none");
        }

        /* find out the dns server ip address */
        if(strncmp(string, "nameserv", 8) == 0)
        {
            char ttstr[16];
            char *ttp = ttstr;

            str = strtok_r(string, " ", &ttp);
            if(str != NULL)
            {
				if (i < 1) {
					strncpy(ifinfo->dns[i], ttp, WFA_IP_ADDR_STR_LEN);
					//slen = strlen(ifinfo->dns[i]);
					ifinfo->dns[i][WFA_IP_ADDR_STR_LEN-1] = '\0';
					i++;
				}
            }
        }
     }

     /*
      * Report back the results
      */
     ipconfigResp->status = STATUS_COMPLETE;
     wfaEncodeTLV(WFA_STA_P2P_GET_IP_CONFIG_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)ipconfigResp, respBuf);

     *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

#if 0
     DPRINT_INFO(WFA_OUT, "%i, %i, %s, %s, %s, %s, %s, %i,\n", ipconfigResp->status,
				 ifinfo->isDhcp, ifinfo->ipaddr, ifinfo->mask,
				 ifinfo->dns[0], ifinfo->dns[1], ifinfo->mac, *respLen);
#endif

     fclose(tmpfd);

#endif //MTK_P2P_SUPPLICANT

    return WFA_SUCCESS;

    }







/*
 * wfaStaSendServiceDiscoveryReq():
 */
int wfaStaSendServiceDiscoveryReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* caStaSendServiceDiscoveryReq_t *staSendServiceDiscoveryReq= (caStaSendServiceDiscoveryReq_t *)caCmdBuf; uncomment and use it */

	printf("\n Entry wfaStaSendServiceDiscoveryReq... ");
	// Implement the function and this does not return any thing back.

	//FIXME, TBD


   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_SEND_SERVICE_DISCOVERY_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}



/*
 * wfaStaSendP2pPresenceReq():
 */
int wfaStaSendP2pPresenceReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaSendP2pPresenceReq_t *staSendP2pPresenceReq= (caStaSendP2pPresenceReq_t *)caCmdBuf;
   caStaSendP2pPresenceReq_t *c = staSendP2pPresenceReq;

	printf("\n Entry wfaStaSendP2pPresenceReq... ");
	// Implement the function and this does not return any thing back.

#if defined (MTK_P2P_SUPPLICANT)
	MTK_P2P_CMD("p2p_send_presence %llu %llu %s \n", c->duration, c->interval, "");

#endif //MTK_P2P_SUPPLICANT


   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_SEND_PRESENCE_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}

/*
 * wfaStaSetSleepReq():
 */
int wfaStaSetSleepReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* caStaSetSleep_t *staSetSleepReq= (caStaSetSleep_t *)caCmdBuf; */

	printf("\n Entry wfaStaSetSleepReq... ");
	// Implement the function and this does not return any thing back.
#if defined (MTK_P2P_SUPPLICANT)
	MTK_P2P_CMD("p2p_set_sleep \n");

#endif //MTK_P2P_SUPPLICANT


   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_SET_SLEEP_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN +4;

   return WFA_SUCCESS;
}

/*
 * wfaStaSetOpportunisticPsReq():
 */
int wfaStaSetOpportunisticPsReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaSetOpprPs_t *staSetOpperPsReq= (caStaSetOpprPs_t *)caCmdBuf;

	printf("\n Entry wfaStaSetOpportunisticPsReq... ");
	// Implement the function and this does not return any thing back.
#if defined (MTK_P2P_SUPPLICANT)
	MTK_P2P_CMD("p2p_set_opps %u %s \n", staSetOpperPsReq->ctwindow, staSetOpperPsReq->grpId);

#endif //MTK_P2P_SUPPLICANT


   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_SET_OPPORTUNISTIC_PS_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}
#ifndef WFA_STA_TB
/*
 * wfaStaPresetParams():
 */

int wfaStaPresetParams(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;

   caStaPresetParameters_t *presetParams = (caStaPresetParameters_t *)caCmdBuf;


   DPRINT_INFO(WFA_OUT, "Inside wfaStaPresetParameters function ...\n");

	// Implement the function and its sub commands
	infoResp.status = STATUS_COMPLETE;

   wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_RESP_TLV, 4, (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}
int wfaStaSet11n(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{

	caSta11n_t * v11nParams = (caSta11n_t *)caCmdBuf;
	dutCmdResponse_t infoResp;
	dutCmdResponse_t *v11nParamsResp = &infoResp;



	int st =0; // SUCCESS

	DPRINT_INFO(WFA_OUT, "Inside wfaStaSet11n function....\n");

	printf("FIXME FIXME, not yet implemented wfaStaSet11n \n");


	if(v11nParams->addba_reject != 0xFF && v11nParams->addba_reject < 2)
	{
		// implement the funciton
		//st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_addba_reject failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return WFA_FAILURE;
		}
	}

    if(v11nParams->ampdu != 0xFF && v11nParams->ampdu < 2)
	{
		// implement the funciton
		//st = wfaExecuteCLI(gCmdStr);

		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_ampdu failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return WFA_FAILURE;
		}
	}

    if(v11nParams->amsdu != 0xFF && v11nParams->amsdu < 2)
	{
		// implement the funciton
		//st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_amsdu failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return WFA_FAILURE;
		}
	}

    if(v11nParams->greenfield != 0xFF && v11nParams->greenfield < 2)
	{
		// implement the funciton
		//st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "_set_greenfield failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return WFA_FAILURE;
		}
	}

    if(v11nParams->mcs32!= 0xFF && v11nParams->mcs32 < 2 && v11nParams->mcs_fixedrate[0] != '\0')
	{
		// implement the funciton
		//st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_mcs failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return WFA_FAILURE;
		}
	}
	else if (v11nParams->mcs32!= 0xFF && v11nParams->mcs32 < 2 && v11nParams->mcs_fixedrate[0] == '\0')
	{
		// implement the funciton
		//st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_mcs32 failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return WFA_FAILURE;
		}

	}
	else if (v11nParams->mcs32 == 0xFF && v11nParams->mcs_fixedrate[0] != '\0')
	{
		// implement the funciton
		//st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_mcs32 failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return WFA_FAILURE;
		}
	}

    if(v11nParams->rifs_test != 0xFF && v11nParams->rifs_test < 2)
	{
		// implement the funciton
		//st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_rifs_test failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return WFA_FAILURE;
		}
	}

    if(v11nParams->sgi20 != 0xFF && v11nParams->sgi20 < 2)
	{
		// implement the funciton
		//st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_sgi20 failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return WFA_FAILURE;
		}
	}

	if(v11nParams->smps != 0xFFFF)
	{
	    if(v11nParams->smps == 0)
	    {
			// implement the funciton
			//st = wfaExecuteCLI(gCmdStr);
			;

	    }
	    else if(v11nParams->smps == 1)
	    {
			// implement the funciton
			//st = wfaExecuteCLI(gCmdStr);
			;
	    }
	    else if(v11nParams->smps == 2)
		{
			// implement the funciton
			//st = wfaExecuteCLI(gCmdStr);
			;
	    }
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_smps failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return WFA_FAILURE;
		}
	}

	if(v11nParams->stbc_rx != 0xFFFF)
	{
		// implement the funciton
		//st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_stbc_rx failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return WFA_FAILURE;
		}
	}

	if(v11nParams->width[0] != '\0')
	{
		// implement the funciton
		//st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_11n_channel_width failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return WFA_FAILURE;
		}

	}

    if(v11nParams->_40_intolerant != 0xFF && v11nParams->_40_intolerant < 2)
	{
		// implement the funciton
		//st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_40_intolerant failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return WFA_FAILURE;
		}

	}

	if(v11nParams->txsp_stream != 0 && v11nParams->txsp_stream <4)
	{
		// implement the funciton
		//st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
			v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_txsp_stream failed");
			wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return WFA_FAILURE;
		}

	}

	if(v11nParams->rxsp_stream != 0 && v11nParams->rxsp_stream < 4)
	{
		// implement the funciton
		//st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
			v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_rxsp_stream failed");
			wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return WFA_FAILURE;
		}
	}

	v11nParamsResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, 4, (BYTE *)v11nParamsResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;
	return WFA_SUCCESS;
}
#endif
/*
 * wfaStaAddArpTableEntry():
 */
int wfaStaAddArpTableEntry(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* caStaAddARPTableEntry_t *staAddARPTableEntry= (caStaAddARPTableEntry_t *)caCmdBuf; uncomment and use it */

	printf("\n Entry wfastaAddARPTableEntry... ");
	// Implement the function and this does not return any thing back.

   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_ADD_ARP_TABLE_ENTRY_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}

/*
 * wfaStaBlockICMPResponse():
 */
int wfaStaBlockICMPResponse(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* caStaBlockICMPResponse_t *staAddARPTableEntry= (caStaBlockICMPResponse_t *)caCmdBuf; uncomment and use it */

	printf("\n Entry wfaStaBlockICMPResponse... ");
	// Implement the function and this does not return any thing back.

   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_BLOCK_ICMP_RESPONSE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}
#endif /* MTK_P2P_SIGMA */


#ifdef MTK_HS20_SIGMA

/*
 * wfaStaResetParm():
 */
int wfaStaHs20ResetParm(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	caStaResetParm_t *staResetParm = (caStaResetParm_t *)caCmdBuf;
	FILE *tmpfile = NULL;
	char str[128];
	char *tmpfilename = TMP_ASEC_PATH"hs20_sta_reset_parm";

	DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __func__);

	{
		// Clean up ARP
		if(staResetParm->arp[0] != '\0'){
			// Clean all entries
			if(strncmp(staResetParm->arp, "all", 3) == 0){
				sprintf(gCmdStr, "arp -a | cut -f 2 -d '(' | cut -f 1 -d ')' > %s \n", tmpfilename);
				DPRINT_INFO(WFA_OUT, "%s", gCmdStr);
   				system(gCmdStr);

				tmpfile = fopen(tmpfilename, "r+");

				while(fgets(str, 128, tmpfile) != NULL){
					sprintf(gCmdStr, "arp -i %s -d %s \n", staResetParm->intf, str);
					DPRINT_INFO(WFA_OUT, "%s", gCmdStr);
   					system(gCmdStr);
				}
				if(tmpfile != NULL)
					fclose(tmpfile);
			}
			// Clean a specific IP entry
			else if(isIpV4Addr(staResetParm->arp) == WFA_SUCCESS){
				sprintf(gCmdStr, "arp -d %s \n", staResetParm->arp);
				DPRINT_INFO(WFA_OUT, "%s", gCmdStr);
				system(gCmdStr);
			}
			else {
				infoResp.status = STATUS_INVALID;
				wfaEncodeTLV(WFA_STA_HS20_STA_RESET_PARM_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
				*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
				return WFA_FAILURE;
			}

		}

		// Clean up hs2_cache_profile
		if(staResetParm->hs2_cache_profile[0] != '\0'){
			// Clean all hs2_cache_profile
			if(strncmp(staResetParm->hs2_cache_profile, "all", 3) == 0){
				MTK_HS20_CMD("-i %s remove_network all", staResetParm->intf);
			}
			else {
				infoResp.status = STATUS_INVALID;
				wfaEncodeTLV(WFA_STA_HS20_STA_RESET_PARM_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
				*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
				return WFA_FAILURE;
			}
		}
	}


   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_HS20_STA_RESET_PARM_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}


/*
 * wfaStaHs20GetGtkPtkKey():
 */
int wfaStaHs20GetGtkPtkKey(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	caStaGetKey_t *staGetKey= (caStaGetKey_t *)caCmdBuf;

	DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __func__);
	{
		FILE *tmpfile = NULL;
		char string[128];
		char *tmpfilename = TMP_ASEC_PATH"hs20_get_key";

		MTK_HS20_CMD("get_gtk_ptk_key %s | grep KEY | cut -f2 -d ' '  > %s \n",
			staGetKey->intf,
			staGetKey->keyType,
			tmpfilename);

		tmpfile = fopen(tmpfilename, "r+");
		if ((NULL == tmpfile) || (NULL == fgets(string, 128, tmpfile))) {
			printf("fail: %s \n", tmpfilename);
			infoResp.status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_HS20_GET_GTK_PTK_KEY_RESP_TLV, 4, (BYTE *)&infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			return WFA_FAILURE;
		}

		DPRINT_INFO(WFA_OUT, "[%s] The GTK Key is : %s", __func__, string);

		strncpy(&infoResp.cmdru.GtkPtkKey[0], string, 32);
		if(tmpfile != NULL)
			fclose(tmpfile);
	}


   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_HS20_GET_GTK_PTK_KEY_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}


/*
 * wfaStaHs20SetBssidPool():
 */
int wfaStaHs20SetBssidPool(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	caStaBssidPool_t *staBssidPool= (caStaBssidPool_t *)caCmdBuf;
	int j=0;

	DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __func__);
	{
		DPRINT_INFO(WFA_OUT, "%s, staBssidPool->bssid_filter %c ...\n", __func__, staBssidPool->bssid_filter);
		DPRINT_INFO(WFA_OUT, "%s, staBssidPool->bssid_list %s ...\n", __func__, staBssidPool->bssid_list[0]);

		if(staBssidPool->bssid_filter == '1'){
			MTK_HS20_CMD("-i %s set bssid_filter %s\n",
				staBssidPool->intf,
				staBssidPool->bssid_list[0]);
		}else {
			MTK_HS20_CMD("-i %s set bssid_filter xx\n",
				staBssidPool->intf);

		}
	}
	
	MTK_HS20_CMD("-i %s scan\n",
		staBssidPool->intf);

    printf("Setting Bssid Pool");
	for(j=1; j<=10; j++){
		printf(".", j);
		buzz_time(1000000);
	}
	printf("\n");
	
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_HS20_SET_BSSID_POOL_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}


#if 0
/*
 * wfaStaHs20StaHs2Associate():
 */
int wfaStaHs20StaHs2Associate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCommand_t *staHs2Associate = (dutCommand_t *)caCmdBuf;
	char *ifname = staHs2Associate->intf;
	dutCmdResponse_t infoResp;

	FILE *tmpfile = NULL;
	FILE *tmpfile1 = NULL;
	char temp_str[256] = "";
	char temp_str1[4] = "";
	char *str;
	char ssid[WFA_SSID_NAME_LEN];
	char bssid[18];
	char *tmpfilename = "/data/asec/staHs2Assoc.txt";
	char *tmpfilename1 = "/data/asec/scanlock.txt";
	int i=0, j=0;
	int assoc_rnd = 60;
	int scan_fail = 0;
	int fg_bssid = 0;
	int fg_ssid = 0;

	DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __func__);

	MTK_HS20_CMD("-i %s ap_scan 1 ", ifname);

#if 0
	//Disable network
	//MTK_HS20_CMD("-i %s disable_network all\n", ifname);
	MTK_HS20_CMD("-i %s scan", ifname);
	buzz_time(10000000);
#endif

	//scan_lock
	// No need while normal mode. Enable while attending plugfest
#if 0	
	for(i=0; i<10; i++){
		DPRINT_INFO(WFA_OUT, "Round %d...", i);
		MTK_HS20_CMD("-i %s lock_hs20_scan | grep RESULT | cut -f 2 -d ':'  > %s \n", ifname, tmpfilename1);
		tmpfile1 = fopen(tmpfilename1, "r+");
		if ((tmpfile1 == NULL)||(fscanf(tmpfile1, "%s", temp_str1) == EOF)){
			printf("fail scan_lock file: %s \n", tmpfilename1);
			infoResp.status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_HS20_STA_HS2_ASSOCIATE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			fclose(tmpfile1);
			return WFA_FAILURE;
		}

		if(strncmp(temp_str1, "PASS", 4) == 0){
			DPRINT_INFO(WFA_OUT, "SCAN_LOCK PASS\n");
			scan_fail = 0;
			break;
		}
		else if(strncmp(temp_str1, "FAIL", 4) == 0){
			DPRINT_INFO(WFA_OUT, "SCAN_LOCK FAIL\n");
			scan_fail = 1;
			MTK_HS20_CMD("scan \n");
			buzz_time(1000000);
		}
		else {
			printf("fail scan_lock return status: %s \n", temp_str1);
			infoResp.status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_HS20_STA_HS2_ASSOCIATE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			fclose(tmpfile1);
			return WFA_FAILURE;
		}
		fclose(tmpfile1);
	}
#endif	

	// Enable network
	//MTK_HS20_CMD("-i %s enable_network all\n", ifname);
/*
	if(scan_fail == 1){
		printf("Scan fail!!!\n");
		infoResp.status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_HS20_STA_HS2_ASSOCIATE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;
		return WFA_FAILURE;
	}
*/

	//StaHs2Associate
	{
		MTK_HS20_CMD("-i %s sta_hs2_associate \n", ifname);
		printf("running...\n");
		//buzz_time(30000000);
		//printf("done!!!\n");
		//sprintf(gCmdStr, " echo -e \"ssid=1234\\nbssid=11:22:33:44:55:66\" > %s \n", tmpfilename);
		//DPRINT_INFO(WFA_OUT, "%s", gCmdStr);
   		//system(gCmdStr);
	}

	//Get current association status
	for(j=1; j<=assoc_rnd; j++){
		printf("Get current association status...(%d)\n", j);
		buzz_time(1000000);

		// Watch-dog
		if(j % 20 == 1){
			MTK_HS20_CMD("-i %s sta_pred_anqp_dis \n", ifname);
			buzz_time(500000);
			MTK_HS20_CMD("-i %s sta_pred_anqp_en \n", ifname);
		}
		
		MTK_HS20_CMD("-i %s get_curr_assoc > %s \n", ifname, tmpfilename);
		tmpfile = fopen(tmpfilename, "r+");
		if (tmpfile == NULL) {
			printf("fail: %s \n", tmpfilename);
			infoResp.status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_HS20_STA_HS2_ASSOCIATE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			if(tmpfile != NULL)
				fclose(tmpfile);
			return WFA_FAILURE;
		}

		infoResp.cmdru.staHs2Assoc.ssid[0] = '\0';
		infoResp.cmdru.staHs2Assoc.bssid[0] = '\0';
		for(;;)
		{
			if(fscanf(tmpfile, "%s", temp_str) == EOF)
			{
				printf("Not ready...\n");
				goto loop_get_assoc;
#if 0			
				if(strncmp(temp_str, "FAIL", 4) == 0)
						goto loop_get_assoc;
				
				if((infoResp.cmdru.staHs2Assoc.ssid[0] == '\0') ||
					(infoResp.cmdru.staHs2Assoc.bssid[0] == '\0')){
					printf("fail result: ssid = %s \n", infoResp.cmdru.staHs2Assoc.ssid);
					printf("fail result: bssid = %s \n", infoResp.cmdru.staHs2Assoc.bssid);
					infoResp.status = STATUS_ERROR;
					wfaEncodeTLV(WFA_STA_HS20_STA_HS2_ASSOCIATE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
					*respLen = WFA_TLV_HDR_LEN + 4;
					return WFA_FAILURE;
				} else {
					goto loop_get_assoc;
				}
				break;
#endif				
			}

			if(strncmp(temp_str, "bssid", 5) == 0)
			{
				str = strtok(temp_str, "=");
				str = strtok(NULL, "=");
				if(str != NULL)
				{
					strcpy(infoResp.cmdru.staHs2Assoc.bssid, str);
					infoResp.cmdru.staHs2Assoc.bssid[17] = '\0';
				}
				printf("bssid = %s \n", infoResp.cmdru.staHs2Assoc.bssid);
				fg_bssid = 1;
			}

			if(strncmp(temp_str, "ssid", 4) == 0)
			{
				str = strtok(temp_str, "=");
				str = strtok(NULL, "=");
				if(str != NULL)
				{
					strcpy(infoResp.cmdru.staHs2Assoc.ssid, str);
					infoResp.cmdru.staHs2Assoc.ssid[WFA_SSID_NAME_LEN-1] = '\0';
				}
				printf("ssid = %s \n", infoResp.cmdru.staHs2Assoc.ssid);
				fg_ssid = 1;
			}

			if(fg_bssid == 1 && fg_ssid == 1){
				goto assoc_done;
			}
		}
loop_get_assoc:
		if(j >= assoc_rnd){
			printf("Assoc status failed after (%d) sec ... \n", j);
			infoResp.status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_HS20_STA_HS2_ASSOCIATE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			return WFA_FAILURE;	
		}	
	}	

assoc_done:
	if(tmpfile != NULL)
		fclose(tmpfile);

	//Resume scan
	MTK_HS20_CMD("-i %s ap_scan 1 ", ifname);
	MTK_HS20_CMD("-i %s scan", ifname);

	buzz_time(3000000);

	if(fgIsDhcpOn) {
		FILE *tmpfd;
		char ipv6addr[WFA_IP_V6_ADDR_STR_LEN];
		
		printf("Requesting DHCP IP!\n");
		system("netcfg wlan0 dhcp");
		

		printf("Acquiring dhcp");
		for(j=1; j<=10; j++){
			printf(".", j);
			buzz_time(1000000);
		}
		printf("\n");

		printf("DHCP DONE!\n");


#if 0
		// set ipv6 manually START		
    	sprintf(gCmdStr, "busybox-full ifconfig %s |grep inet6 | cut -d \" \" -f 13 > /data/asec/ipconfig.txt \n", ifname);
		puts("\n\t");
		puts(gCmdStr);
		system(gCmdStr);
		
		tmpfd = fopen("/data/asec/ipconfig.txt", "r+");
		
		if(tmpfd == NULL){
			DPRINT_ERR(WFA_ERR, "file open failed\n");
		}
		else {
			int idx, str_idx = 0;
			char v6_str[256], *temp_str;

			fgets(v6_str, 256, tmpfd);


			for(;;)
			{
				temp_str = strtok_r(NULL, "\n", &v6_str);
				if(temp_str == NULL || temp_str[0] == '\0')
					break;

				DPRINT_INFO(WFA_OUT, "dhcp_ipv6 %s\n", temp_str);

				sprintf(gCmdStr, "busybox-full ifconfig %s del %s \n", ifname, temp_str);
				puts("\n\t");
				puts(gCmdStr);
				system(gCmdStr);

				buzz_time(3000000);

				sprintf(gCmdStr, "busybox-full ifconfig %s add %s \n", ifname, temp_str);
				puts("\n\t");
				puts(gCmdStr);
				system(gCmdStr);
			
			}

			fclose(tmpfd);

		}
		// set ipv6 manually END
#endif		
	}
	else if(g_ipconfig_isSet == 1) {

			if(g_ipconfig.type != 2){	//ipv4
	
#if (!defined MTK_P2P_SUPPLICANT) && (!defined MTK_HS20_SIGMA)
			   sprintf(gCmdStr, "/sbin/ifconfig %s %s netmask %s > /dev/null 2>&1 ", g_ipconfig.intf, g_ipconfig.ipaddr, g_ipconfig.mask);
#else
			   sprintf(gCmdStr, "ifconfig %s %s netmask %s > /dev/null 2>&1 ", g_ipconfig.intf, g_ipconfig.ipaddr, g_ipconfig.mask);
#endif
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
	
			   /* use command 'route add' to set set gatewway (linux specific) */
			   if(g_ipconfig.defGateway[0] != '\0')
			   {
#if (!defined MTK_P2P_SUPPLICANT) && (!defined MTK_HS20_SIGMA)
				  sprintf(gCmdStr, "/sbin/route add default gw %s > /dev/null 2>&1", g_ipconfig.defGateway);
#else
				  sprintf(gCmdStr, "/system/bin/route add default gw %s > /dev/null 2>&1", g_ipconfig.defGateway);
#endif
				  DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
				  system(gCmdStr);
			   }
	
#if (!defined MTK_P2P_SUPPLICANT) && (!defined MTK_HS20_SIGMA)
			   /* set dns (linux specific) */
			   sprintf(gCmdStr, "cp /etc/resolv.conf /tmp/resolv.conf.bk");
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
			   sprintf(gCmdStr, "echo nameserv %s > /etc/resolv.conf", g_ipconfig.pri_dns);
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
			   sprintf(gCmdStr, "echo nameserv %s >> /etc/resolv.conf", g_ipconfig.sec_dns);
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
#else
			   sprintf(gCmdStr, "setprop dhcp.%s.dns1 %s", g_ipconfig.intf, g_ipconfig.pri_dns);
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
			   sprintf(gCmdStr, "setprop dhcp.%s.dns2 %s", g_ipconfig.intf, g_ipconfig.sec_dns);
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
			   sprintf(gCmdStr, "setprop net.dns1 %s", g_ipconfig.pri_dns);
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
			   sprintf(gCmdStr, "setprop net.dns2 %s", g_ipconfig.sec_dns);
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
	
#endif
			}
			else {	//ipv6

				FILE *tmpfd;

				sprintf(gCmdStr, "busybox-full ifconfig %s |grep inet6 | cut -d \" \" -f 13 > /data/asec/ipconfig.txt \n", g_ipconfig.intf);
				puts("\n\t");
				puts(gCmdStr);
				system(gCmdStr);

				tmpfd = fopen("/data/asec/ipconfig.txt", "r+");

				if(tmpfd == NULL){
					DPRINT_ERR(WFA_ERR, "file open failed\n");
				}
				else {
					int idx, str_idx = 0;
					char v6_str[256];
					DPRINT_ERR(WFA_ERR, "[PUFF 1]\n");
					for(;;)
					{
						DPRINT_ERR(WFA_ERR, "[PUFF 2]\n");
						if(fscanf(tmpfd, "%s", v6_str) != EOF)
						{
							DPRINT_ERR(WFA_ERR, "[PUFF 3]\n");
							DPRINT_INFO(WFA_OUT, "dhcp_ipv6 %s\n", v6_str);

							sprintf(gCmdStr, "busybox-full ifconfig %s del %s \n", g_ipconfig.intf, v6_str);
							puts("\n\t");
							puts(gCmdStr);
							system(gCmdStr);

							buzz_time(1000000);

							sprintf(gCmdStr, "busybox-full ifconfig %s add %s \n", g_ipconfig.intf, v6_str);
							puts("\n\t");
							puts(gCmdStr);
							system(gCmdStr);

						}
						else {
							 break;
						}
					}

					if(tmpfd != NULL)
						fclose(tmpfd);

				}

				sprintf(gCmdStr, "busybox-full ifconfig %s add %s \n", g_ipconfig.intf, g_ipconfig.ipaddr);
				puts("\n\t");
				puts(gCmdStr);
				system(gCmdStr);				
	
			}

	}
	
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_HS20_STA_HS2_ASSOCIATE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
   
   return WFA_SUCCESS;
}
#endif


/*
 * wfaStaHs20StaHs2Associate():
 */
int wfaStaHs20StaHs2Associate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCommand_t *staHs2Associate = (dutCommand_t *)caCmdBuf;
	char *ifname = staHs2Associate->intf;
	dutCmdResponse_t infoResp;

	FILE *tmpfile = NULL;
	FILE *tmpfile1 = NULL;
	char temp_str[256] = "";
	char temp_str1[4] = "";
	char *str;
	char ssid[WFA_SSID_NAME_LEN];
	char bssid[18];
	char *tmpfilename = TMP_ASEC_PATH"staHs2Assoc.txt";
	char *tmpfilename1 = TMP_ASEC_PATH"scanlock.txt";
	int i=0, j=0;
	int assoc_rnd = 60;
	int scan_fail = 0;
	int fg_bssid = 0;
	int fg_ssid = 0;

	DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __func__);

	MTK_HS20_CMD("-i %s ap_scan 1 ", ifname);

#if 1
	//Disable network
	MTK_HS20_CMD("-i %s disable_network all\n", ifname);
	MTK_HS20_CMD("-i %s set auto_interworking 0 \n", ifname);
	//MTK_HS20_CMD("-i %s scan", ifname);
	buzz_time(3000000);
	MTK_HS20_CMD("-i %s enable_network all\n", ifname);
	
#endif

	//scan_lock
	// No need while normal mode. Enable while attending plugfest
#if 0	
	for(i=0; i<10; i++){
		DPRINT_INFO(WFA_OUT, "Round %d...", i);
		MTK_HS20_CMD("-i %s lock_hs20_scan | grep RESULT | cut -f 2 -d ':'  > %s \n", ifname, tmpfilename1);
		tmpfile1 = fopen(tmpfilename1, "r+");
		if ((tmpfile1 == NULL)||(fscanf(tmpfile1, "%s", temp_str1) == EOF)){
			printf("fail scan_lock file: %s \n", tmpfilename1);
			infoResp.status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_HS20_STA_HS2_ASSOCIATE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			fclose(tmpfile1);
			return WFA_FAILURE;
		}

		if(strncmp(temp_str1, "PASS", 4) == 0){
			DPRINT_INFO(WFA_OUT, "SCAN_LOCK PASS\n");
			scan_fail = 0;
			break;
		}
		else if(strncmp(temp_str1, "FAIL", 4) == 0){
			DPRINT_INFO(WFA_OUT, "SCAN_LOCK FAIL\n");
			scan_fail = 1;
			MTK_HS20_CMD("scan \n");
			buzz_time(1000000);
		}
		else {
			printf("fail scan_lock return status: %s \n", temp_str1);
			infoResp.status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_HS20_STA_HS2_ASSOCIATE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			fclose(tmpfile1);
			return WFA_FAILURE;
		}
		fclose(tmpfile1);
	}
#endif	

	// Enable network
	//MTK_HS20_CMD("-i %s enable_network all\n", ifname);
/*
	if(scan_fail == 1){
		printf("Scan fail!!!\n");
		infoResp.status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_HS20_STA_HS2_ASSOCIATE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;
		return WFA_FAILURE;
	}
*/

	//StaHs2Associate
	{
		//MTK_HS20_CMD("-i %s sta_hs2_associate \n", ifname);
		MTK_HS20_CMD("-i %s set auto_interworking 1 \n", ifname);
		MTK_HS20_CMD("-i %s save_config", ifname);
		printf("running...\n");
		//buzz_time(30000000);
		//printf("done!!!\n");
		//sprintf(gCmdStr, " echo -e \"ssid=1234\\nbssid=11:22:33:44:55:66\" > %s \n", tmpfilename);
		//DPRINT_INFO(WFA_OUT, "%s", gCmdStr);
   		//system(gCmdStr);
	}

	//Get current association status
	for(j=1; j<=assoc_rnd; j++){
		printf("Get current association status...(%d)\n", j);
		buzz_time(1000000);

		if(j == assoc_rnd){
			goto assoc_fail;
		}
		
		if(wfaStaCheckIsConnected(ifname) == 0){
			continue;
		}
		
		MTK_HS20_CMD("-i %s get_curr_assoc > %s \n", ifname, tmpfilename);
		tmpfile = fopen(tmpfilename, "r+");
		if (tmpfile == NULL) {
			printf("fail: %s \n", tmpfilename);
			infoResp.status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_HS20_STA_HS2_ASSOCIATE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			if(tmpfile != NULL)
				fclose(tmpfile);
			return WFA_FAILURE;
		}

		infoResp.cmdru.staHs2Assoc.ssid[0] = '\0';
		infoResp.cmdru.staHs2Assoc.bssid[0] = '\0';
		for(;;)
		{
			if(fscanf(tmpfile, "%s", temp_str) == EOF)
			{
				printf("No connection...\n");
				goto assoc_fail;
#if 0			
				if(strncmp(temp_str, "FAIL", 4) == 0)
						goto loop_get_assoc;
				
				if((infoResp.cmdru.staHs2Assoc.ssid[0] == '\0') ||
					(infoResp.cmdru.staHs2Assoc.bssid[0] == '\0')){
					printf("fail result: ssid = %s \n", infoResp.cmdru.staHs2Assoc.ssid);
					printf("fail result: bssid = %s \n", infoResp.cmdru.staHs2Assoc.bssid);
					infoResp.status = STATUS_ERROR;
					wfaEncodeTLV(WFA_STA_HS20_STA_HS2_ASSOCIATE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
					*respLen = WFA_TLV_HDR_LEN + 4;
					return WFA_FAILURE;
				} else {
					goto loop_get_assoc;
				}
				break;
#endif				
			}

			if(strncmp(temp_str, "bssid", 5) == 0)
			{
				str = strtok(temp_str, "=");
				str = strtok(NULL, "=");
				if(str != NULL)
				{
					strcpy(infoResp.cmdru.staHs2Assoc.bssid, str);
					infoResp.cmdru.staHs2Assoc.bssid[17] = '\0';
				}
				printf("bssid = %s \n", infoResp.cmdru.staHs2Assoc.bssid);
				fg_bssid = 1;
			}

			if(strncmp(temp_str, "ssid", 4) == 0)
			{
				str = strtok(temp_str, "=");
				str = strtok(NULL, "=");
				if(str != NULL)
				{
					strcpy(infoResp.cmdru.staHs2Assoc.ssid, str);
					infoResp.cmdru.staHs2Assoc.ssid[WFA_SSID_NAME_LEN-1] = '\0';
				}
				printf("ssid = %s \n", infoResp.cmdru.staHs2Assoc.ssid);
				fg_ssid = 1;
			}

			if(fg_bssid == 1 && fg_ssid == 1){
				goto assoc_done;
			}
		}
assoc_fail:
		{
			printf("Assoc status failed after (%d) sec ... \n", j);
			infoResp.status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_HS20_STA_HS2_ASSOCIATE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			return WFA_FAILURE;	
		}	
	}	

assoc_done:
	if(tmpfile != NULL)
		fclose(tmpfile);

	//Resume scan
	//MTK_HS20_CMD("-i %s ap_scan 1 ", ifname);
	//MTK_HS20_CMD("-i %s scan", ifname);

	buzz_time(3000000);

	if(fgIsDhcpOn) {
		FILE *tmpfd;
		char ipv6addr[WFA_IP_V6_ADDR_STR_LEN];
		
		printf("Requesting DHCP IP!\n");
		system("netcfg wlan0 dhcp");

		printf("Acquiring dhcp");
		for(j=1; j<=10; j++){
			printf(".", j);
			buzz_time(1500000);
		}
		printf("\n");

		printf("DHCP DONE!\n");


#if 0
		// set ipv6 manually START		
    	sprintf(gCmdStr, "busybox-full ifconfig %s |grep inet6 | cut -d \" \" -f 13 > /data/asec/ipconfig.txt \n", ifname);
		puts("\n\t");
		puts(gCmdStr);
		system(gCmdStr);
		
		tmpfd = fopen("/data/asec/ipconfig.txt", "r+");
		
		if(tmpfd == NULL){
			DPRINT_ERR(WFA_ERR, "file open failed\n");
		}
		else {
			int idx, str_idx = 0;
			char v6_str[256], *temp_str;

			fgets(v6_str, 256, tmpfd);


			for(;;)
			{
				temp_str = strtok_r(NULL, "\n", &v6_str);
				if(temp_str == NULL || temp_str[0] == '\0')
					break;

				DPRINT_INFO(WFA_OUT, "dhcp_ipv6 %s\n", temp_str);

				sprintf(gCmdStr, "busybox-full ifconfig %s del %s \n", ifname, temp_str);
				puts("\n\t");
				puts(gCmdStr);
				system(gCmdStr);

				buzz_time(3000000);

				sprintf(gCmdStr, "busybox-full ifconfig %s add %s \n", ifname, temp_str);
				puts("\n\t");
				puts(gCmdStr);
				system(gCmdStr);
			
			}

			fclose(tmpfd);

		}
		// set ipv6 manually END
#endif		
	}
	else if(g_ipconfig_isSet == 1) {

			if(g_ipconfig.type != 2){	//ipv4
	
#if (!defined MTK_P2P_SUPPLICANT) && (!defined MTK_HS20_SIGMA)
			   sprintf(gCmdStr, "/sbin/ifconfig %s %s netmask %s > /dev/null 2>&1 ", g_ipconfig.intf, g_ipconfig.ipaddr, g_ipconfig.mask);
#else
			   sprintf(gCmdStr, "ifconfig %s %s netmask %s > /dev/null 2>&1 ", g_ipconfig.intf, g_ipconfig.ipaddr, g_ipconfig.mask);
#endif
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
	
			   /* use command 'route add' to set set gatewway (linux specific) */
			   if(g_ipconfig.defGateway[0] != '\0')
			   {
#if (!defined MTK_P2P_SUPPLICANT) && (!defined MTK_HS20_SIGMA)
				  sprintf(gCmdStr, "/sbin/route add default gw %s > /dev/null 2>&1", g_ipconfig.defGateway);
#else
				  sprintf(gCmdStr, "/system/bin/route add default gw %s > /dev/null 2>&1", g_ipconfig.defGateway);
#endif
				  DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
				  system(gCmdStr);
			   }
	
#if (!defined MTK_P2P_SUPPLICANT) && (!defined MTK_HS20_SIGMA)
			   /* set dns (linux specific) */
			   sprintf(gCmdStr, "cp /etc/resolv.conf /tmp/resolv.conf.bk");
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
			   sprintf(gCmdStr, "echo nameserv %s > /etc/resolv.conf", g_ipconfig.pri_dns);
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
			   sprintf(gCmdStr, "echo nameserv %s >> /etc/resolv.conf", g_ipconfig.sec_dns);
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
#else
			   sprintf(gCmdStr, "setprop dhcp.%s.dns1 %s", g_ipconfig.intf, g_ipconfig.pri_dns);
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
			   sprintf(gCmdStr, "setprop dhcp.%s.dns2 %s", g_ipconfig.intf, g_ipconfig.sec_dns);
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
			   sprintf(gCmdStr, "setprop net.dns1 %s", g_ipconfig.pri_dns);
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
			   sprintf(gCmdStr, "setprop net.dns2 %s", g_ipconfig.sec_dns);
			   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
			   system(gCmdStr);
	
#endif
			}
			else {	//ipv6

				FILE *tmpfd;

				sprintf(gCmdStr, "/data/busybox-full ifconfig %s |grep inet6 | cut -d \" \" -f 13 > "TMP_ASEC_PATH"ipconfig.txt \n", g_ipconfig.intf);
				puts("\n\t");
				puts(gCmdStr);
				system(gCmdStr);

				tmpfd = fopen(TMP_ASEC_PATH"ipconfig.txt", "r+");

				if(tmpfd == NULL){
					DPRINT_ERR(WFA_ERR, "file open failed\n");
				}
				else {
					int idx, str_idx = 0;
					char v6_str[256];
					for(;;)
					{
						if(fscanf(tmpfd, "%s", v6_str) != EOF)
						{
							DPRINT_INFO(WFA_OUT, "dhcp_ipv6 %s\n", v6_str);

							sprintf(gCmdStr, "/data/busybox-full ifconfig %s del %s \n", g_ipconfig.intf, v6_str);
							puts("\n\t");
							puts(gCmdStr);
							system(gCmdStr);

							buzz_time(1000000);

							sprintf(gCmdStr, "/data/busybox-full ifconfig %s add %s \n", g_ipconfig.intf, v6_str);
							puts("\n\t");
							puts(gCmdStr);
							system(gCmdStr);

						}
						else {
							 break;
						}
					}

					if(tmpfd != NULL)
						fclose(tmpfd);

				}

				sprintf(gCmdStr, "/data/busybox-full ifconfig %s add %s \n", g_ipconfig.intf, g_ipconfig.ipaddr);
				puts("\n\t");
				puts(gCmdStr);
				system(gCmdStr);				
	
			}

	}
	
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_HS20_STA_HS2_ASSOCIATE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
   
   return WFA_SUCCESS;
}


/*
 * wfaStaHs20DevSendFrame():
 */
int wfaStaHs20DevSendFrame(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caDevSendFrame_t *devSendFrame = (caDevSendFrame_t *)caCmdBuf;
	char *ifname = devSendFrame->intf;
	dutCmdResponse_t infoResp;


#if MTK_TDLS_SIGMA
    dutCommand_t *cmd = (dutCommand_t *)caCmdBuf;
    caStaSendFrame_t *sf = &cmd->cmdsu.sf;
    pmfFrame_t *pmf = &sf->frameType.pmf;
    tdlsFrame_t *tdls = &sf->frameType.tdls;
#endif
	char anqp[128] = "";
	char *anqp_r;
	int fgAnqp = 0;
	char hs2_anqp[128] = "";
	char *hs2_anqp_r;
	int fgHs2Anqp = 0;
	char *hs2_test_nai = "mail.example.com";

 	DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __func__);

	// Program: TDLS
	if(strncmp(devSendFrame->prog, "TDLS", 4) == 0){
		// Type: discovery
		if(strcasecmp(devSendFrame->type, "discovery") == 0){
			MTK_HS20_CMD("-i %s tdls_discover %s \n", ifname, devSendFrame->dest);
#if MTK_TDLS_SIGMA
            MTK_TDLS_CMD( " TDLS_DISCOVER %s", devSendFrame->dest);
#endif
		}
		// Type: setup
		else if(strcasecmp(devSendFrame->type, "setup") == 0){
			MTK_HS20_CMD("-i %s tdls_setup %s \n", ifname, devSendFrame->dest);
#if MTK_TDLS_SIGMA
            MTK_TDLS_CMD( " TDLS_SETUP %s", devSendFrame->dest);
#endif
		}
		else if(strcasecmp(devSendFrame->type, "teardown") == 0){
			MTK_HS20_CMD("-i %s tdls_teardown %s \n", ifname, devSendFrame->dest);
#if MTK_TDLS_SIGMA            
            MTK_TDLS_CMD( " TDLS_TEARDOWN  %s", devSendFrame->dest);
#endif
		} 
		// Wrong parameter
		else {
			printf("Not support parameters\n");
			infoResp.status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_HS20_DEV_SEND_FRAME_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			return WFA_FAILURE;
		}
	}

    
	// Program: HS
	else if(strncmp(devSendFrame->prog, "HS2", 3) == 0 || strncmp(devSendFrame->prog, "HS2-R2", 6) == 0){
		// Type: ANQPQuery
		printf("Program is [%s]\n", devSendFrame->prog);
		if(strncmp(devSendFrame->framename, "anqpquery", 9) == 0){
			printf("Framename is [%s]\n", devSendFrame->framename);
			// Send 11u ANQP GAS
			if(devSendFrame->fg_ANQP_QUERY_LIST == 1){
				fgAnqp = 1;
				strcat(anqp, "256,");
				printf("ANQP_QUERY_LIST\n");
			}
			if(devSendFrame->fg_ANQP_CAPABILITY_LIST == 1){
				fgAnqp = 1;
				strcat(anqp, "257,");
				printf("ANQP_CAPABILITY_LIST\n");
			}
			if(devSendFrame->fg_ANQP_VENUE_NAME_INFORMATION == 1){
				fgAnqp = 1;
				strcat(anqp, "258,");
				printf("ANQP_VENUE_NAME_INFORMATION\n");
			}
			if(devSendFrame->fg_ANQP_EMERGENCY_CALL_NUMBER_INFORMATION == 1){
				fgAnqp = 1;
				strcat(anqp, "259,");
				printf("ANQP_EMERGENCY_CALL_NUMBER_INFORMATION\n");
			}
			if(devSendFrame->fg_ANQP_NETWORK_AUTHENTICATION_TYPE_INFORMATION == 1){
				fgAnqp = 1;
				strcat(anqp, "260,");
				printf("ANQP_NETWORK_AUTHENTICATION_TYPE_INFORMATION\n");
			}
			if(devSendFrame->fg_ANQP_ROAMING_CONSORTIUM_LIST == 1){
				fgAnqp = 1;
				strcat(anqp, "261,");
				printf("ANQP_ROAMING_CONSORTIUM_LIST\n");
			}
			if(devSendFrame->fg_ANQP_IP_ADDRESS_TYPE_AVAILABILITY_INFORMATION == 1){
				fgAnqp = 1;
				strcat(anqp, "262,");
				printf("ANQP_IP_ADDRESS_TYPE_AVAILABILITY_INFORMATION\n");
			}
			if(devSendFrame->fg_ANQP_NAI_REALM_LIST == 1){
				fgAnqp = 1;
				strcat(anqp, "263,");
				printf("ANQP_NAI_REALM_LIST\n");
			}
			if(devSendFrame->fg_ANQP_3GPP_CELLULAR_NETWORK_INFORMATION == 1){
				fgAnqp = 1;
				strcat(anqp, "264,");
				printf("ANQP_3GPP_CELLULAR_NETWORK_INFORMATION\n");
			}
			if(devSendFrame->fg_ANQP_AP_GEOSPATIAL_LOCATION == 1){
				fgAnqp = 1;
				strcat(anqp, "265,");
				printf("ANQP_AP_GEOSPATIAL_LOCATION\n");
			}
			if(devSendFrame->fg_ANQP_AP_CIVIC_LOCATION == 1){
				fgAnqp = 1;
				strcat(anqp, "266,");
				printf("ANQP_AP_CIVIC_LOCATION\n");
			}
			if(devSendFrame->fg_ANQP_AP_LOCATION_PUBLIC_IDENTIFIER_URI == 1){
				fgAnqp = 1;
				strcat(anqp, "267,");
				printf("ANQP_AP_LOCATION_PUBLIC_IDENTIFIER_URI\n");
			}
			if(devSendFrame->fg_ANQP_DOMAIN_NAME_LIST == 1){
				fgAnqp = 1;
				strcat(anqp, "268,");
				printf("ANQP_DOMAIN_NAME_LIST\n");
			}
			if(devSendFrame->fg_ANQP_EMERGENCY_ALERT_IDENTIFIER_URI == 1){
				fgAnqp = 1;
				strcat(anqp, "269,");
				printf("ANQP_EMERGENCY_ALERT_IDENTIFIER_URI\n");
			}
			if(devSendFrame->fg_ANQP_EMERGENCY_NAI == 1){
				fgAnqp = 1;
				strcat(anqp, "271,");
				printf("ANQP_EMERGENCY_NAI\n");
			}
			if(devSendFrame->fg_ANQP_VENDOR_SPECIFIC_LIST == 1){
				fgAnqp = 1;
				strcat(anqp, "56797,");
				printf("ANQP_VENDOR_SPECIFIC_LIST\n");
			}
			if(fgAnqp == 1){
				anqp_r = strrchr(anqp, ',');
				anqp[anqp_r-anqp] = '\0';
				MTK_HS20_CMD("-i %s anqp_get %s %s \n",
					ifname,
					devSendFrame->dest,
					anqp);
			}
			// Send HS20 ANQP GAS
			if(devSendFrame->fg_HS20_CAPABILITY_LIST == 1){
				fgHs2Anqp = 1;
				strcat(hs2_anqp, "2,");
				printf("HS20_CAPABILITY_LIST\n");
			}
			if(devSendFrame->fg_HS20_OPERATOR_FRIENDLY_NAME == 1){
				fgHs2Anqp = 1;
				strcat(hs2_anqp, "3,");
				printf("HS20_OPERATOR_FRIENDLY_NAME\n");
			}
			if(devSendFrame->fg_HS20_WAN_METRICS == 1){
				fgHs2Anqp = 1;
				strcat(hs2_anqp, "4,");
				printf("HS20_WAN_METRICS\n");
			}
			if(devSendFrame->fg_HS20_CONNECTION_CAPABILITY == 1){
				fgHs2Anqp = 1;
				strcat(hs2_anqp, "5,");
				printf("HS20_CONNECTION_CAPABILITY\n");
			}
			if(devSendFrame->fg_HS20_OP_CLASS == 1){
				fgHs2Anqp = 1;
				strcat(hs2_anqp, "7,");
				printf("HS20_OP_CLASS\n");
			}
			if(devSendFrame->fg_HS20_OSU_PROVIDER_LIST == 1){
				fgHs2Anqp = 1;
				strcat(hs2_anqp, "8,");
				printf("HS20_OSU_PROVIDER_LIST\n");
			}
			if(devSendFrame->fg_HS20_ICON_REQ == 1){
				MTK_HS20_CMD("-i %s sta_icon_req %s %s\n",
					ifname,
					devSendFrame->dest,
					devSendFrame->hs20_icon_req);
			}
			if(fgHs2Anqp == 1){
				hs2_anqp_r = strrchr(hs2_anqp, ',');
				hs2_anqp[hs2_anqp_r-hs2_anqp] = '\0';
				MTK_HS20_CMD("-i %s hs20_anqp_get %s %s\n",
					ifname,
					devSendFrame->dest,
					hs2_anqp);
			}
			if(devSendFrame->fg_HS20_NAI_HOME_REALM_QUERY == 1){
				MTK_HS20_CMD("-i %s nai_home_realm_list %s realm=%s\n",
					ifname,
					devSendFrame->dest,
					hs2_test_nai);
			}
		}
		// Type: DLSRequest
		else if(strcasecmp(devSendFrame->framename, "DLSrequest") == 0){
			MTK_HS20_CMD("-i %s send_dls_tdls 0 %s\n", ifname, devSendFrame->dest);
		}
		// Type: Gratuitous ARP Request
		else if(strncmp(devSendFrame->framename, "GARPReq", 7) == 0){
			//1 TODO given mac address arp to IP
		    sprintf(gCmdStr, "/data/busybox-full arping -I %s -c 4 -U 255.255.255.255", devSendFrame->intf);
		    printf("CS : The command string is %s\n",gCmdStr);
            system(gCmdStr);
		}
		// Type: Gratuitous ARP Response
		else if(strncmp(devSendFrame->framename, "GARPRes", 7) == 0){
			//1 TODO given mac address arp to IP
		    sprintf(gCmdStr, "/data/busybox-full arping -I %s -c 4 -A 255.255.255.255", devSendFrame->intf);
		    printf("CS : The command string is %s\n",gCmdStr);
            system(gCmdStr);
		}		
		// Type: BTM
		else if(strncmp(devSendFrame->framename, "btm", 3) == 0){
			// BTM_Qry
			MTK_HS20_CMD("-i %s set_btm_qry_reason 13 \n", ifname);
			MTK_HS20_CMD("-i %s add_nr_info 34100102030405060708090a0b0c0d0301FF \n", ifname);
			MTK_HS20_CMD("-i %s add_nr_info 34100708090a0b0c0708090a0b0c0d030101 \n", ifname);
			MTK_HS20_CMD("-i %s send_btm_qry \n", ifname);
		}
		// Type: NeighAdv
		else if(strncmp(devSendFrame->framename, "NeighAdv", 8) == 0){
        	FILE *tmpfile = NULL;
        	char *tmpfilename = TMP_ASEC_PATH"ipv6_addr.txt";
        	char temp_str[256];

		    sprintf(gCmdStr, "/data/busybox ifconfig %s | grep -e inet6 | cut -f 1 -d/ | cut -f13 -d\' \' > %s", devSendFrame->intf, tmpfilename);
		    printf("CS : The command string is %s\n",gCmdStr);
            system(gCmdStr);

            tmpfile = fopen(tmpfilename, "r+");
            if (tmpfile == NULL) {
                printf("fail: %s \n", tmpfilename);
                infoResp.status = STATUS_ERROR;
                wfaEncodeTLV(WFA_STA_HS20_DEV_SEND_FRAME_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
                *respLen = WFA_TLV_HDR_LEN + 4;
				if(tmpfile != NULL)
                	fclose(tmpfile);
                return WFA_FAILURE;
            }

            fscanf(tmpfile, "%s", temp_str);

            sprintf(gCmdStr, "/data/ndsend %s %s", temp_str, devSendFrame->intf);
            printf("CS : The command string is %s\n",gCmdStr);
            system(gCmdStr);
			if(tmpfile != NULL)
            	fclose(tmpfile);
		}
		// Type: ARPProbe
		else if(strncmp(devSendFrame->framename, "ARPProbe", 7) == 0){
			FILE *tmpfd;
			char string[256];
			char *str;
			char ipaddr[WFA_IP_ADDR_STR_LEN];

			sprintf(gCmdStr, "sh /system/bin/mtk_hs20_getipconfig.sh "TMP_ASEC_PATH"ipconfig.txt %s\n", ifname);
			puts("\n\t");
			puts(gCmdStr);

			system(gCmdStr);
			
			tmpfd = fopen(TMP_ASEC_PATH"ipconfig.txt", "r+");
			
			if(tmpfd == NULL){
				DPRINT_ERR(WFA_ERR, "file open failed\n");
			}
			else {
				for(;;)
					{
						if(fgets(string, 256, tmpfd) == NULL)
						   break;
				
						/* find out the ip address */
						if(strncmp(string, "ipaddr", 6) == 0)
						{
							str = strtok(string, "=");
							str = strtok(NULL, " ");
							if(str != NULL)
							{
							   wSTRNCPY(ipaddr, str, 15);
							   ipaddr[15]='\0';
							}
							else {
								printf("Cannot get ipv4 for %s... \n", devSendFrame->framename);
								infoResp.status = STATUS_ERROR;
								wfaEncodeTLV(WFA_STA_HS20_DEV_SEND_FRAME_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
								*respLen = WFA_TLV_HDR_LEN + 4;
								return WFA_FAILURE;

							}
						}
					 }

				sprintf(gCmdStr, "/data/busybox-full arping -I %s -c 8 -D %s", devSendFrame->intf, ipaddr);
				printf("CS : The command string is %s\n",gCmdStr);
				system(gCmdStr);
				if(tmpfd != NULL)
					fclose(tmpfd);
			}
		}
		// Type: ARPAnnounce
		else if(strncmp(devSendFrame->framename, "ARPAnnounce", 11) == 0){
			FILE *tmpfd;
			char string[256];
			char *str;
			char ipaddr[WFA_IP_ADDR_STR_LEN];

			sprintf(gCmdStr, "sh mtk_hs20_getipconfig.sh "TMP_ASEC_PATH"ipconfig.txt %s\n", ifname);
			puts("\n\t");
			puts(gCmdStr);

			system(gCmdStr);
			
			tmpfd = fopen(TMP_ASEC_PATH"ipconfig.txt", "r+");
			
			if(tmpfd == NULL){
				DPRINT_ERR(WFA_ERR, "file open failed\n");
			}
			else {
				for(;;)
					{
						if(fgets(string, 256, tmpfd) == NULL)
						   break;
				
						/* find out the ip address */
						if(strncmp(string, "ipaddr", 6) == 0)
						{
							str = strtok(string, "=");
							str = strtok(NULL, "\n");
							if(str != NULL)
							{
							   wSTRCPY(ipaddr, str);
							}
							else {
								printf("Cannot get ipv4 for %s... \n", devSendFrame->framename);
								infoResp.status = STATUS_ERROR;
								wfaEncodeTLV(WFA_STA_HS20_DEV_SEND_FRAME_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
								*respLen = WFA_TLV_HDR_LEN + 4;
								return WFA_FAILURE;

							}
						}
					 }
		
				sprintf(gCmdStr, "/data/busybox-full arping -I %s -c 8 -s %s %s", devSendFrame->intf, ipaddr, ipaddr);
				printf("CS : The command string is %s\n",gCmdStr);
				system(gCmdStr);
				if(tmpfd != NULL)
					fclose(tmpfd);
			
			}
		}
		// Type: ARPReply
		else if(strncmp(devSendFrame->framename, "ARPReply", 8) == 0){
			FILE *tmpfd;
			char string[256];
			char *str;
			char ipaddr[WFA_IP_ADDR_STR_LEN];
			int j;

			sprintf(gCmdStr, "sh mtk_hs20_getipconfig.sh "TMP_ASEC_PATH"ipconfig.txt %s\n", ifname);
			puts("\n\t");
			puts(gCmdStr);

			system(gCmdStr);
			
			tmpfd = fopen(TMP_ASEC_PATH"ipconfig.txt", "r+");
			
			if(tmpfd == NULL){
				DPRINT_ERR(WFA_ERR, "file open failed\n");
			}
			else {
				for(;;)
					{
						if(fgets(string, 256, tmpfd) == NULL)
						   break;
				
						/* find out the ip address */
						if(strncmp(string, "ipaddr", 6) == 0)
						{
							str = strtok(string, "=");
							str = strtok(NULL, "\n");
							if(str != NULL)
							{
							   wSTRCPY(ipaddr, str);
							}
							else {
								printf("Cannot get ipv4 for %s... \n", devSendFrame->framename);
								infoResp.status = STATUS_ERROR;
								wfaEncodeTLV(WFA_STA_HS20_DEV_SEND_FRAME_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
								*respLen = WFA_TLV_HDR_LEN + 4;
								return WFA_FAILURE;

							}
						}
					 }
				
				MTK_HS20_CMD("-i %s set_fake_arprsp 1 %s %s\n",
					devSendFrame->intf,
					devSendFrame->SenderMac,
					devSendFrame->dest);

				printf("Setting Fake Arp Reply");
				for(j=1; j<=3; j++){
					printf(".", j);
					buzz_time(1000000);
				}
				printf("\n");
		
				sprintf(gCmdStr, "/data/busybox-full arping -I %s -A -c 8 -s %s %s", devSendFrame->intf, ipaddr, devSendFrame->DestIP);
				printf("CS : The command string is %s\n",gCmdStr);
				system(gCmdStr);
				if(tmpfd != NULL)
					fclose(tmpfd);

				MTK_HS20_CMD("-i %s set_fake_arprsp 0 \n",
					devSendFrame->intf);				
			
			}
		}		
		// Type: NeighSolicitReq
		else if(strncmp(devSendFrame->framename, "NeighSolicitReq", 15) == 0){
			printf("NeighSolicitReq can be sent automatically...\n");
		}
		// Type: others are not support
		else {
			printf("Not supported type: %s \n", devSendFrame->framename);
			infoResp.status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_HS20_DEV_SEND_FRAME_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			return WFA_FAILURE;
		}
	}
	// Program: others are not support
	else {
		printf("Not supported program: %s \n", devSendFrame->prog);
		infoResp.status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_HS20_DEV_SEND_FRAME_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;
		return WFA_FAILURE;
	}

	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_HS20_DEV_SEND_FRAME_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

	DPRINT_INFO(WFA_OUT, "Leaving %s ...\n", __func__);

	return WFA_SUCCESS;

}


/*
 * wfaStaHs20StaAddCredential():
 */
int wfaStaHs20StaAddCredential(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	caStaAddCredential_t *staAddCred= (caStaAddCredential_t *)caCmdBuf;
	char *ifname = staAddCred->intf;
	char *anonymous_id = "anonymous@mail.example.com";
    FILE *fd;
    char *filename = TMP_ASEC_PATH"cred_idx.txt";
    char idx[16];
    int idx_i;

	DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __func__);
	
	MTK_HS20_CMD("-i %s enable_sw_sim\n", staAddCred->intf);

#if 0
	{
		// -w1: enable PMF, -w0: disable PMF
		MTK_HS20_CMD("-i %s sta_add_cred%s%s%s%s%s%s%s%s%s%s%s -w1\n",
			staAddCred->intf,
			(staAddCred->type[0] == '\0')?"":strcat(type_t,staAddCred->type),
			(staAddCred->username[0] == '\0')?"":strcat(username_t,staAddCred->username),
			(staAddCred->password[0] == '\0')?"":strcat(password_t,staAddCred->password),
			(staAddCred->imsi[0] == '\0')?"":strcat(imsi_t,staAddCred->imsi),
			(staAddCred->plmn_mnc[0] == '\0')?"":strcat(plmn_mnc_t,staAddCred->plmn_mnc),
			(staAddCred->plmn_mcc[0] == '\0')?"":strcat(plmn_mcc_t,staAddCred->plmn_mcc),
			(staAddCred->root_ca[0] == '\0')?"":strcat(root_ca_t,staAddCred->root_ca),
			(staAddCred->realm[0] == '\0')?"":strcat(realm_t,staAddCred->realm),
			(staAddCred->prefer == 1)? " -f1":" -f0",
			(staAddCred->fqdn[0] == '\0')?"":strcat(fqdn_t,staAddCred->fqdn),
			(staAddCred->clientCA[0] == '\0')?"":strcat(clientCA_t,staAddCred->clientCA)
			);
		MTK_HS20_CMD("-i %s enable_sw_sim\n", staAddCred->intf);
		
	}
#else 

	// Add a credential
	MTK_HS20_CMD("-i %s add_cred > %s", ifname, filename);
	// Get network index
	fd = fopen(filename, "r+");
	if ((NULL == fd) || (NULL == fgets(idx, 16, fd))) {
		printf("fail: %s \n", filename);
		infoResp.status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_HS20_STA_ADD_CREDENTIAL_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
		return WFA_FAILURE;
	}
	else {
		idx_i = atoi(idx);
		DPRINT_INFO(WFA_OUT, "[%s]The credential index is [%d]", __func__, idx_i);
	}

#if 0
	if(staAddCred->type[0] != '\0'){
		if(strncmp(staAddCred->type, "uname_pwd", 9) == 0){
			MTK_HS20_CMD("-i %s set_cred %d eap '\"%s\"'", ifname, idx_i, "TTLS");
		}
	}
#endif

	if(staAddCred->username[0] != '\0'){
		MTK_HS20_CMD("-i %s set_cred %d username '\"%s\"'", ifname, idx_i, staAddCred->username);
	}

	if(staAddCred->password[0] != '\0'){
		if(strncmp(staAddCred->type, "sim", 3) == 0){
			MTK_HS20_CMD("-i %s set_cred %d milenage '\"%s\"'", ifname, idx_i, staAddCred->password);
		}
		else {
			MTK_HS20_CMD("-i %s set_cred %d password '\"%s\"'", ifname, idx_i, staAddCred->password);
		}
	}

	if(staAddCred->imsi[0] != '\0'){
		MTK_HS20_CMD("-i %s set_cred %d imsi '\"%s%s-%s\"'", ifname, idx_i, 
			staAddCred->plmn_mcc, 
			staAddCred->plmn_mnc, 
			staAddCred->imsi + strlen(staAddCred->plmn_mcc) + strlen(staAddCred->plmn_mnc));
	}
	
	if(staAddCred->root_ca[0] != '\0'){
		MTK_HS20_CMD("-i %s set_cred %d ca_cert '\"/data/misc/wifi/%s\"'", ifname, idx_i, staAddCred->root_ca);
	}
	
	if(staAddCred->clientCA[0] != '\0'){
		MTK_HS20_CMD("-i %s set_cred %d client_cert '\"/data/misc/wifi/%s\"'", ifname, idx_i, staAddCred->clientCA);
		MTK_HS20_CMD("-i %s set_cred %d private_key '\"/data/misc/wifi/%s\"'", ifname, idx_i, staAddCred->clientCA);
	}

	if(staAddCred->realm[0] != '\0'){
		MTK_HS20_CMD("-i %s set_cred %d realm '\"%s\"'", ifname, idx_i, staAddCred->realm);
	}

	if(staAddCred->prefer == 1){
		MTK_HS20_CMD("-i %s set_cred %d priority %d", ifname, idx_i, staAddCred->prefer);
	}

	if(staAddCred->fqdn[0] != '\0'){
		MTK_HS20_CMD("-i %s set_cred %d domain '\"%s\"'", ifname, idx_i, staAddCred->fqdn);
	}		

	// Save config
	MTK_HS20_CMD("-i %s save_config", ifname);

	fclose(fd);

#endif

    infoResp.status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_HS20_STA_ADD_CREDENTIAL_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

    return WFA_SUCCESS;
}


/*
 * wfaStaHs20StaScan():
 */
int wfaStaHs20StaScan(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{

	dutCmdResponse_t infoResp;
	caStaScan_t *staScan= (caStaScan_t *)caCmdBuf;
	int j=0;

	char hessid_t[WFA_HS20_LEN_64] = " -h";
	char accs_net_type_t[WFA_HS20_LEN_64] = " -a";

	DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __func__);

	MTK_HS20_CMD("-i %s ap_scan 0 ", staScan->intf);

	if((staScan->hessid[0] != '\0') || (staScan->accs_net_type[0] != '\0')){
		MTK_HS20_CMD("-i %s sta_add_scan_info%s%s\n",
			staScan->intf,
			(staScan->hessid[0] == '\0')?"":strcat(hessid_t,staScan->hessid),
			(staScan->accs_net_type[0] == '\0')?"":strcat(accs_net_type_t,staScan->accs_net_type)
		);
	}
	
    printf("Setting Scan Info");
	for(j=1; j<=5; j++){
		printf(".", j);
		buzz_time(1000000);
	}
	printf("\n");

	MTK_HS20_CMD("-i %s ap_scan 1 ", staScan->intf);
	MTK_HS20_CMD("-i %s scan", staScan->intf);

   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_HS20_STA_SCAN_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}


/*
 * wfaStaHs20DevSetParameter():
 */
int wfaStaHs20DevSetParameter(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{

	dutCmdResponse_t infoResp;
	caDevSetParameter_t *DevSetParameter= (caDevSetParameter_t *)caCmdBuf;

	DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __func__);

	FILE *tmpfile = NULL;
	char *tmpfilename = TMP_ASEC_PATH"hs20_dev_set_parameter";

	DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __func__);

	{
		char str[64];
		
		// Clean up ARP
		if(DevSetParameter->clearARP == 1){
			sprintf(gCmdStr, "arp -a | cut -f 2 -d '(' | cut -f 1 -d ')' > %s \n", tmpfilename);
			DPRINT_INFO(WFA_OUT, "%s", gCmdStr);
				system(gCmdStr);

			tmpfile = fopen(tmpfilename, "r+");

			for(;;){
				if(fgets(str, 64, tmpfile) == NULL)
					break;
				else {
					sprintf(gCmdStr, "arp -i %s -d %s \n", DevSetParameter->intf, str);
					DPRINT_INFO(WFA_OUT, "%s", gCmdStr);
						system(gCmdStr);
				}
			}			
			if(tmpfile != NULL)
				fclose(tmpfile);
		}

	}

   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_HS20_DEV_SET_PARAMETER_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}


/*
 * wfaStaHs20DevGetParameter():
 */
int wfaStaHs20DevGetParameter(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   return WFA_FAILURE;
}


/*
 * wfaStaHs20StaOSU():
 */
int wfaStaHs20StaOSU(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	caStaOSU_t *StaOSU = (caStaOSU_t *)caCmdBuf;
	int i=0, j=0;
	int osu_rnd = 300;
	int assoc_rnd = 60;
	char temp_str[32];

	char *str;
	char ssid[WFA_SSID_NAME_LEN];
	char bssid[18];
	int fg_bssid = 0;
	int fg_ssid = 0;	

	DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __func__);

	FILE *tmpfile = NULL;
	char *tmpfilename = TMP_ASEC_PATH"hs20_get_osu_complete";
	char *tmpfilename2 = TMP_ASEC_PATH"hs20_get_osu_status";

	infoResp.cmdru.staHs2Assoc.ssid[0] = '\0';
	infoResp.cmdru.staHs2Assoc.bssid[0] = '\0';

	// set_osu_connect
	{
		MTK_HS20_CMD("-i %s sta_hs2_associate \n", StaOSU->intf);
		MTK_HS20_CMD("-i %s set_osu_connect %s \n", StaOSU->intf, StaOSU->fname);
	}

	//get_osu_complete
	for(j=1; j<=osu_rnd; j++){
		printf("Get osu status...(%d)\n", j);
		buzz_time(1000000);
		MTK_HS20_CMD("-i %s get_osu_complete > %s \n", StaOSU->intf, tmpfilename);
		tmpfile = fopen(tmpfilename, "r+");
		if (tmpfile == NULL) {
			printf("fail: %s \n", tmpfilename);
			goto OSU_FAIL;
		}

		for(;;){
			if(fgets(temp_str, 32, tmpfile) == NULL)
				break;
			else {
				if(strncmp(temp_str, "OSU_FAILED", 10) == 0){
					DPRINT_INFO(WFA_OUT, "OSU is FAILED...\n");
					goto OSU_FAIL;
				}
				if(strncmp(temp_str, "OSU_SUCCESS", 11) == 0){
					DPRINT_INFO(WFA_OUT, "Subscription SUCCESS!!!\n");
					goto OSU_SUCCESS;
				}
			}
		}

	}	

	DPRINT_INFO(WFA_OUT, "OSU is TIMEOUT(%d)...\n", j);
	goto OSU_FAIL;
	
OSU_SUCCESS:
	
	printf("Disconnect Legacy");
	for(j=1; j<=3; j++){
		printf(".", j);
		buzz_time(1000000);
	}
	printf("\n");
	
	//Get current association status
	for(j=1; j<=assoc_rnd; j++){
		printf("Get current association status...(%d)\n", j);
		buzz_time(1000000);
		MTK_HS20_CMD("-i %s get_curr_assoc > %s \n", StaOSU->intf, tmpfilename2);
		tmpfile = fopen(tmpfilename2, "r+");
		if (tmpfile == NULL) {
			printf("fail: %s \n", tmpfilename2);
			goto OSU_FAIL;
		}

		for(;;)
		{
			if(fscanf(tmpfile, "%s", temp_str) == EOF)
			{
				printf("Not ready...\n");
				if(strncmp(temp_str, "FAIL", 4) == 0){
					if(j >= assoc_rnd){
						goto OSU_FAIL;
					}
					else{
						break;
					}
				}
			}

			if(strncmp(temp_str, "bssid", 5) == 0)
			{
				str = strtok(temp_str, "=");
				str = strtok(NULL, "=");
				printf("bssid = %s \n", str);
				if(str != NULL)
				{
					strcpy(infoResp.cmdru.staHs2Assoc.bssid, str);
					infoResp.cmdru.staHs2Assoc.bssid[17] = '\0';
				}
				fg_bssid = 1;
			}

			if(strncmp(temp_str, "ssid", 4) == 0)
			{
				str = strtok(temp_str, "=");
				str = strtok(NULL, "=");
				printf("ssid = %s \n", str);
				if(str != NULL)
				{
					strcpy(infoResp.cmdru.staHs2Assoc.ssid, str);
					infoResp.cmdru.staHs2Assoc.ssid[WFA_SSID_NAME_LEN-1] = '\0';
				}				
				fg_ssid = 1;
			}

			if(fg_bssid == 1 && fg_ssid == 1){
				goto osu_assoc_done;
			}

		}

	}

osu_assoc_done:
    infoResp.status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_HS20_STA_OSU_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	if(tmpfile != NULL)
		fclose(tmpfile);
    return WFA_SUCCESS;

OSU_FAIL:
	infoResp.status = STATUS_COMPLETE;
	infoResp.cmdru.staHs2Assoc.ssid[0] = '\0';
	infoResp.cmdru.staHs2Assoc.bssid[0] = '\0';
	wfaEncodeTLV(WFA_STA_HS20_STA_OSU_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	if(tmpfile != NULL)
		fclose(tmpfile);
	return WFA_FAILURE;	
		
}


int wfaStaHs20StaPolicyUpdate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *dutCmd = (dutCommand_t *)caCmdBuf;
   caStaPolicyUpdate_t *staPU = (caStaPolicyUpdate_t *)caCmdBuf;
   dutCmdResponse_t *caResp = &gGenericResp;
   char *intf = dutCmd->intf;

#if defined MTK_HS20_SIGMA & 0
	if(strcasecmp(rfeat->prog, "HS2-R2") == 0)
	{
		if((strlen(rfeat->username) > 0) && (strlen(rfeat->password) > 0)){
			DPRINT_INFO(WFA_OUT, "%s, Set Username(%s) Password(%s) for User remediation ...\n", 
				__func__, 
				rfeat->username,
				rfeat->password);
			MTK_HS20_CMD("-i %s set_uname_passwd %s %s\n",
				dutCmd->intf,
				rfeat->username,
				rfeat->password);
		}

	
		DPRINT_INFO(WFA_OUT, "%s, Policy Update %d ...\n", __func__, rfeat->policyupdate);	
		MTK_HS20_CMD("-i %s set_policy_update %d\n",
			dutCmd->intf,
			rfeat->policyupdate);
	}
#endif

   caResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_RFEATURE_RESP_TLV, 4, (BYTE *)caResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

#endif
