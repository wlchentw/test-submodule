
/****************************************************************************
 *  (c) Copyright 2007 Wi-Fi Alliance.  All Rights Reserved
 *
 *
 *  LICENSE
 *
 *  License is granted only to Wi-Fi Alliance members and designated
 *  contractors ($B!H(BAuthorized Licensees$B!I(B)..AN  Authorized Licensees are granted
 *  the non-exclusive, worldwide, limited right to use, copy, import, export
 *  and distribute this software:
 *  (i) solely for noncommercial applications and solely for testing Wi-Fi
 *  equipment; and
 *  (ii) solely for the purpose of embedding the software into Authorized
 *  Licensee$B!G(Bs proprietary equipment and software products for distribution to
 *  its customers under a license with at least the same restrictions as
 *  contained in this License, including, without limitation, the disclaimer of
 *  warranty and limitation of liability, below..AN  The distribution rights
 *  granted in clause
 *  (ii), above, include distribution to third party companies who will
 *  redistribute the Authorized Licensee$B!G(Bs product to their customers with or
 *  without such third party$B!G(Bs private label. Other than expressly granted
 *  herein, this License is not transferable or sublicensable, and it does not
 *  extend to and may not be used with non-Wi-Fi applications..AN  Wi-Fi Alliance
 *  reserves all rights not expressly granted herein..AN
 *.AN
 *  Except as specifically set forth above, commercial derivative works of
 *  this software or applications that use the Wi-Fi scripts generated by this
 *  software are NOT AUTHORIZED without specific prior written permission from
 *  Wi-Fi Alliance.
 *.AN
 *  Non-Commercial derivative works of this software for internal use are
 *  authorized and are limited by the same restrictions; provided, however,
 *  that the Authorized Licensee shall provide Wi-Fi Alliance with a copy of
 *  such derivative works under a perpetual, payment-free license to use,
 *  modify, and distribute such derivative works for purposes of testing Wi-Fi
 *  equipment.
 *.AN
 *  Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 *  or promote products that are derived from or that use this software without
 *  specific prior written permission from Wi-Fi Alliance.
 *
 *  THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A.AN PARTICULAR PURPOSE,
 *  ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
 *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ******************************************************************************
 */
/*
 *      File: wfa_cmdproc.c
 *      Library functions to handle all string command parsing and convert it
 *      to an internal format for DUT. They should be called by Control Agent
 *      and Test console while receiving commands from CLI or TM
 *
 *      Revision History:
 *        2006/03/10  -- initially created by qhu
 *        2006/06/01    -- BETA release by qhu
 *        2006/06/13    -- 00.02 release by qhu
 *        2006/06/30    -- 00.10 Release by qhu
 *        2006/07/10  -- 01.00 Release by qhu
 *        2006/08/30  -- add some print statements by Isaac in Epson.
 *        2006/09/01  -- 01.05 release by qhu
 *        2006/10/26    -- 01.06 release by qhu
 *        2006/12/02    -- bug fix reported by p.schwan
 *        2007/01/11    -- 01.10 release by qhu
 *        2007/02/15  -- WMM Extension Beta released by qhu, mkaroshi
 *        2007/03/30  -- 01.40 WPA2 and Official WMM Beta Release by qhu
 *        2007/04/20  -- 02.00 WPA2 and Official WMM Release by qhu
 *        2007/08/15 --  02.10 WMM-Power Save release by qhu
 *        2007/10/10 --  02.20 Voice SOHO beta -- qhu
 *        2007/11/07 --  02.30 Voice HSO -- qhu
 *        2007/12/10 --  02.32 Add a funtion to upload test results.
 *        2008/01/03 --  02.34 Support the result upload command.
 *        2008/02/11 --  02.40 Fix the BUG 5, multiple issues.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <unistd.h>

#include <sys/socket.h>
#include "wfa_debug.h"
#include "wfa_types.h"
#include "wfa_tlv.h"
#include "wfa_tg.h"
#include "wfa_ca.h"
#include "wfa_cmds.h"
#include "wfa_miscs.h"
#include "wfa_agtctrl.h"


extern int gSock;
extern void printProfile(tgProfile_t *);
int wfaStandardBoolParsing (char *str);

/* command KEY WORD String table */
typeNameStr_t keywordStr[] =
{
    { KW_PROFILE,      "profile",       NULL},
    { KW_DIRECTION,    "direction",     NULL},
    { KW_DIPADDR,      "destination",   NULL},
    { KW_DPORT,        "destinationport",  NULL},
    { KW_SIPADDR,      "source",        NULL},
    { KW_SPORT,        "sourceport",    NULL},
    { KW_FRATE,        "framerate",     NULL},
    { KW_DURATION,     "duration",      NULL},
    { KW_PLOAD,        "payloadsize",   NULL},
    { KW_TCLASS,       "trafficClass",  NULL},    /* It is to indicate WMM traffic pattern */
    { KW_STREAMID,     "streamid",      NULL},
    { KW_STARTDELAY,   "startdelay",    NULL},     /* It is used to schedule multi-stream test such as WMM */
    { KW_NUMFRAME,     "numframes",     NULL},
    { KW_USESYNCCLOCK, "useSyncClock",  NULL},
    { KW_USERPRIORITY, "userpriority",  NULL},
    { KW_MAXCNT,       "maxcnt",        NULL},
};

/* profile type string table */
typeNameStr_t profileStr[] =
{
    { PROF_FILE_TX, "file_transfer", NULL},
    { PROF_MCAST,   "multicast",     NULL},
    { PROF_IPTV,    "iptv",          NULL},       /* This is used for WMM, confused? */
    { PROF_TRANSC,  "transaction",   NULL},       /* keep for temporary backward compat., will be removed */
    { PROF_START_SYNC,    "start_sync",    NULL},
    { PROF_CALI_RTD,    "cali_rtd",    NULL},
    { PROF_UAPSD,  "uapsd",   NULL}
};

/* direction string table */
typeNameStr_t direcStr[] =
{
    { DIRECT_SEND,  "send",          NULL},
    { DIRECT_RECV,  "receive",       NULL}
};

/*
 * cmdProcNotDefinedYet(): a dummy function
 */
int cmdProcNotDefinedYet(char *pcmdStr, char *buf, int *len)
{
    printf("The command processing function not defined.\n");

    /* need to send back a response */

    return (WFA_SUCCESS);
}

extern unsigned short wfa_defined_debug;

/*
 *  xcCmdProcGetVersion(): process the command get_version string from TM
 *                         to convert it into a internal format
 *  input:        pcmdStr -- a string pointer to the command string
 */
int xcCmdProcGetVersion(char *pcmdStr, BYTE *aBuf, int *aLen)
{

	char buf[1024];
	FILE *pp, *qq;


    DPRINT_INFO(WFA_OUT, "start xcCmdProcGetVersion ...\n");

    if(aBuf == NULL)
      return WFA_FAILURE;

    /* encode the tag without values */
    wfaEncodeTLV(WFA_GET_VERSION_TLV, 0, NULL, aBuf);

	//DPRINT_INFO(WFA_OUT, "start to run wget...\n");

	//system("notepad.exe");
	//system("wget http://192.165.21.20/home.asp --user=admin --password=admin");


/*
	if( (pp = popen("wget http://192.165.21.20/home.asp --user=admin --password=admin", "r")) == NULL )
	{
		printf("popen() error!\n");
		exit(1);
	}
	while(fgets(buf, sizeof(buf), pp))
	{
		printf("%s", buf);
	}
	pclose(pp);


	if( (qq = popen("adb push home.asp /mnt/asec/", "r")) == NULL )
	{
		printf("popen2() error!\n");
		exit(1);
	}
	while(fgets(buf, sizeof(buf), qq))
	{
		printf("%s", buf);
	}
	pclose(qq);

*/

	
	//system("/cygdrive/c/Windows/wget.exe http://192.165.21.20/home.asp --user=admin --password=admin --directory-prefix=D:\\Sigma\\MTK_STA_HS20_R2_SIGMA\\Sigma");
	//execl("C::\\Windows\\wget.exe", "wget.exe", "http://192.165.21.20/home.asp", 
    //  "--user=admin", "--password=admin", "--directory-prefix=D::\\Sigma\\MTK_STA_HS20_R2_SIGMA\\Sigma");

	//execl("C::\\WINDOWS\\SYSTEM32\\CMD.EXE", "cmd.exe", "/c", 
	//	  "echo", "foo", ">C:\\Users\\user\\Desktop\\foo.txt");

	
	//DPRINT_INFO(WFA_OUT, system("\"\"c:\\program files\\internet explorer\\iexplore.exe\" \"www.stackoverflow.com\"\""));


    *aLen = 4;

    return WFA_SUCCESS;
}

/*
 *  xcCmdProcAgentConfig(): process the command traffic_agent_config string
 *                          from TM to convert it into a internal format
 *  input:        pcmdStr -- a string pointer to the command string
 */
int xcCmdProcAgentConfig(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    char *str;
    int i = 0, j=0, kwcnt = 0;
    wfaTLV *hdr = (wfaTLV *)aBuf;
    tgProfile_t tgpf = {0, 0, "", -1, "", -1, 0, 0, 0, TG_WMM_AC_BE, 0, 0};
    tgProfile_t *pf = &tgpf;
    int userPrio = 0;

    DPRINT_INFO(WFA_OUT, "start xcCmdProcAgentConfig ...\n");
    DPRINT_INFO(WFA_OUT, "params:  %s\n", pcmdStr);

    if(aBuf == NULL)
        return WFA_FAILURE;

    while((str = strtok_r(NULL, ",", (char **)&pcmdStr)) != NULL)
    {
       for(i = 0; i<sizeof(keywordStr)/sizeof(typeNameStr_t); i++)
       {
          if(strcasecmp(str, keywordStr[i].name) == 0)
          {
              switch(keywordStr[i].type)
              {
              case  KW_PROFILE:
              str = strtok_r(NULL, ",", (char **)&pcmdStr);
              if(isString(str) == WFA_FAILURE)
              {
                 DPRINT_ERR(WFA_ERR, "Incorrect profile keyword format\n");
                 return WFA_FAILURE;
              }

              for(j = 0; j < PROF_LAST; j++)
              {
                  if(strcasecmp(str, profileStr[j].name) == 0)
                  {
                     pf->profile = profileStr[j].type;
                  }
              }

              DPRINT_INFO(WFA_OUT, "profile type %i\n", pf->profile);
              kwcnt++;
              str = NULL;
              break;

              case KW_DIRECTION:
              str = strtok_r(NULL, ",", (char **)&pcmdStr);
              if(isString(str) == WFA_FAILURE)
              {
                 DPRINT_ERR(WFA_ERR, "Incorrect direction keyword format\n");
                 return WFA_FAILURE;
              }

              if(strcasecmp(str, "send") == 0)
              {
                  pf->direction = DIRECT_SEND;
              }
              else if(strcasecmp(str, "receive") == 0)
              {
                  pf->direction = DIRECT_RECV;
              }
              else
                  printf("Don't know direction\n");

              DPRINT_INFO(WFA_OUT, "direction %i\n", pf->direction);
              kwcnt++;
              str = NULL;
              break;

              case KW_DIPADDR: /* dest ip address */
              memcpy(pf->dipaddr, strtok_r(NULL, ",", &pcmdStr), IPV4_ADDRESS_STRING_LEN);
              if(isIpV4Addr(pf->dipaddr) == WFA_FAILURE)
              {
                 DPRINT_ERR(WFA_ERR, "Incorrect ipaddr format\n");
                 return WFA_FAILURE;
              }
              DPRINT_INFO(WFA_OUT, "dipaddr %s\n", pf->dipaddr);

              kwcnt++;
              str = NULL;
              break;

              case KW_DPORT:
              str = strtok_r(NULL, ",", &pcmdStr);
              if(isNumber(str) == WFA_FAILURE)
              {
                 DPRINT_ERR(WFA_ERR, "Incorrect port number format\n");
                 return WFA_FAILURE;
              }
              DPRINT_INFO(WFA_OUT, "dport %s\n", str);
              pf->dport = atoi(str);

              kwcnt++;
              str = NULL;
              break;

              case KW_SIPADDR:
              memcpy(pf->sipaddr, strtok_r(NULL, ",", &pcmdStr), IPV4_ADDRESS_STRING_LEN);

              if(isIpV4Addr(pf->sipaddr) == WFA_FAILURE)
              {
                 DPRINT_ERR(WFA_ERR, "Incorrect ipaddr format\n");
                 return WFA_FAILURE;
              }
              DPRINT_INFO(WFA_OUT, "sipaddr %s\n", pf->sipaddr);
              kwcnt++;
              str = NULL;
              break;

              case KW_SPORT:
              str = strtok_r(NULL, ",", &pcmdStr);
              if(isNumber(str) == WFA_FAILURE)
              {
                 DPRINT_ERR(WFA_ERR, "Incorrect port number format\n");
                 return WFA_FAILURE;
              }
              DPRINT_INFO(WFA_OUT, "sport %s\n", str);
              pf->sport = atoi(str);

              kwcnt++;
              str = NULL;
              break;

              case KW_FRATE:
              str = strtok_r(NULL, ",", &pcmdStr);
              if(isNumber(str) == WFA_FAILURE)
              {
                 DPRINT_ERR(WFA_ERR, "Incorrect frame rate format\n");
                 return WFA_FAILURE;
              }
              DPRINT_INFO(WFA_OUT, "framerate %s\n", str);
              pf->rate = atoi(str);
              kwcnt++;
              str = NULL;
              break;

              case KW_DURATION:
              str = strtok_r(NULL, ",", &pcmdStr);
              if(isNumber(str) == WFA_FAILURE)
              {
                 DPRINT_ERR(WFA_ERR, "Incorrect duration format\n");
                 return WFA_FAILURE;
              }
              DPRINT_INFO(WFA_OUT, "duration %s\n", str);
              pf->duration = atoi(str);
              kwcnt++;
              str = NULL;
              break;

              case KW_PLOAD:
              str = strtok_r(NULL, ",", &pcmdStr);
              if(isNumber(str) == WFA_FAILURE)
              {
                 DPRINT_ERR(WFA_ERR, "Incorrect payload format\n");
                 return WFA_FAILURE;
              }
              DPRINT_INFO(WFA_OUT, "payload %s\n", str);
              pf->pksize = atoi(str);
              kwcnt++;
              str = NULL;
              break;

	      	  case KW_STARTDELAY:
              str = strtok_r(NULL, ",", &pcmdStr);
              if(isNumber(str) == WFA_FAILURE)
              {
                 DPRINT_ERR(WFA_ERR, "Incorrect startDelay format\n");
                 return WFA_FAILURE;
              }
              DPRINT_INFO(WFA_OUT, "startDelay %s\n", str);
              pf->startdelay = atoi(str);
              kwcnt++;
              str = NULL;
              break;

              case KW_MAXCNT:
              str = strtok_r(NULL, ",", &pcmdStr);
              if(isNumber(str) == WFA_FAILURE)
              {
                 DPRINT_ERR(WFA_ERR, "Incorrect max count format\n");
                 return WFA_FAILURE;
              }
              pf->maxcnt = atoi(str);
              kwcnt++;
              str = NULL;
              break;

              case KW_TCLASS:
              str = strtok_r(NULL, ",", &pcmdStr);

              // if user priority is used, tclass is ignored.
	      	  if(userPrio == 1)
	          	break;

              if(strcasecmp(str, "voice") == 0 )
              {
                 pf->trafficClass = TG_WMM_AC_VO;
              }
              else if(strcasecmp(str, "Video") == 0 )
              {
                 pf->trafficClass = TG_WMM_AC_VI;
              }
              else if(strcasecmp(str, "Background") == 0 )
              {
                 pf->trafficClass = TG_WMM_AC_BK;
              }
              else if(strcasecmp(str, "BestEffort") == 0 )
              {
                 pf->trafficClass = TG_WMM_AC_BE;
              }
              else
	      	  {
	         	pf->trafficClass = TG_WMM_AC_BE;
              }
			  DPRINT_INFO(WFA_OUT, "trafficClass %d\n", pf->trafficClass);
              kwcnt++;
              str = NULL;
              break;

	      	  case KW_USERPRIORITY:
              str = strtok_r(NULL, ",", &pcmdStr);

              if( strcasecmp(str, "6") == 0 )
              {
                 pf->trafficClass = TG_WMM_AC_UP6;
              }
              else if( strcasecmp(str, "7") == 0 )
              {
                 pf->trafficClass = TG_WMM_AC_UP7;
              }
              else if( strcasecmp(str, "5") == 0 )
              {
                 pf->trafficClass = TG_WMM_AC_UP5;
              }
              else if( strcasecmp(str, "4") == 0 )
              {
                 pf->trafficClass = TG_WMM_AC_UP4;
              }
              else if( strcasecmp(str, "1") == 0 )
              {
                 pf->trafficClass = TG_WMM_AC_UP1;
              }
              else if( strcasecmp(str, "2") == 0 )
              {
                 pf->trafficClass = TG_WMM_AC_UP2;
              }
              else if( strcasecmp(str, "0") == 0 )
              {
                 pf->trafficClass = TG_WMM_AC_UP0;
              }
              else if( strcasecmp(str, "3") == 0)
              {
                 pf->trafficClass = TG_WMM_AC_UP3;
              }

              // if User Priority is used
	      	  userPrio = 1;
			  DPRINT_INFO(WFA_OUT, "userpriority %d\n", pf->trafficClass);
              kwcnt++;
              str = NULL;
              break;

              case KW_STREAMID:
              kwcnt++;
              break;

	          case KW_NUMFRAME:
              str = strtok_r(NULL, ",", &pcmdStr);
              if(isNumber(str) == WFA_FAILURE)
              {
                 DPRINT_ERR(WFA_ERR, "Incorrect numframe format\n");
                 return WFA_FAILURE;
              }
              DPRINT_INFO(WFA_OUT, "num frame %s\n", str);
              kwcnt++;
              str = NULL;
	      	  break;

	      	  case KW_USESYNCCLOCK:
              str = strtok_r(NULL, ",", &pcmdStr);
              if(isNumber(str) == WFA_FAILURE)
              {
                 DPRINT_ERR(WFA_ERR, "Incorrect sync clock format\n");
                 return WFA_FAILURE;
              }
              DPRINT_INFO(WFA_OUT, "sync clock %s\n", str);
              kwcnt++;
              str = NULL;
	      	  break;

              default:
                ;
              } /* switch */

              if(str==NULL)
                  break;
           }  /* if */
       } /* for */
    } /* while */

#if 0
    if(kwcnt < 8)
    {
       printf("Incorrect command, missing parameters\n");
       return WFA_FAILURE;
    }
#endif

    //printProfile(pf);
    hdr->tag =  WFA_TRAFFIC_AGENT_CONFIG_TLV;
    hdr->len = sizeof(tgProfile_t);

    memcpy(aBuf+4, pf, sizeof(tgpf));

    *aLen = 4+sizeof(tgProfile_t);

    return WFA_SUCCESS;
}

/*
 * xcCmdProcAgentSend(): Process and send the Control command
 *                       "traffic_agent_send"
 * input - pcmdStr  parameter string pointer
 * return - WFA_SUCCESS or WFA_FAILURE;
 */
int xcCmdProcAgentSend(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    wfaTLV *hdr = (wfaTLV *)aBuf;
    char *str, *sid;
    int strid;
    int id_cnt = 0;

    if(aBuf == NULL)
      return WFA_FAILURE;

    memset(aBuf, 0, 512);

    DPRINT_INFO(WFA_OUT, "Entering xcCmdProcAgentSend ...\n");
    /* there is only one stream for baseline. Will support
     * multiple streams later.
     */
    str = strtok_r(NULL, ",", &pcmdStr);

    if(str == NULL || str[0] == '\0')
       return WFA_FAILURE;

    /* take the stream ids */
    if(strcasecmp(str, "streamid") != 0)
    {
       DPRINT_ERR(WFA_ERR, "invalid type name\n");
       return WFA_FAILURE;
    }

    /*
     * To handle there are multiple stream ids such as WMM
     */
    while(1)
    {
        sid = strtok_r (NULL, " ", &pcmdStr);
        if(sid == NULL)
           break;

        printf("sid %s\n", sid);
        if(isNumber(sid) == WFA_FAILURE)
           continue;

        strid = atoi(sid);
        printf("id %i\n", strid);
        id_cnt++;

        memcpy(aBuf+4*id_cnt, (char *)&strid, 4);
    }

    hdr->tag =  WFA_TRAFFIC_AGENT_SEND_TLV;
    hdr->len = 4*id_cnt;  /* multiple 4s if more streams */

    *aLen = 4 + 4*id_cnt;

#if 1
     {
              int i;
              for(i = 0; i< *aLen; i++)
                 printf("%x ", aBuf[i]);

              printf("\n");
     }
#endif


    return WFA_SUCCESS;
}

/*
 * xcCmdProcAgentReset(): Process and send the Control command
 *                       "traffic_agent_reset"
 * input - pcmdStr  parameter string pointer
 * return - WFA_SUCCESS or WFA_FAILURE;
 */
int xcCmdProcAgentReset(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    wfaTLV *hdr = (wfaTLV *)aBuf;

    DPRINT_INFO(WFA_OUT, "Entering xcCmdProcAgentReset ...\n");

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    hdr->tag =  WFA_TRAFFIC_AGENT_RESET_TLV;
    hdr->len = 0;  /* multiple 4s if more streams */

    *aLen = 4;

    return WFA_SUCCESS;
}

/*
 * xcCmdProcAgentRecvStart(): Process and send the Control command
 *                       "traffic_agent_receive_start"
 * input - pcmdStr  parameter string pointer
 * return - WFA_SUCCESS or WFA_FAILURE;
 */
int xcCmdProcAgentRecvStart(char *pcmdStr, BYTE *aBuf, int *aLen)
{

    wfaTLV *hdr = (wfaTLV *)aBuf;
    char *str, *sid;
    int strid;
    int id_cnt = 0;

    DPRINT_INFO(WFA_OUT, "Entering xcCmdProcAgentRecvStart ...%s\n", pcmdStr);

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    /* there is only one stream for baseline. Will support
     * multiple streams later.
     */
    str = strtok_r(NULL, ",", &pcmdStr);

    if(str == NULL || str[0] == '\0')
    {
       DPRINT_ERR(WFA_ERR, "Null string\n");
       return WFA_FAILURE;
    }


    if(strcasecmp(str, "streamid") != 0)
    {
       DPRINT_ERR(WFA_ERR, "invalid type name\n");
       return WFA_FAILURE;
    }

    while(1)
    {
        sid = strtok_r (NULL, " ", &pcmdStr);
        if(sid == NULL)
           break;

        if(isNumber(sid) == WFA_FAILURE)
           continue;

        strid = atoi(sid);
        id_cnt++;

        memcpy(aBuf+4*id_cnt, (char *)&strid, 4);
    }

    hdr->tag =  WFA_TRAFFIC_AGENT_RECV_START_TLV;
    hdr->len = 4*id_cnt;  /* multiple 4s if more streams */

    *aLen = 4 + 4*id_cnt;

#if 1
     {
              int i;
              for(i = 0; i< *aLen; i++)
                 printf("%x ", aBuf[i]);

              printf("\n");
     }
#endif
    return WFA_SUCCESS;
}

/*
 * xcCmdProcAgentRecvStop(): Process and send the Control command
 *                       "traffic_agent_receive_stop"
 * input - pcmdStr  parameter string pointer
 * return - WFA_SUCCESS or WFA_FAILURE;
 */
int xcCmdProcAgentRecvStop(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    wfaTLV *hdr = (wfaTLV *)aBuf;
    char *str, *sid;
    int strid;
    int id_cnt = 0;

    DPRINT_INFO(WFA_OUT, "Entering xcCmdProcAgentRecvStop ...\n");

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    /* there is only one stream for baseline. Will support
     * multiple streams later.
     */
    str = strtok_r(NULL, ",", &pcmdStr);

    if(str == NULL || str[0] == '\0')
       return WFA_FAILURE;

    if(strcasecmp(str, "streamid") != 0)
    {
       DPRINT_ERR(WFA_ERR, "invalid type name\n");
       return WFA_FAILURE;
    }
    while(1)
    {
        sid = strtok_r (NULL, " ", &pcmdStr);
        if(sid == NULL)
           break;

        if(isNumber(sid) == WFA_FAILURE)
           continue;

        strid = atoi(sid);
        id_cnt++;

        memcpy(aBuf+4*id_cnt, (char *)&strid, 4);
    }

    hdr->tag =  WFA_TRAFFIC_AGENT_RECV_STOP_TLV;
    hdr->len = 4*id_cnt;  /* multiple 4s if more streams */

    *aLen = 4 + 4*id_cnt;

    return WFA_SUCCESS;
}

int xcCmdProcAgentSendPing(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    wfaTLV *hdr = (wfaTLV *)aBuf;
    tgPingStart_t *staping = (tgPingStart_t *) (aBuf+sizeof(wfaTLV));
    char *str;
    staping->type = 0;
	staping->dscp = 0;

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "destination") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(staping->dipaddr, str, 44);
            DPRINT_INFO(WFA_OUT, "destination %s\n", staping->dipaddr);
        }
        if(strcasecmp(str, "frameSize") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            staping->frameSize=atoi(str);
            DPRINT_INFO(WFA_OUT, "framesize %i\n", staping->frameSize);
        }
        if(strcasecmp(str, "frameRate") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            staping->frameRate=atoi(str);
            DPRINT_INFO(WFA_OUT, "framerate %i\n", staping->frameRate);
        }
        if(strcasecmp(str, "duration") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            staping->duration=atoi(str);
            DPRINT_INFO(WFA_OUT, "duration %i\n", staping->duration);
        }
        //if(strcasecmp(str, "type") == 0 || strcasecmp(str, "iptype") == 0)
        if(strcasecmp(str, "iptype") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            staping->type = atoi(str);
            DPRINT_INFO(WFA_OUT, "type %i\n", staping->type);
            /*
            if(strcasecmp(str, "udp") == 0)
                staping->type = 1;
            else
                staping->type = 0;
                */
        }
    	if(strcasecmp(str, "qos") == 0)
    	{
            str = strtok_r(NULL, ",", &pcmdStr);
            if(strcasecmp(str, "vo") == 0)
            {
                staping->qos = TG_WMM_AC_VO;
            }
	    else if(strcasecmp(str, "vi") == 0)
            {
                staping->qos = TG_WMM_AC_VI;
            }
            else if(strcasecmp(str, "be") ==0)
            {
                staping->qos = TG_WMM_AC_BE;
            }
            else if(strcasecmp(str, "bk") == 0)
            {
                staping->qos = TG_WMM_AC_BK;
            }
            else
            {
                // be
                staping->qos = TG_WMM_AC_BE;
            }
        }
#ifdef MTK_HS20_SIGMA
		if(strcasecmp(str, "DSCP") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			staping->dscp=atoi(str);
			DPRINT_INFO(WFA_OUT, "dscp %d\n", staping->dscp);
		}
#endif
    }

    hdr->tag =  WFA_TRAFFIC_SEND_PING_TLV;
    hdr->len = sizeof(tgPingStart_t);

    *aLen = hdr->len + 4;

    return WFA_SUCCESS;
}

int xcCmdProcAgentStopPing(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    wfaTLV *hdr = (wfaTLV *)aBuf;
    char *str;
    int strid;
    str = strtok_r(NULL, ",", &pcmdStr);

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    if(str == NULL || str[0] == '\0')
       return WFA_FAILURE;

    if(strcasecmp(str, "streamid") == 0)
       str = strtok_r(NULL, ",", &pcmdStr);
    else
    {
       DPRINT_ERR(WFA_ERR, "invalid type name\n");
       return WFA_FAILURE;
    }

    if(isNumber(str) == WFA_FAILURE)
      return WFA_FAILURE;

    strid = atoi(str);

    memcpy(aBuf+4, (char *)&strid, 4);

    hdr->tag =  WFA_TRAFFIC_STOP_PING_TLV;
    hdr->len = 4;  /* multiple 4s if more streams */

    *aLen = 8;

    return WFA_SUCCESS;
}

#ifdef MTK_HS20_SIGMA
int xcCmdProcStaGetIpConfig(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    int slen;
    char *str = NULL;
    dutCommand_t getipconf;
    memset(&getipconf, 0, sizeof(dutCommand_t));

    DPRINT_INFO(WFA_OUT, "Entering xcCmdProcStaGetIpConfig ...\n");

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

	//type default = 1 (ipv4)
	getipconf.cmdsu.iftype = 1;

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(getipconf.intf, str, WFA_IF_NAME_LEN);
            DPRINT_INFO(WFA_OUT, "interface %s\n", getipconf.intf);
        }
        else if(strcasecmp(str, "type") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            getipconf.cmdsu.iftype = atoi(str);
            DPRINT_INFO(WFA_OUT, "type %i\n", getipconf.cmdsu.iftype);
        }
    }
	
    wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_TLV, sizeof(dutCommand_t), (BYTE *)&getipconf, aBuf);

    *aLen = 4+sizeof(getipconf);

    return WFA_SUCCESS;
}
#else
int xcCmdProcStaGetIpConfig(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    int slen;
    char *str = NULL;
    dutCommand_t getipconf;
    memset(&getipconf, 0, sizeof(dutCommand_t));

    DPRINT_INFO(WFA_OUT, "Entering xcCmdProcStaGetIpConfig ...\n");

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    str = strtok_r(NULL, ",", &pcmdStr);
    str = strtok_r(NULL, ",", &pcmdStr);
    if(str == NULL)
        return WFA_FAILURE;


    slen = strlen(str);
    memcpy(getipconf.intf, str, slen);
    wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_TLV, sizeof(dutCommand_t), (BYTE *)&getipconf, aBuf);

    *aLen = 4+sizeof(getipconf);

    return WFA_SUCCESS;
}
#endif

int xcCmdProcStaSetIpConfig(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    dutCommand_t staSetIpConfig;
    caStaSetIpConfig_t *setip = (caStaSetIpConfig_t *)&staSetIpConfig.cmdsu.ipconfig;
    char *str;
	int str_len = 16;

	DPRINT_INFO(WFA_OUT, "Entering xcCmdProcStaSetIpConfig ...\n");

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

//#ifdef MTK_HS20_SIGMA
	//Init
	setip->type = 1;
	setip->defGateway[0] = '\0';
//#endif

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setip->intf, str, str_len);
            DPRINT_INFO(WFA_OUT, "interface %s\n", setip->intf);
			setip->intf[WFA_IF_NAME_LEN-1]='\0';
        }
        else if(strcasecmp(str, "dhcp") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setip->isDhcp = atoi(str);
            DPRINT_INFO(WFA_OUT, "dhcp %i\n", setip->isDhcp);
        }
        else if(strcasecmp(str, "ip") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setip->ipaddr, str, WFA_IP_ADDR_STR_LEN);
            DPRINT_INFO(WFA_OUT, "ip %s\n", setip->ipaddr);
        }
        else if(strcasecmp(str, "mask") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setip->mask, str, str_len);
            DPRINT_INFO(WFA_OUT, "mask %s\n", setip->mask);
        }
        else if(strcasecmp(str, "defaultGateway") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setip->defGateway, str, str_len);
            DPRINT_INFO(WFA_OUT, "gw %s\n", setip->defGateway);
        }
        else if(strcasecmp(str, "primary-dns") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setip->pri_dns, str, str_len);
            DPRINT_INFO(WFA_OUT, "dns p %s\n", setip->pri_dns);
        }
        else if(strcasecmp(str, "secondary-dns") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setip->sec_dns, str, str_len);
            DPRINT_INFO(WFA_OUT, "dns s %s\n", setip->sec_dns);
        }
        else if(strcasecmp(str, "type") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setip->type = atoi(str);
            DPRINT_INFO(WFA_OUT, "type %d\n", setip->type);
        }
        else
        {
            DPRINT_ERR(WFA_ERR, "invalid command %s\n",str);
            return WFA_FAILURE;
        }
    }

    wfaEncodeTLV(WFA_STA_SET_IP_CONFIG_TLV, sizeof(staSetIpConfig), (BYTE *)&staSetIpConfig, aBuf);

    *aLen = 4+sizeof(staSetIpConfig);

    return WFA_SUCCESS;
}

int xcCmdProcStaGetMacAddress(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    int slen;
    char *str = NULL;
    dutCommand_t getmac;

    DPRINT_INFO(WFA_OUT, "Entering xcCmdProcStaGetMacAddress ...\n");

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    memset(&getmac, 0, sizeof(getmac));
    str = strtok_r(NULL, ",", &pcmdStr);
    str = strtok_r(NULL, ",", &pcmdStr);
    if(str == NULL)
        return WFA_FAILURE;

    slen = strlen(str);
    memcpy(getmac.intf, str, slen);
    wfaEncodeTLV(WFA_STA_GET_MAC_ADDRESS_TLV, sizeof(getmac), (BYTE *)&getmac, aBuf);

    *aLen = 4+sizeof(getmac);

    return WFA_SUCCESS;
}

int xcCmdProcStaSetMacAddress(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    char *str = NULL;
    dutCommand_t setmac;

    DPRINT_INFO(WFA_OUT, "Entering xcCmdProcStaSetMacAddress ...\n");

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setmac.intf, str, 15);
            DPRINT_INFO(WFA_OUT, "interface %s\n", setmac.intf);
        }
        else if(strcasecmp(str, "mac") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setmac.cmdsu.macaddr, str, 17);
            DPRINT_INFO(WFA_OUT, "mac %s\n", setmac.cmdsu.macaddr);
        }
    }

    wfaEncodeTLV(WFA_STA_SET_MAC_ADDRESS_TLV, sizeof(setmac), (BYTE *)&setmac, aBuf);

    *aLen = 4+sizeof(setmac);

    return WFA_SUCCESS;
}

int xcCmdProcStaIsConnected(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    int slen;
    char *str = NULL;
    dutCommand_t isconnected;

    DPRINT_INFO(WFA_OUT, "Entering xcCmdProcStaIsConnected\n");

    memset(&isconnected, 0, sizeof(isconnected));

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    str = strtok_r(NULL, ",", &pcmdStr);
    str = strtok_r(NULL, ",", &pcmdStr);
    if(str == NULL)
        return WFA_FAILURE;

    slen = strlen(str);
    memcpy(isconnected.intf, str, slen);
    wfaEncodeTLV(WFA_STA_IS_CONNECTED_TLV, sizeof(isconnected), (BYTE *)&isconnected, aBuf);

    *aLen = 4+sizeof(isconnected);

    return WFA_SUCCESS;
}

int xcCmdProcStaVerifyIpConnection(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    wfaTLV *hdr = (wfaTLV *)aBuf;
    dutCommand_t *verifyip = (dutCommand_t *) (aBuf+sizeof(wfaTLV));
    char *str;

    DPRINT_INFO(WFA_OUT, "Entering xcCmdProcStaVerifyIpConnection ...\n");

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strcpy(verifyip->intf, str);
            verifyip->intf[15]='\0';
            DPRINT_INFO(WFA_OUT, "interface %s %i\n", verifyip->intf, strlen(verifyip->intf));
        }
        else if(strcasecmp(str, "destination") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(verifyip->cmdsu.verifyIp.dipaddr, str, 15);
            DPRINT_INFO(WFA_OUT, "ip %s\n", verifyip->cmdsu.verifyIp.dipaddr);
        }
        else if(strcasecmp(str, "timeout") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            verifyip->cmdsu.verifyIp.timeout = atoi(str);
            DPRINT_INFO(WFA_OUT, "timeout %i\n", verifyip->cmdsu.verifyIp.timeout);
        }
    }

    wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_TLV, sizeof(verifyip), (BYTE *)&verifyip, aBuf);

    hdr->tag =  WFA_STA_VERIFY_IP_CONNECTION_TLV;
    hdr->len = sizeof(dutCommand_t);

    *aLen = 4+sizeof(dutCommand_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaGetBSSID(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    char *str = NULL;
    dutCommand_t getbssid;

    DPRINT_INFO(WFA_OUT, "Entering xcCmdProcStaGetBSSID ...\n");

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    memset(&getbssid, 0, sizeof(getbssid));
    str = strtok_r(NULL, ",", &pcmdStr);
    str = strtok_r(NULL, ",", &pcmdStr);
    if(str == NULL)
        return WFA_FAILURE;

    memcpy(getbssid.intf, str, WFA_IF_NAME_LEN-1);
    getbssid.intf[WFA_IF_NAME_LEN-1] = '\0';
    wfaEncodeTLV(WFA_STA_GET_BSSID_TLV, sizeof(getbssid), (BYTE *)&getbssid, aBuf);

    *aLen = 4+sizeof(getbssid);

    return WFA_SUCCESS;
}


int xcCmdProcStaGetStats(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    char *str = NULL;
    dutCommand_t getstats;

    DPRINT_INFO(WFA_OUT, "Entering xcCmdProcStaGetStats ...\n");
    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    memset(&getstats, 0, sizeof(getstats));
    str = strtok_r(NULL, ",", &pcmdStr);
    /* need to check if the parameter name is called interface */
    str = strtok_r(NULL, ",", &pcmdStr);
    if(str == NULL)
        return WFA_FAILURE;

    memcpy(getstats.intf, str, WFA_IF_NAME_LEN-1);
    getstats.intf[WFA_IF_NAME_LEN-1] = '\0';
    wfaEncodeTLV(WFA_STA_GET_STATS_TLV, sizeof(getstats), (BYTE *)&getstats, aBuf);

    *aLen = 4+sizeof(getstats);

    return WFA_SUCCESS;
}


int  xcCmdProcStaSetEncryption(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    caStaSetEncryption_t *setencryp = (caStaSetEncryption_t *) (aBuf+sizeof(wfaTLV));
    char *str;

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setencryp->intf, str, 15);
        }
        else if(strcasecmp(str, "ssid") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setencryp->ssid, str, 64);
        }
        else if(strcasecmp(str, "encpType") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            if(strcasecmp(str, "wep") == 0)
               setencryp->encpType = ENCRYPT_WEP;
            else
               setencryp->encpType = 0;
        }
        else if(strcasecmp(str, "key1") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy((char *)setencryp->keys[0], str, 26);
            DPRINT_INFO(WFA_OUT, "%s\n", setencryp->keys[0]);
            setencryp->activeKeyIdx = 0;
        }
        else if(strcasecmp(str, "key2") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy((char *)setencryp->keys[1], str, 26);
            DPRINT_INFO(WFA_OUT, "%s\n", setencryp->keys[1]);
        }
        else if(strcasecmp(str, "key3") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy((char *)setencryp->keys[2], str, 26);
            DPRINT_INFO(WFA_OUT, "%s\n", setencryp->keys[2]);
        }
        else if(strcasecmp(str, "key4") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy((char *)setencryp->keys[3], str, 26);
            DPRINT_INFO(WFA_OUT, "%s\n", setencryp->keys[3]);
        }
        else if(strcasecmp(str, "activeKey") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setencryp->activeKeyIdx =  atoi(str);
        }
        else
        {
            DPRINT_INFO(WFA_WNG, "Incorrect Command, check syntax\n");
        }
    }

    wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_TLV, sizeof(caStaSetEncryption_t), (BYTE *)setencryp, aBuf);

    *aLen = 4+sizeof(caStaSetEncryption_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaSetSecurity(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    int ret = WFA_SUCCESS;
    dutCommand_t *cmd = (dutCommand_t *) (aBuf+sizeof(wfaTLV));
    caStaSetSecurity_t *ssec = &cmd->cmdsu.setsec;
    char *str;
    int secType = 0;

#ifndef WFA_PC_CONSOLE
    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(cmd->intf, str, 15);
        }
        else if(strcasecmp(str, "ssid") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(ssec->ssid, str, 64);
            DPRINT_INFO(WFA_OUT, "ssid %s\n", ssec->ssid);
        }
        else if(strcasecmp(str, "encpType") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);

            if(strcasecmp(str, "tkip") == 0 || strcasecmp(str, "aes-ccmp") == 0)
               strncpy(ssec->encrptype, str, strlen(str));
        }
        else if(strcasecmp(str, "pmf") == 0)
        {
            str = strtok_r (NULL, ",", &pcmdStr);

            if( strcasecmp(str, "optional") == 0)
               ssec->pmf = WFA_OPTIONAL;
            else if(strcasecmp(str, "required") == 0)
               ssec->pmf = WFA_REQUIRED;
            else
               ssec->pmf = WFA_DISABLED;
        }

        else if(strcasecmp(str, "type") == 0)
        {
           /* process the specific type of security */
           str = strtok_r (NULL, ",", &pcmdStr);
           if(strcasecmp(str, "psk") == 0)
           {
               ssec->type = secType = SEC_TYPE_PSK;

               str = strtok_r(NULL, ",", &pcmdStr);
               if(strcasecmp(str, "passphrase") == 0)
               {
                  str = strtok_r(NULL, ",", &pcmdStr);
                  strncpy(ssec->secu.passphrase, str, 64);
               }
           }
           else if(strcasecmp(str, "eaptls") == 0)
           {
               ssec->type = secType = SEC_TYPE_EAPTLS;
           }
           else if(strcasecmp(str, "eapttls") == 0)
           {
               ssec->type = secType = SEC_TYPE_EAPTTLS;
           }
           else if(strcasecmp(str, "eappeap") == 0)
           {
               ssec->type = secType = SEC_TYPE_EAPPEAP;
           }
           else if(strcasecmp(str, "eapsim") == 0)
           {
               ssec->type = secType = SEC_TYPE_EAPSIM;
           }
           else if(strcasecmp(str, "eapfast") == 0)
           {
               ssec->type = secType = SEC_TYPE_EAPFAST;
           }
           else if(strcasecmp(str, "eapaka") == 0)
           {
               ssec->type = secType = SEC_TYPE_EAPAKA;
           }
        }
    }
#endif

    return ret;
}

int xcCmdProcStaSetPSK(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    caStaSetPSK_t *setencryp = (caStaSetPSK_t *) (aBuf+sizeof(wfaTLV));
    char *str;

#if defined(MTK_HS20_SIGMA)
	//Init
	setencryp->prefer = 0;
	strncpy(setencryp->prog, "hs2", 3);
#endif

#ifndef WFA_PC_CONSOLE
    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setencryp->intf, str, 15);
        }
        else if(strcasecmp(str, "ssid") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setencryp->ssid, str, 64);
            DPRINT_INFO(WFA_OUT, "ssid %s\n", setencryp->ssid);
        }
        else if(strcasecmp(str, "passPhrase") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy((char *)setencryp->passphrase, str, 63);
        }
        else if(strcasecmp(str, "keyMgmtType") == 0)
        {
            str=strtok_r(NULL, ",", &pcmdStr);
            strncpy(setencryp->keyMgmtType, str, strlen(str));
        }
        else if(strcasecmp(str, "encpType") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);

            if(strcasecmp(str, "tkip") == 0)
               setencryp->encpType = ENCRYPT_TKIP;
            else if(strcasecmp(str, "aes-ccmp") == 0)
               setencryp->encpType = ENCRYPT_AESCCMP;
        }
        else if(strcasecmp(str, "pmf") == 0)
        {
            str = strtok_r (NULL, ",", &pcmdStr);

            if(strcasecmp(str, "enable") == 0
                || strcasecmp(str, "optional") == 0)
               setencryp->pmf = WFA_ENABLED;
            else if(strcasecmp(str, "required") == 0)
               setencryp->pmf = WFA_REQUIRED;
            else
               setencryp->pmf = WFA_DISABLED;
        }
#if defined(MTK_HS20_SIGMA)
		else if(strcasecmp(str, "prefer") == 0)
		{
            str = strtok_r(NULL, ",", &pcmdStr);
            setencryp->prefer =  atoi(str);
		}
        else if(strcasecmp(str, "prog") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(setencryp->prog, str, 15);
        }		
#endif
    }

#endif

    wfaEncodeTLV(WFA_STA_SET_PSK_TLV, sizeof(caStaSetPSK_t), (BYTE *)setencryp, aBuf);

    *aLen = 4+sizeof(caStaSetPSK_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaSetEapTLS(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    caStaSetEapTLS_t *setsec = (caStaSetEapTLS_t *) (aBuf+sizeof(wfaTLV));
    char *str;

#if defined(MTK_HS20_SIGMA)
	//Init
	setsec->prefer = 0;
	strncpy(setsec->prog, "hs2", 3);
#endif	

#ifndef WFA_PC_CONSOLE

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->intf, str, 15);
        }
        else if(strcasecmp(str, "ssid") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->ssid, str, 64);
        }
        else if(strcasecmp(str, "keyMgmtType") == 0)
        {
            str=strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->keyMgmtType, str, strlen(str));
        }
        else if(strcasecmp(str, "encpType") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->encrptype, str, strlen(str));
        }
        else if(strcasecmp(str, "trustedRootCA") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strcpy(setsec->trustedRootCA, str);
        }
        else if(strcasecmp(str, "clientCertificate") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strcpy(setsec->clientCertificate, str);
        }
        else if(strcasecmp(str, "pmf") == 0)
        {
            str = strtok_r (NULL, ",", &pcmdStr);

            if(strcasecmp(str, "enable") == 0
                || strcasecmp(str, "optional") == 0)
               setsec->pmf = WFA_ENABLED;
            else if(strcasecmp(str, "required") == 0)
               setsec->pmf = WFA_REQUIRED;
            else if(strcasecmp(str, "forced_required") == 0)
               setsec->pmf = WFA_F_REQUIRED;
            else if(strcasecmp(str, "forced_disabled") == 0)
               setsec->pmf = WFA_F_DISABLED;
            else
               setsec->pmf = WFA_DISABLED;
        }
#if defined(MTK_HS20_SIGMA)
		else if(strcasecmp(str, "prefer") == 0)
		{
            str = strtok_r(NULL, ",", &pcmdStr);
            setsec->prefer =  atoi(str);
		}
        else if(strcasecmp(str, "prog") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(setsec->prog, str, 15);
        }		
#endif		
    }

#endif

    wfaEncodeTLV(WFA_STA_SET_EAPTLS_TLV, sizeof(caStaSetEapTLS_t), (BYTE *)setsec, aBuf);

    *aLen = 4+sizeof(caStaSetEapTLS_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaSetEapTTLS(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    caStaSetEapTTLS_t *setsec = (caStaSetEapTTLS_t *) (aBuf+sizeof(wfaTLV));
    char *str;

#if defined(MTK_HS20_SIGMA)
	//Init
	setsec->prefer = 0;
	strncpy(setsec->prog, "hs2", 3);
#endif		

#ifndef WFA_PC_CONSOLE
    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->intf, str, 15);
        }
        else if(strcasecmp(str, "ssid") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->ssid, str, 64);
        }
        else if(strcasecmp(str, "username") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strcpy(setsec->username, str);
        }
        else if(strcasecmp(str, "password") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strcpy(setsec->passwd, str);
        }
        else if(strcasecmp(str, "keyMgmtType") == 0)
        {
            str=strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->keyMgmtType, str, 7);
        }
        else if(strcasecmp(str, "encpType") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->encrptype, str, strlen(str));
        }
        else if(strcasecmp(str, "trustedRootCA") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strcpy(setsec->trustedRootCA, str);
        }
        else if(strcasecmp(str, "clientCertificate") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strcpy(setsec->clientCertificate, str);
        }
        else if(strcasecmp(str, "pmf") == 0)
        {
            str = strtok_r (NULL, ",", &pcmdStr);

            if(strcasecmp(str, "enable") == 0
                || strcasecmp(str, "optional") == 0)
               setsec->pmf = WFA_ENABLED;
            else if(strcasecmp(str, "required") == 0)
               setsec->pmf = WFA_REQUIRED;
            else
               setsec->pmf = WFA_DISABLED;
        }
#if defined(MTK_HS20_SIGMA)
		else if(strcasecmp(str, "prefer") == 0)
		{
            str = strtok_r(NULL, ",", &pcmdStr);
            setsec->prefer =  atoi(str);
		}
        else if(strcasecmp(str, "prog") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(setsec->prog, str, 15);
        }		
#endif			
    }

#endif
    printf("setsec->trustedRootCA:%s\n", setsec->trustedRootCA);
    wfaEncodeTLV(WFA_STA_SET_EAPTTLS_TLV, sizeof(caStaSetEapTTLS_t), (BYTE *)setsec, aBuf);

    *aLen = 4+sizeof(caStaSetEapTTLS_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaSetEapSIM(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    caStaSetEapSIM_t *setsec = (caStaSetEapSIM_t *) (aBuf+sizeof(wfaTLV));
    char *str;

#ifndef WFA_PC_CONSOLE
    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->intf, str, 15);
        }
        else if(strcasecmp(str, "ssid") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->ssid, str, 64);
        }
        else if(strcasecmp(str, "username") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strcpy(setsec->username, str);
        }
        else if(strcasecmp(str, "password") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strcpy(setsec->passwd, str);
        }
        else if(strcasecmp(str, "keyMgmtType") == 0)
        {
            str=strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->keyMgmtType, str, strlen(str));
        }
        else if(strcasecmp(str, "encpType") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->encrptype, str, strlen(str));
        }
        else if(strcasecmp(str, "triplet1") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy((char *)setsec->tripletSet[0], str, 63);
            DPRINT_INFO(WFA_OUT, "Triplet1 : %s\n", setsec->tripletSet[0]);
            setsec->tripletCount = 1;
        }
        else if(strcasecmp(str, "triplet2") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy((char *)setsec->tripletSet[1], str, 63);
            DPRINT_INFO(WFA_OUT, "Triplet2 : %s\n", setsec->tripletSet[1]);
            setsec->tripletCount=2;
        }
        else if(strcasecmp(str, "triplet3") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy((char *)setsec->tripletSet[2], str, 63);
            DPRINT_INFO(WFA_OUT, "Triplet1 : %s\n", setsec->tripletSet[2]);
            setsec->tripletCount = 3;
        }
        else if(strcasecmp(str, "pmf") == 0)
        {
            str = strtok_r (NULL, ",", &pcmdStr);

            if(strcasecmp(str, "enable") == 0
                || strcasecmp(str, "optional") == 0)
               setsec->pmf = WFA_ENABLED;
            else if(strcasecmp(str, "required") == 0)
               setsec->pmf = WFA_REQUIRED;
            else
               setsec->pmf = WFA_DISABLED;
        }
    }

#endif

    wfaEncodeTLV(WFA_STA_SET_EAPSIM_TLV, sizeof(caStaSetEapSIM_t), (BYTE *)setsec, aBuf);

    *aLen = 4+sizeof(caStaSetEapSIM_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaSetPEAP(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    caStaSetEapPEAP_t *setsec = (caStaSetEapPEAP_t *) (aBuf+sizeof(wfaTLV));
    char *str;

#ifndef WFA_PC_CONSOLE
    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->intf, str, 15);
        }
        else if(strcasecmp(str, "ssid") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->ssid, str, 64);
        }
        else if(strcasecmp(str, "username") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strcpy(setsec->username, str);
        }
        else if(strcasecmp(str, "password") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strcpy(setsec->passwd, str);
        }
        else if(strcasecmp(str, "keyMgmtType") == 0)
        {
            str=strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->keyMgmtType, str, strlen(str));
        }
        else if(strcasecmp(str, "encpType") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->encrptype, str, strlen(str));
        }
        else if(strcasecmp(str, "innerEAP") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strcpy(setsec->innerEAP, str);
        }
	else if(strcasecmp(str, "trustedRootCA") == 0)
	{
	    str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->trustedRootCA, str,31);
	}
        else if(strcasecmp(str, "peapVersion") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setsec->peapVersion = atoi(str);
        }
        else if(strcasecmp(str, "pmf") == 0)
        {
            str = strtok_r (NULL, ",", &pcmdStr);

            if(strcasecmp(str, "enable") == 0
                || strcasecmp(str, "optional") == 0)
               setsec->pmf = WFA_ENABLED;
            else if(strcasecmp(str, "required") == 0)
               setsec->pmf = WFA_REQUIRED;
            else
               setsec->pmf = WFA_DISABLED;
        }
    }

#endif

    wfaEncodeTLV(WFA_STA_SET_PEAP_TLV, sizeof(caStaSetEapPEAP_t), (BYTE *)setsec, aBuf);

    *aLen = 4+sizeof(caStaSetEapPEAP_t);

    return WFA_SUCCESS;
}


int xcCmdProcStaSetIBSS(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    caStaSetIBSS_t *setibss = (caStaSetIBSS_t *) (aBuf+sizeof(wfaTLV));
    char *str;
    int i = 0;

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setibss->intf, str, 15);
            DPRINT_INFO(WFA_OUT, "interface %s\n", setibss->intf);

        }
        else if(strcasecmp(str, "ssid") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setibss->ssid, str, 64);
            DPRINT_INFO(WFA_OUT, "ssid %s\n", setibss->ssid);
        }
        else if(strcasecmp(str, "channel") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setibss->channel = atoi(str);
        }
        else if(strcasecmp(str, "encpType") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            if(strcasecmp(str, "wep") == 0)
               setibss->encpType = ENCRYPT_WEP;
            else
               setibss->encpType = 0;
        }
        else if(strncasecmp(str, "key1", 4) == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setibss->keys[i++], str, 26);
            setibss->activeKeyIdx = 0;
        }
        else if(strncasecmp(str, "key2", 4) == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setibss->keys[i++], str, 26);
        }
        else if(strncasecmp(str, "key3", 4) == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setibss->keys[i++], str, 26);
        }
        else if(strncasecmp(str, "key4", 4) == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setibss->keys[i++], str, 26);
        }
        else if(strcasecmp(str, "activeKey") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setibss->activeKeyIdx = atoi(str);
        }
    }

    wfaEncodeTLV(WFA_STA_SET_IBSS_TLV, sizeof(caStaSetIBSS_t), (BYTE *)setibss, aBuf);

    *aLen = 4+sizeof(caStaSetIBSS_t);

    return WFA_SUCCESS;
}

int xcCmdProcDeviceGetInfo(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    dutCommand_t *dutCmd = (dutCommand_t *) (aBuf+sizeof(wfaTLV));
    caDevInfo_t *dinfo = &dutCmd->cmdsu.dev;
    char *str;

    if(aBuf == NULL)
        return WFA_FAILURE;

    printf("entering device get info\n");
    memset(aBuf, 0, *aLen);

    dinfo->fw = 0;
    str = strtok_r(NULL, ",", &pcmdStr);
    if(str != NULL && str[0] != '\0')
    {
       if(strcasecmp(str, "firmware") == 0)
       {
           dinfo->fw = 1;
       }
    }

    wfaEncodeTLV(WFA_DEVICE_GET_INFO_TLV, 0, NULL, aBuf);

    *aLen = 4;

    return WFA_SUCCESS;
}

int xcCmdProcStaGetInfo(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    char *str;
    dutCommand_t *getInfo = (dutCommand_t *) (aBuf+sizeof(wfaTLV));

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    str = strtok_r(NULL, ",", &pcmdStr);
    if(str == NULL || str[0] == '\0')
         return WFA_FAILURE;

    if(strcasecmp(str, "interface") == 0)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        strncpy(getInfo->intf, str, 15);
        DPRINT_INFO(WFA_OUT, "interface %s\n", getInfo->intf);

    }

    wfaEncodeTLV(WFA_STA_GET_INFO_TLV, sizeof(dutCommand_t), (BYTE *)getInfo, aBuf);

    *aLen = 4 + sizeof(dutCommand_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaUpload(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    char *str;
    dutCommand_t *dutCmd = (dutCommand_t *) (aBuf+sizeof(wfaTLV));
    caStaUpload_t *tdp = &dutCmd->cmdsu.upload;

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    str = strtok_r(NULL, ",", &pcmdStr);
    if(str == NULL || str[0] == '\0')
         return WFA_FAILURE;

    if(strcasecmp(str, "test") == 0)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
	if(strcasecmp(str, "voice") == 0)
	{
	    tdp->type = WFA_UPLOAD_VHSO_RPT;
            DPRINT_INFO(WFA_OUT, "testdata voice %i\n", tdp->type);
            str = strtok_r(NULL, ",", &pcmdStr);
            tdp->next = atoi(str);
	}
    }

    wfaEncodeTLV(WFA_STA_UPLOAD_TLV, sizeof(dutCommand_t), (BYTE *)dutCmd, aBuf);

    *aLen = 4 + sizeof(dutCommand_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaAssociate(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    dutCommand_t *setassoc = (dutCommand_t *) (aBuf+sizeof(wfaTLV));
    char *str;

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setassoc->intf, str, 15);
            DPRINT_INFO(WFA_OUT, "interface %s\n", setassoc->intf);

        }
        else if(strcasecmp(str, "ssid") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setassoc->cmdsu.assoc.ssid, str, 64);
            DPRINT_INFO(WFA_OUT, "ssid %s\n", setassoc->cmdsu.assoc.ssid);
        }
        else if(strcasecmp(str, "bssid") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setassoc->cmdsu.assoc.bssid, str, 17);
            DPRINT_INFO(WFA_OUT, "bssid %s\n", setassoc->cmdsu.assoc.bssid);
        }
   }

    wfaEncodeTLV(WFA_STA_ASSOCIATE_TLV, sizeof(dutCommand_t), (BYTE *)setassoc, aBuf);

    *aLen = 4+sizeof(dutCommand_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaReAssociate(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    dutCommand_t *setassoc = (dutCommand_t *) (aBuf+sizeof(wfaTLV));
    char *str;

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setassoc->intf, str, 15);
            DPRINT_INFO(WFA_OUT, "interface %s\n", setassoc->intf);

        }
        else if(strcasecmp(str, "ssid") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setassoc->cmdsu.assoc.ssid, str, 64);
            DPRINT_INFO(WFA_OUT, "ssid %s\n", setassoc->cmdsu.assoc.ssid);
        }
        else if(strcasecmp(str, "bssid") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setassoc->cmdsu.assoc.bssid, str, 17);
            DPRINT_INFO(WFA_OUT, "bssid %s\n", setassoc->cmdsu.assoc.bssid);
        }
   }

    wfaEncodeTLV(WFA_STA_REASSOCIATE_TLV, sizeof(dutCommand_t), (BYTE *)setassoc, aBuf);

    *aLen = 4+sizeof(dutCommand_t);

    return WFA_SUCCESS;
}

int xcCmdProcDeviceListIF(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    dutCommand_t *getdevlist = (dutCommand_t *) (aBuf+sizeof(wfaTLV));
    char *str;

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    str = strtok_r(NULL, ",", &pcmdStr);
    if(str == NULL || str[0] == '\0')
       return WFA_FAILURE;

    if(strcasecmp(str, "interfaceType") == 0)
    {
         str = strtok_r(NULL, ",", &pcmdStr);
         if(strcmp(str, "802.11") == 0)
             getdevlist->cmdsu.iftype = IF_80211;

         DPRINT_INFO(WFA_OUT, "interface type %i\n", getdevlist->cmdsu.iftype);
    }

    wfaEncodeTLV(WFA_DEVICE_LIST_IF_TLV, sizeof(dutCommand_t), (BYTE *)getdevlist, aBuf);

    *aLen = 4 + sizeof(dutCommand_t);

#if DEBUG
               for(i = 0; i< len; i++)
                 printf("%x ", buf[i]);

               printf("\n");
#endif

    return WFA_SUCCESS;
}

int xcCmdProcStaSetUAPSD(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    caStaSetUAPSD_t *setuapsd = (caStaSetUAPSD_t *) (aBuf+sizeof(wfaTLV));
    char *str;
    wfaTLV *hdr = (wfaTLV *)aBuf;

    DPRINT_INFO(WFA_OUT, "start xcCmdProcAgentConfig ...\n");
    DPRINT_INFO(WFA_OUT, "params:  %s\n", pcmdStr);
    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);
    setuapsd->acBE = 0;
    setuapsd->acBK = 0;
    setuapsd->acVI = 0;
    setuapsd->acVO = 0;

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setuapsd->intf, str, 15);
        }
        else if(strcasecmp(str, "ssid") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setuapsd->ssid, str, 64);
        }
        else if(strcasecmp(str, "maxSP") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setuapsd->maxSPLength = atoi(str);
        }
        else if(strcasecmp(str, "acBE") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setuapsd->acBE = atoi(str);

        }
        else if(strcasecmp(str, "acBK") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setuapsd->acBK = atoi(str);

        }
        else if(strcasecmp(str, "acVI") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setuapsd->acVI = atoi(str);
        }
        else if(strcasecmp(str, "acVO") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setuapsd->acVO = atoi(str);
        }
        else if(strcasecmp(str, "type") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setuapsd->type = atoi(str);
        }
        else if(strcasecmp(str, "peer") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setuapsd->peer, str, 17);
        }
    }
    hdr->tag =  WFA_STA_SET_UAPSD_TLV;
    hdr->len = sizeof(caStaSetUAPSD_t);

    memcpy(aBuf+4, setuapsd, sizeof(caStaSetUAPSD_t));

    *aLen = 4+sizeof(caStaSetUAPSD_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaDebugSet(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    dutCommand_t *debugSet = (dutCommand_t *) (aBuf+sizeof(wfaTLV));
    char *str;

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "level") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            if(atoi(str) == WFA_DEBUG_INFO || WFA_DEBUG_WARNING)
            {
                debugSet->cmdsu.dbg.level = atoi(str);
                DPRINT_INFO(WFA_OUT, "dbg level %i\n", debugSet->cmdsu.dbg.level);
            }
            else
                return WFA_FAILURE;  /* not support */

        }
        else if(strcasecmp(str, "enable") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            printf("enable %i\n", atoi(str));
            switch(atoi(str)) /* enable */
            {
            case 1:
               debugSet->cmdsu.dbg.state = 1;
               printf("enable\n");
               break;
            case 0:
               debugSet->cmdsu.dbg.state = 0;
               printf("disable\n");
               break;
            default:
               printf("wrong\n");
               return WFA_FAILURE;  /* command invalid */
            }
         }
    }

    wfaEncodeTLV(WFA_STA_DEBUG_SET_TLV, sizeof(dutCommand_t), (BYTE *)debugSet, aBuf);

    *aLen = 4 + sizeof(dutCommand_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaSetMode(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    caStaSetMode_t *setmode = (caStaSetMode_t *) (aBuf+sizeof(wfaTLV));
    char *str;

    if(aBuf == NULL)
       return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
           break;

        if(strcasecmp(str, "interface") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           strncpy(setmode->intf, str, 15);
        }
        else if(strcasecmp(str, "ssid") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           strncpy(setmode->ssid, str, 64);
        }
        else if(strcasecmp(str, "encpType") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           if(strcasecmp(str, "wep") == 0)
              setmode->encpType = ENCRYPT_WEP;
           else
              setmode->encpType = 0;
        }
        else if(strcasecmp(str, "key1") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           strncpy((char *)setmode->keys[0], str, 26);
           DPRINT_INFO(WFA_OUT, "%s\n", setmode->keys[0]);
           setmode->activeKeyIdx = 0;
        }
        else if(strcasecmp(str, "key2") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy((char *)setmode->keys[1], str, 26);
            DPRINT_INFO(WFA_OUT, "%s\n", setmode->keys[1]);
        }
        else if(strcasecmp(str, "key3") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy((char *)setmode->keys[2], str, 26);
            DPRINT_INFO(WFA_OUT, "%s\n", setmode->keys[2]);
        }
        else if(strcasecmp(str, "key4") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy((char *)setmode->keys[3], str, 26);
            DPRINT_INFO(WFA_OUT, "%s\n", setmode->keys[3]);
        }
        else if(strcasecmp(str, "activeKey") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setmode->activeKeyIdx =  atoi(str);
        }
        else if(strcasecmp(str, "mode") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            printf("\r\n mode is %s\n",str);
            if(strcasecmp(str, "adhoc") == 0)
               setmode->mode = 1;
            else
               setmode->mode = 0;
        }
        else if(strcasecmp(str, "channel") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setmode->channel = atoi(str);
        }
        else
        {
            DPRINT_INFO(WFA_WNG, "Incorrect Command, check syntax\n");
            printf("\r\n mode is %s\n",str);
        }
    }

    wfaEncodeTLV(WFA_STA_SET_MODE_TLV, sizeof(caStaSetMode_t), (BYTE *)setmode, aBuf);
    *aLen = 4+sizeof(caStaSetMode_t);

    return WFA_SUCCESS;
}

#ifdef MTK_P2P_SIGMA
int xcCmdProcStaGetP2pDevAddress(char * pcmdStr,BYTE * aBuf,int * aLen)
{
    dutCommand_t *getP2pDevAdd= (dutCommand_t *) (aBuf+sizeof(wfaTLV));
    char *str;

    if(aBuf == NULL)
       return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
           break;

        if(strcasecmp(str, "interface") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           strncpy(getP2pDevAdd->intf, str, WFA_IF_NAME_LEN-1 );
           getP2pDevAdd->intf[WFA_IF_NAME_LEN-1] = '\0';
        }
    }

    wfaEncodeTLV(WFA_STA_P2P_GET_DEV_ADDRESS_TLV, sizeof(dutCommand_t), (BYTE *)getP2pDevAdd, aBuf);

    *aLen = 4+sizeof(dutCommand_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaSetP2p(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   caStaSetP2p_t *staSetP2p= (caStaSetP2p_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staSetP2p->intf, str, WFA_IF_NAME_LEN-1);
         staSetP2p->intf[WFA_IF_NAME_LEN-1]='\0';

      }
      else if(strcasecmp(str, "listen_chn") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSetP2p->listen_chn= atoi(str);
         staSetP2p->listen_chn_flag =1;
      }
      else if(strcasecmp(str, "p2p_mode") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staSetP2p->p2p_mode, str, 15);
         staSetP2p->p2p_mode_flag = 1;
      }
      else if(strcasecmp(str, "persistent") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSetP2p->presistent= atoi(str);
         staSetP2p->presistent_flag = 1;
      }
      else if(strcasecmp(str, "intra_bss") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSetP2p->intra_bss= atoi(str);
         staSetP2p->intra_bss_flag = 1;
      }
      else if(strcasecmp(str, "noa_duration") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSetP2p->noa_duration= atoi(str);
         staSetP2p->noa_duration_flag = 1;
      }
      else if(strcasecmp(str, "noa_interval") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSetP2p->noa_interval= atoi(str);
         staSetP2p->noa_interval_flag = 1;
      }
      else if(strcasecmp(str, "noa_count") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSetP2p->noa_count= atoi(str);
         staSetP2p->noa_count_flag = 1;
      }
      else if(strcasecmp(str, "concurrency") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSetP2p->concurrency= atoi(str);
         staSetP2p->concurrency_flag= 1;
      }
      else if(strcasecmp(str, "p2pinvitation") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSetP2p->p2p_invitation= atoi(str);
         staSetP2p->p2p_invitation_flag= 1;
      }
      else if(strcasecmp(str, "bcn_int") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSetP2p->bcn_int= atoi(str);
         staSetP2p->bcn_int_flag= 1;
      }
      else if(strcasecmp(str, "ext_listen_time_interval") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSetP2p->ext_listen_time_int= atoi(str);
         staSetP2p->ext_listen_time_int_flag= 1;
      }
      else if(strcasecmp(str, "ext_listen_time_period") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSetP2p->ext_listen_time_period= atoi(str);
         staSetP2p->ext_listen_time_period_flag= 1;
      }
      else if(strcasecmp(str, "discoverability") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSetP2p->discoverability= atoi(str);
         staSetP2p->discoverability_flag= 1;
      }
      else if(strcasecmp(str, "service_discovery") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSetP2p->service_discovery= atoi(str);
         staSetP2p->service_discovry_flag= 1;
      }
      else if(strcasecmp(str, "crossconnection") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSetP2p->crossconnection= atoi(str);
         staSetP2p->crossconnection_flag= 1;
      }
      else if(strcasecmp(str, "p2pmanaged") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSetP2p->p2pmanaged= atoi(str);
         staSetP2p->p2pmanaged_flag= 1;
      }
      else if(strcasecmp(str, "go_apsd") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSetP2p->go_apsd= atoi(str);
         staSetP2p->go_apsd_flag= 1;
      }
   }

   wfaEncodeTLV(WFA_STA_P2P_SETP2P_TLV, sizeof(caStaSetP2p_t), (BYTE *)staSetP2p, aBuf);

   *aLen = 4+sizeof(caStaSetP2p_t);

   return WFA_SUCCESS;
}


int xcCmdProcStaP2pConnect(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   caStaP2pConnect_t *staP2pConnect= (caStaP2pConnect_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staP2pConnect->intf, str,WFA_IF_NAME_LEN-1);
         staP2pConnect->intf[WFA_IF_NAME_LEN-1]='\0';
      }
      else if(strcasecmp(str, "groupid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staP2pConnect->grpid, str, WFA_P2P_GRP_ID_LEN-1);
         staP2pConnect->grpid[WFA_P2P_GRP_ID_LEN-1]='\0';
      }
      else if(strcasecmp(str, "p2pdevid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staP2pConnect->devId, str, WFA_P2P_DEVID_LEN-1);
         staP2pConnect->devId[WFA_P2P_DEVID_LEN-1]='\0';
      }
   }

   wfaEncodeTLV(WFA_STA_P2P_CONNECT_TLV, sizeof(caStaP2pConnect_t), (BYTE *)staP2pConnect, aBuf);

   *aLen = 4+sizeof(caStaP2pConnect_t);

   return WFA_SUCCESS;
}



int xcCmdProcStaP2pStartGroupFormation(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   caStaP2pStartGrpForm_t *staP2pStartGrpForm= (caStaP2pStartGrpForm_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staP2pStartGrpForm->intf, str, WFA_IF_NAME_LEN-1);
         staP2pStartGrpForm->intf[WFA_IF_NAME_LEN-1]='\0';
      }
      else if(strcasecmp(str, "p2pdevid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staP2pStartGrpForm->devId, str, WFA_P2P_DEVID_LEN-1);
         staP2pStartGrpForm->devId[WFA_P2P_DEVID_LEN-1]='\0';
      }
      else if(strcasecmp(str, "intent_val") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staP2pStartGrpForm->intent_val= atoi(str);
      }
      else if(strcasecmp(str, "init_go_neg") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staP2pStartGrpForm->init_go_neg= atoi(str);
      }
      else if(strcasecmp(str, "oper_chn") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staP2pStartGrpForm->oper_chn= atoi(str);
         staP2pStartGrpForm->oper_chn_flag=1;
      }
      else if(strcasecmp(str, "ssid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staP2pStartGrpForm->ssid, str, WFA_SSID_NAME_LEN-1);
         staP2pStartGrpForm->ssid[WFA_SSID_NAME_LEN-1]='\0';
         staP2pStartGrpForm->ssid_flag =1;
      }
   }

   wfaEncodeTLV(WFA_STA_P2P_START_GRP_FORMATION_TLV, sizeof(caStaP2pStartGrpForm_t), (BYTE *)staP2pStartGrpForm, aBuf);

   *aLen = 4+sizeof(caStaP2pStartGrpForm_t);

   return WFA_SUCCESS;
}

int xcCmdProcStaP2pDissolve(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   caStaP2pDissolve_t *staP2pDissolve= (caStaP2pDissolve_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staP2pDissolve->intf, str, WFA_IF_NAME_LEN-1);
         staP2pDissolve->intf[WFA_IF_NAME_LEN-1]='\0';
      }
      else if(strcasecmp(str, "groupid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staP2pDissolve->grpId, str, WFA_P2P_GRP_ID_LEN-1);
         staP2pDissolve->grpId[WFA_P2P_GRP_ID_LEN-1]='\0';
      }
   }

   wfaEncodeTLV(WFA_STA_P2P_DISSOLVE_TLV, sizeof(dutCommand_t), (BYTE *)staP2pDissolve, aBuf);

   *aLen = 4+sizeof(caStaP2pDissolve_t);

   return WFA_SUCCESS;
}

int xcCmdProcStaSendP2pInvReq(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   caStaSendP2pInvReq_t *staSendP2pInvReq= (caStaSendP2pInvReq_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staSendP2pInvReq->intf, str, WFA_IF_NAME_LEN-1);
         staSendP2pInvReq->intf[WFA_IF_NAME_LEN-1]='\0';
      }
      else if(strcasecmp(str, "groupid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staSendP2pInvReq->grpId, str, WFA_P2P_GRP_ID_LEN-1);
         staSendP2pInvReq->grpId[WFA_P2P_GRP_ID_LEN-1]='\0';
      }
      else if(strcasecmp(str, "p2pdevid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staSendP2pInvReq->devId, str, WFA_P2P_DEVID_LEN-1);
         staSendP2pInvReq->devId[WFA_P2P_DEVID_LEN-1]='\0';
      }
      else if(strcasecmp(str, "reinvoke") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSendP2pInvReq->reinvoke= atoi(str);
      }
   }

   wfaEncodeTLV(WFA_STA_P2P_SEND_INV_REQ_TLV, sizeof(caStaSendP2pInvReq_t), (BYTE *)staSendP2pInvReq, aBuf);

   *aLen = 4+sizeof(caStaSendP2pInvReq_t);

   return WFA_SUCCESS;
}

int xcCmdProcStaAcceptP2pInvReq(char *pcmdStr, BYTE *aBuf, int *aLen)
{

   caStaAcceptP2pInvReq_t *staAccceptP2pInvReq= (caStaAcceptP2pInvReq_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staAccceptP2pInvReq->intf, str, WFA_IF_NAME_LEN-1);
         staAccceptP2pInvReq->intf[WFA_IF_NAME_LEN-1]='\0';
      }
      else if(strcasecmp(str, "groupid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staAccceptP2pInvReq->grpId, str, WFA_P2P_GRP_ID_LEN-1);
         staAccceptP2pInvReq->grpId[WFA_P2P_GRP_ID_LEN-1]='\0';
      }
      else if(strcasecmp(str, "p2pdevid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staAccceptP2pInvReq->devId, str, WFA_P2P_DEVID_LEN-1);
         staAccceptP2pInvReq->devId[WFA_P2P_DEVID_LEN-1]='\0';
      }
      else if(strcasecmp(str, "reinvoke") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staAccceptP2pInvReq->reinvoke= atoi(str);
      }
   }

   wfaEncodeTLV(WFA_STA_P2P_ACCEPT_INV_REQ_TLV, sizeof(caStaAcceptP2pInvReq_t), (BYTE *)staAccceptP2pInvReq, aBuf);

   *aLen = 4+sizeof(caStaAcceptP2pInvReq_t);

   return WFA_SUCCESS;
}



int xcCmdProcStaSendP2pProvDisReq(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   caStaSendP2pProvDisReq_t *staSendP2pProvDisReq= (caStaSendP2pProvDisReq_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staSendP2pProvDisReq->intf, str, WFA_IF_NAME_LEN-1);
         staSendP2pProvDisReq->intf[WFA_IF_NAME_LEN-1]='\0';
      }
      else if(strcasecmp(str, "configmethod") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staSendP2pProvDisReq->confMethod, str, 15);
      }
      else if(strcasecmp(str, "p2pdevid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staSendP2pProvDisReq->devId, str, WFA_P2P_DEVID_LEN-1);
         staSendP2pProvDisReq->devId[WFA_P2P_DEVID_LEN-1]='\0';
      }
   }

   wfaEncodeTLV(WFA_STA_P2P_SEND_PROV_DIS_REQ_TLV, sizeof(caStaSendP2pProvDisReq_t), (BYTE *)staSendP2pProvDisReq, aBuf);

   *aLen = 4+sizeof(caStaSendP2pProvDisReq_t);

   return WFA_SUCCESS;
}

int xcCmdProcStaSetWpsPbc(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   caStaSetWpsPbc_t *staSetWpsPbc= (caStaSetWpsPbc_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staSetWpsPbc->intf, str, WFA_IF_NAME_LEN-1);
         staSetWpsPbc->intf[WFA_IF_NAME_LEN-1]='\0';
      }
      else if(strcasecmp(str, "groupid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staSetWpsPbc->grpId, str, WFA_P2P_GRP_ID_LEN-1);
         staSetWpsPbc->grpId[WFA_P2P_GRP_ID_LEN-1]='\0';
         staSetWpsPbc->grpid_flag=1;
      }
   }

   wfaEncodeTLV(WFA_STA_WPS_SETWPS_PBC_TLV, sizeof(caStaSetWpsPbc_t), (BYTE *)staSetWpsPbc, aBuf);

   *aLen = 4+sizeof(caStaSetWpsPbc_t);

   return WFA_SUCCESS;
}

int xcCmdProcStaWpsReadPin(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   caStaWpsReadPin_t *staWpsReadPin= (caStaWpsReadPin_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staWpsReadPin->intf, str, WFA_IF_NAME_LEN-1);
         staWpsReadPin->intf[WFA_IF_NAME_LEN-1]='\0';
      }
      else if(strcasecmp(str, "groupid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staWpsReadPin->grpId, str, WFA_P2P_GRP_ID_LEN-1);
         staWpsReadPin->grpId[WFA_P2P_GRP_ID_LEN-1]='\0';
         staWpsReadPin->grpid_flag=1;
      }
   }

   wfaEncodeTLV(WFA_STA_WPS_READ_PIN_TLV, sizeof(caStaWpsReadPin_t), (BYTE *)staWpsReadPin, aBuf);

   *aLen = 4+sizeof(caStaWpsReadPin_t);

   return WFA_SUCCESS;
}


int xcCmdProcStaWpsReadLabel(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   caStaWpsReadLabel_t *staWpsReadLabel= (caStaWpsReadLabel_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staWpsReadLabel->intf, str, WFA_IF_NAME_LEN-1);
         staWpsReadLabel->intf[WFA_IF_NAME_LEN-1]='\0';
      }
      else if(strcasecmp(str, "groupid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staWpsReadLabel->grpId, str, WFA_P2P_GRP_ID_LEN-1);
         staWpsReadLabel->grpId[WFA_P2P_GRP_ID_LEN-1]='\0';
         staWpsReadLabel->grpid_flag=1;
      }
   }

   wfaEncodeTLV(WFA_STA_WPS_READ_LABEL_TLV, sizeof(caStaWpsReadLabel_t), (BYTE *)staWpsReadLabel, aBuf);

   *aLen = 4+sizeof(caStaWpsReadLabel_t);

   return WFA_SUCCESS;
}


int xcCmdProcStaWpsEnterPin(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   caStaWpsEnterPin_t *staWpsEnterPin= (caStaWpsEnterPin_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staWpsEnterPin->intf, str, WFA_IF_NAME_LEN-1);
         staWpsEnterPin->intf[WFA_IF_NAME_LEN-1]='\0';
      }
      else if(strcasecmp(str, "pin") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staWpsEnterPin->wpsPin, str, WFA_WPS_PIN_LEN-1);
         staWpsEnterPin->wpsPin[WFA_WPS_PIN_LEN-1]='\0';
      }
      else if(strcasecmp(str, "groupid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staWpsEnterPin->grpId, str, WFA_P2P_GRP_ID_LEN-1);
         staWpsEnterPin->grpId[WFA_P2P_GRP_ID_LEN-1]='\0';
         staWpsEnterPin->grpid_flag=1;
      }
   }

   wfaEncodeTLV(WFA_STA_WPS_ENTER_PIN_TLV, sizeof(caStaWpsEnterPin_t), (BYTE *)staWpsEnterPin, aBuf);

   *aLen = 4+sizeof(caStaWpsEnterPin_t);

   return WFA_SUCCESS;
}

int xcCmdProcStaGetPsk(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   caStaGetPsk_t *staGetPsk= (caStaGetPsk_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staGetPsk->intf, str, WFA_IF_NAME_LEN-1);
         staGetPsk->intf[WFA_IF_NAME_LEN-1]='\0';
      }
      else if(strcasecmp(str, "groupid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staGetPsk->grpId, str, WFA_P2P_GRP_ID_LEN-1);
         staGetPsk->grpId[WFA_P2P_GRP_ID_LEN-1]='\0';
      }
   }

   wfaEncodeTLV(WFA_STA_P2P_GET_PSK_TLV, sizeof(caStaGetPsk_t), (BYTE *)staGetPsk, aBuf);

   *aLen = 4+sizeof(caStaGetPsk_t);

   return WFA_SUCCESS;
}

int xcCmdProcStaP2pStartAutoGo(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   caStaStartAutoGo_t *staP2pStartAutoGo= (caStaStartAutoGo_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staP2pStartAutoGo->intf, str,WFA_IF_NAME_LEN-1);
         staP2pStartAutoGo->intf[WFA_IF_NAME_LEN-1]='\0';
      }
      else if(strcasecmp(str, "oper_chn") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staP2pStartAutoGo->oper_chn= atoi(str);
      }
      else if(strcasecmp(str, "ssid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staP2pStartAutoGo->ssid, str, WFA_SSID_NAME_LEN-1);
         staP2pStartAutoGo->ssid[WFA_SSID_NAME_LEN-1]='\0';
         staP2pStartAutoGo->ssid_flag =1;
      }
   }

   wfaEncodeTLV(WFA_STA_P2P_START_AUTO_GO_TLV, sizeof(caStaStartAutoGo_t), (BYTE *)staP2pStartAutoGo, aBuf);

   *aLen = 4+sizeof(caStaStartAutoGo_t);

   return WFA_SUCCESS;
}


int xcCmdProcStaP2pReset(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   dutCommand_t *staP2pReset= (dutCommand_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staP2pReset->intf, str, WFA_IF_NAME_LEN-1);
         staP2pReset->intf[WFA_IF_NAME_LEN-1]='\0';
      }
   }

   wfaEncodeTLV(WFA_STA_P2P_RESET_TLV, sizeof(dutCommand_t), (BYTE *)staP2pReset, aBuf);

   *aLen = 4+sizeof(dutCommand_t);

   return WFA_SUCCESS;
}



int xcCmdProcStaGetP2pIpConfig(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   caStaGetP2pIpConfig_t *staGetP2pIpConfig = (caStaGetP2pIpConfig_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staGetP2pIpConfig->intf, str,WFA_IF_NAME_LEN-1);
         staGetP2pIpConfig->intf[WFA_IF_NAME_LEN-1]='\0';
      }
      else if(strcasecmp(str, "groupid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staGetP2pIpConfig->grpId, str, WFA_P2P_GRP_ID_LEN-1);
         staGetP2pIpConfig->grpId[WFA_P2P_GRP_ID_LEN-1]='\0';
      }
   }

   wfaEncodeTLV(WFA_STA_P2P_GET_IP_CONFIG_TLV, sizeof(caStaGetP2pIpConfig_t), (BYTE *)staGetP2pIpConfig, aBuf);

   *aLen = 4+sizeof(caStaGetP2pIpConfig_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaSendServiceDiscoveryReq(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   caStaSendServiceDiscoveryReq_t *staSendServiceDiscoveryReq = (caStaSendServiceDiscoveryReq_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staSendServiceDiscoveryReq->intf, str,WFA_IF_NAME_LEN-1);
         staSendServiceDiscoveryReq->intf[WFA_IF_NAME_LEN-1]='\0';
      }
      else if(strcasecmp(str, "p2pdevid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staSendServiceDiscoveryReq->devId, str, WFA_P2P_DEVID_LEN-1);
         staSendServiceDiscoveryReq->devId[WFA_P2P_DEVID_LEN-1]='\0';
      }
   }

   wfaEncodeTLV(WFA_STA_P2P_SEND_SERVICE_DISCOVERY_REQ_TLV, sizeof(caStaSendServiceDiscoveryReq_t), (BYTE *)staSendServiceDiscoveryReq, aBuf);

   *aLen = 4+sizeof(caStaSendServiceDiscoveryReq_t);

   return WFA_SUCCESS;
}

int xcCmdProcStaSendP2pPresenceReq(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   caStaSendP2pPresenceReq_t *staSendP2pPresenceReq = (caStaSendP2pPresenceReq_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staSendP2pPresenceReq->intf, str,WFA_IF_NAME_LEN-1);
         staSendP2pPresenceReq->intf[WFA_IF_NAME_LEN-1]='\0';
      }
      else if(strcasecmp(str, "interval") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSendP2pPresenceReq->interval= atoll(str);
      }
      else if(strcasecmp(str, "duration") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSendP2pPresenceReq->duration= atoll(str);
      }
   }

   wfaEncodeTLV(WFA_STA_P2P_SEND_PRESENCE_REQ_TLV, sizeof(caStaSendP2pPresenceReq_t), (BYTE *)staSendP2pPresenceReq, aBuf);

   *aLen = 4+sizeof(caStaSendP2pPresenceReq_t);

   return WFA_SUCCESS;
}


int xcCmdProcStaSetSleepReq(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   caStaSetSleep_t *staSetSleep = (caStaSetSleep_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staSetSleep->intf, str,WFA_IF_NAME_LEN-1);
         staSetSleep->intf[WFA_IF_NAME_LEN-1]='\0';
      }
      else if(strcasecmp(str, "groupid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staSetSleep->grpId, str, WFA_P2P_GRP_ID_LEN-1);
         staSetSleep->grpId[WFA_P2P_GRP_ID_LEN-1]='\0';
      }
   }

   wfaEncodeTLV(WFA_STA_P2P_SET_SLEEP_TLV, sizeof(caStaSetSleep_t), (BYTE *)staSetSleep, aBuf);

   *aLen = 4+sizeof(caStaSetSleep_t);

   return WFA_SUCCESS;
}


int xcCmdProcStaSetOpportunistcPsReq(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   caStaSetOpprPs_t *staSetOpprPs = (caStaSetOpprPs_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staSetOpprPs->intf, str,WFA_IF_NAME_LEN-1);
         staSetOpprPs->intf[WFA_IF_NAME_LEN-1]='\0';
      }
      else if(strcasecmp(str, "ctwindow") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         staSetOpprPs->ctwindow= atoi(str);
      }
      else if(strcasecmp(str, "groupid") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staSetOpprPs->grpId, str, WFA_P2P_GRP_ID_LEN-1);
         staSetOpprPs->grpId[WFA_P2P_GRP_ID_LEN-1]='\0';
      }
   }

   wfaEncodeTLV(WFA_STA_P2P_SET_OPPORTUNISTIC_PS_TLV, sizeof(caStaSetOpprPs_t), (BYTE *)staSetOpprPs, aBuf);

   *aLen = 4+sizeof(caStaSetOpprPs_t);

   return WFA_SUCCESS;
}
int xcCmdProcStaAddARPTableEntry(char *pcmdStr, BYTE *aBuf, int *aLen)
{
   caStaAddARPTableEntry_t *staAddARPTableEntry = (caStaAddARPTableEntry_t *) (aBuf+sizeof(wfaTLV));
   char *str;

   if(aBuf == NULL)
      return WFA_FAILURE;

   memset(aBuf, 0, *aLen);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
         break;

      if(strcasecmp(str, "interface") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strncpy(staAddARPTableEntry->intf, str,WFA_IF_NAME_LEN-1);
         staAddARPTableEntry->intf[WFA_IF_NAME_LEN-1]='\0';
      }
      else if(strcasecmp(str, "macaddress") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strcpy(staAddARPTableEntry->macaddress, str);
      }
      else if(strcasecmp(str, "ipaddress") == 0)
      {
         str = strtok_r(NULL, ",", &pcmdStr);
         strcpy(staAddARPTableEntry->ipaddress, str);
      }
   }

   wfaEncodeTLV(WFA_STA_P2P_ADD_ARP_TABLE_ENTRY_TLV, sizeof(caStaAddARPTableEntry_t), (BYTE *)staAddARPTableEntry, aBuf);

   *aLen = 4+sizeof(caStaAddARPTableEntry_t);

   return WFA_SUCCESS;
}
int xcCmdProcStaBlockICMPResponse(char *pcmdStr, BYTE *aBuf, int *aLen)
{
	caStaBlockICMPResponse_t *staBlockICMPResponse = (caStaBlockICMPResponse_t *) (aBuf+sizeof(wfaTLV));
	char *str;

	if(aBuf == NULL)
		return WFA_FAILURE;

	memset(aBuf, 0, *aLen);

	for(;;)
	{
		str = strtok_r(NULL, ",", &pcmdStr);
		if(str == NULL || str[0] == '\0')
			break;

		if(strcasecmp(str, "interface") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staBlockICMPResponse->intf, str,WFA_IF_NAME_LEN-1);
			staBlockICMPResponse->intf[WFA_IF_NAME_LEN-1]='\0';
		}
		else if(strcasecmp(str, "groupid") == 0)
        {
			str = strtok_r(NULL, ",", &pcmdStr);
			strcpy(staBlockICMPResponse->grpId, str);
        }
		else if(strcasecmp(str, "ipaddress") == 0)
        {
			str = strtok_r(NULL, ",", &pcmdStr);
			strcpy(staBlockICMPResponse->ipaddress, str);
        }

	}

	wfaEncodeTLV(WFA_STA_P2P_ADD_ARP_TABLE_ENTRY_TLV, sizeof(caStaBlockICMPResponse_t), (BYTE *)staBlockICMPResponse, aBuf);

	*aLen = 4+sizeof(caStaBlockICMPResponse_t);

	return WFA_SUCCESS;
}
#endif /* MTK_P2P_SIGMA */

#ifdef MTK_HS20_SIGMA

int xcCmdProcStaResetParm(char *pcmdStr, BYTE *aBuf, int *aLen)
{
	caStaResetParm_t *staResetParm = (caStaResetParm_t *) (aBuf+sizeof(wfaTLV));
	char *str;

	DPRINT_INFO(WFA_OUT, "start %s ...\n", __func__);

	if(aBuf == NULL)
		return WFA_FAILURE;

	memset(aBuf, 0, *aLen);

	//Init
	staResetParm->intf[0] = '\0';
	staResetParm->hs2_cache_profile[0] = '\0';
	staResetParm->arp[0] = '\0';

	for(;;)
	{
		str = strtok_r(NULL, ",", &pcmdStr);
		if(str == NULL || str[0] == '\0')
			break;

		if(strcasecmp(str, "interface") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staResetParm->intf, str,WFA_IF_NAME_LEN-1);
			staResetParm->intf[WFA_IF_NAME_LEN-1]='\0';
		}
		else if(strcasecmp(str, "arp") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strcpy(staResetParm->arp, str);
			staResetParm->arp[WFA_IP_ADDR_STR_LEN-1]='\0';
		}
		else if(strcasecmp(str, "HS2_Cache_Profile") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strcpy(staResetParm->hs2_cache_profile, str);
			staResetParm->hs2_cache_profile[32-1]='\0';
		}

	}

	wfaEncodeTLV(WFA_STA_HS20_STA_RESET_PARM, sizeof(caStaResetParm_t), (BYTE *)staResetParm, aBuf);

	*aLen = 4+sizeof(caStaResetParm_t);

	return WFA_SUCCESS;
}


int xcCmdProcStaGetKey(char *pcmdStr, BYTE *aBuf, int *aLen)
{
	caStaGetKey_t *staGetKey = (caStaGetKey_t *) (aBuf+sizeof(wfaTLV));
	char *str;

	DPRINT_INFO(WFA_OUT, "start %s ...\n", __func__);

	if(aBuf == NULL)
		return WFA_FAILURE;

	memset(aBuf, 0, *aLen);

	for(;;)
	{
		str = strtok_r(NULL, ",", &pcmdStr);
		if(str == NULL || str[0] == '\0')
			break;

		if(strcasecmp(str, "interface") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staGetKey->intf, str,WFA_IF_NAME_LEN-1);
			staGetKey->intf[WFA_IF_NAME_LEN-1]='\0';
		}
		else if(strcasecmp(str, "KeyType") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strcpy(staGetKey->keyType, str);
			staGetKey->keyType[WFA_KEY_TYPE_LEN-1]='\0';
		}

	}

	wfaEncodeTLV(WFA_STA_HS20_GET_GTK_PTK_KEY_TLV, sizeof(caStaGetKey_t), (BYTE *)staGetKey, aBuf);

	*aLen = 4+sizeof(caStaGetKey_t);

	return WFA_SUCCESS;
}

int xcCmdProcStaBssidPool(char *pcmdStr, BYTE *aBuf, int *aLen)
{
	caStaBssidPool_t *staBssidPool = (caStaBssidPool_t *) (aBuf+sizeof(wfaTLV));
	char *str;
	int i;

	DPRINT_INFO(WFA_OUT, "start %s ...\n", __func__);

	if(aBuf == NULL)
		return WFA_FAILURE;

	memset(aBuf, 0, *aLen);

	for(;;)
	{
		str = strtok_r(NULL, ",", &pcmdStr);
		if(str == NULL || str[0] == '\0')
			break;

		if(strcasecmp(str, "interface") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staBssidPool->intf, str,WFA_IF_NAME_LEN-1);
			staBssidPool->intf[WFA_IF_NAME_LEN-1]='\0';
		}
		else if(strcasecmp(str, "bssid_filter") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			staBssidPool->bssid_filter = str[0];
		}
		else if(strcasecmp(str, "bssid_list") == 0)
		{
			for(i=0;i<BSSID_LIST_MAX_LEN;i++){
				str = strtok_r(NULL, " ", &pcmdStr);
				if(str == NULL || str[0] == '\0')
					break;
				strncpy(staBssidPool->bssid_list[i], str, 17);
				staBssidPool->bssid_list[i][17] = ',';
			}
		}

	}

	DPRINT_INFO(WFA_OUT, "%s, staBssidPool->bssid_filter %c ...\n", __func__, (char)staBssidPool->bssid_filter);
	DPRINT_INFO(WFA_OUT, "%s, staBssidPool->bssid_list[0] %s ...\n", __func__, staBssidPool->bssid_list[0]);

	wfaEncodeTLV(WFA_STA_HS20_SET_BSSID_POOL_TLV, sizeof(caStaBssidPool_t), (BYTE *)staBssidPool, aBuf);

	*aLen = 4+sizeof(caStaBssidPool_t);

	return WFA_SUCCESS;
}

int xcCmdProcStaHs2Associate(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    char *str = NULL;
    dutCommand_t staHs2Assoc;

    DPRINT_INFO(WFA_OUT, "start %s ...\n", __func__);

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    memset(&staHs2Assoc, 0, sizeof(staHs2Assoc));
    str = strtok_r(NULL, ",", &pcmdStr);
    str = strtok_r(NULL, ",", &pcmdStr);
    if(str == NULL)
        return WFA_FAILURE;

    memcpy(staHs2Assoc.intf, str, WFA_IF_NAME_LEN-1);
    staHs2Assoc.intf[WFA_IF_NAME_LEN-1] = '\0';
    wfaEncodeTLV(WFA_STA_HS20_STA_HS2_ASSOCIATE_TLV, sizeof(staHs2Assoc), (BYTE *)&staHs2Assoc, aBuf);

    *aLen = 4+sizeof(staHs2Assoc);

    return WFA_SUCCESS;

}


int xcCmdProcDevSendFrame(char *pcmdStr, BYTE *aBuf, int *aLen)
{
	caDevSendFrame_t *devSendFrame = (caDevSendFrame_t *) (aBuf+sizeof(wfaTLV));
	char *str = NULL;

	DPRINT_INFO(WFA_OUT, "start %s ...\n", __func__);

	if(aBuf == NULL)
		return WFA_FAILURE;

	memset(aBuf, 0, *aLen);

	for(;;)
	{
		str = strtok_r(NULL, ",", &pcmdStr);
		if(str == NULL || str[0] == '\0')
			break;

		// Pre-processing
		if(strcasecmp(str, "interface") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(devSendFrame->intf, str, WFA_IF_NAME_LEN-1);
			devSendFrame->intf[WFA_IF_NAME_LEN-1]='\0';
			DPRINT_INFO(WFA_OUT, "interface [%s] ...\n", devSendFrame->intf);
		}
		else if(strcasecmp(str, "program") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(devSendFrame->prog, str, WFA_HS20_PROGRAM_LEN-1);
			devSendFrame->prog[WFA_HS20_PROGRAM_LEN-1]='\0';
			DPRINT_INFO(WFA_OUT, "program [%s] ...\n", devSendFrame->prog);
		}
		else if((strcasecmp(str, "dest") == 0) || (strcasecmp(str, "peer") == 0))
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(devSendFrame->dest, str, WFA_MAC_ADDR_STR_LEN-1);
			devSendFrame->dest[WFA_MAC_ADDR_STR_LEN-1]='\0';
			DPRINT_INFO(WFA_OUT, "dest [%s] ...\n", devSendFrame->dest);
		}
		else if(strcasecmp(str, "Type") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(devSendFrame->type, str, WFA_HS20_TYPE_LEN-1);
			devSendFrame->type[WFA_HS20_TYPE_LEN-1]='\0';
			DPRINT_INFO(WFA_OUT, "Type [%s] ...\n", devSendFrame->type);
			
		}
		else if(strcasecmp(str, "framename") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(devSendFrame->framename, str, WFA_HS20_FRAMENAME_LEN-1);
			devSendFrame->framename[WFA_HS20_FRAMENAME_LEN-1]='\0';
			DPRINT_INFO(WFA_OUT, "framename [%s] ...\n", devSendFrame->framename);
		}
		else if(strcasecmp(str, "SenderMAC") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(devSendFrame->SenderMac, str, WFA_MAC_ADDR_STR_LEN-1);
			devSendFrame->SenderMac[WFA_MAC_ADDR_STR_LEN-1]='\0';
			DPRINT_INFO(WFA_OUT, "SenderMac [%s] ...\n", devSendFrame->SenderMac);
		}
		else if(strcasecmp(str, "DestIP") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(devSendFrame->DestIP, str, WFA_IP_ADDR_STR_LEN-1);
			devSendFrame->DestIP[WFA_IP_ADDR_STR_LEN-1]='\0';
			DPRINT_INFO(WFA_OUT, "DestIP [%s] ...\n", devSendFrame->DestIP);
		}		

		// 11u ANQP GAS
		else if(strcasecmp(str, "ANQP_CAP_LIST") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			if(str[0] == '1')
				devSendFrame->fg_ANQP_CAPABILITY_LIST = 1;
			DPRINT_INFO(WFA_OUT, "ANQP_CAPABILITY_LIST ...\n");
		}
		else if(strcasecmp(str, "NAI_REALM_LIST") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			if(str[0] == '1')
				devSendFrame->fg_ANQP_NAI_REALM_LIST = 1;
			DPRINT_INFO(WFA_OUT, "ANQP_NAI_REALM_LIST ...\n");
		}
		else if(strcasecmp(str, "3GPP_INFO") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			if(str[0] == '1')
				devSendFrame->fg_ANQP_3GPP_CELLULAR_NETWORK_INFORMATION = 1;
			DPRINT_INFO(WFA_OUT, "ANQP_3GPP_CELLULAR_NETWORK_INFORMATION ...\n");
		}
		else if(strcasecmp(str, "DOMAIN_LIST") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			if(str[0] == '1')
				devSendFrame->fg_ANQP_DOMAIN_NAME_LIST = 1;
			DPRINT_INFO(WFA_OUT, "DOMAIN_LIST ...\n");
		}
		else if(strcasecmp(str, "VENUE_NAME") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			if(str[0] == '1')
				devSendFrame->fg_ANQP_VENUE_NAME_INFORMATION = 1;
			DPRINT_INFO(WFA_OUT, "ANQP_VENUE_NAME_INFORMATION ...\n");
		}

		// HS20 ANQP GAS
		else if(strcasecmp(str, "HS_CAP_LIST") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			if(str[0] == '1')
				devSendFrame->fg_HS20_CAPABILITY_LIST = 1;
			DPRINT_INFO(WFA_OUT, "HS_CAP_LIST ...\n");
		}
		else if(strcasecmp(str, "OPER_NAME") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			if(str[0] == '1')
				devSendFrame->fg_HS20_OPERATOR_FRIENDLY_NAME = 1;
			DPRINT_INFO(WFA_OUT, "OPER_NAME ...\n");
		}
		else if(strcasecmp(str, "NAI_HOME_REALM_LIST") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			if(str[0] == '1')
				devSendFrame->fg_HS20_NAI_HOME_REALM_QUERY = 1;
			DPRINT_INFO(WFA_OUT, "NAI_HOME_REALM_LIST ...\n");
		}
		else if(strcasecmp(str, "WAN_MAT") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			if(str[0] == '1')
				devSendFrame->fg_HS20_WAN_METRICS = 1;
			DPRINT_INFO(WFA_OUT, "WAN_MAT ...\n");
		}
		else if(strcasecmp(str, "OP_CLASS") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			if(str[0] == '1')
				devSendFrame->fg_HS20_OP_CLASS = 1;
			DPRINT_INFO(WFA_OUT, "OP_CLASS ...\n");
		}
		else if(strcasecmp(str, "OSU_PROVIDER_LIST") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			if(str[0] == '1')
				devSendFrame->fg_HS20_OSU_PROVIDER_LIST = 1;
			DPRINT_INFO(WFA_OUT, "OSU_PROVIDER_LIST ...\n");
		}
		else if(strcasecmp(str, "ICON_REQUEST") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			devSendFrame->fg_HS20_ICON_REQ = 1;
			strncpy(devSendFrame->hs20_icon_req, str, WFA_HS20_ICON_LEN-1);
			devSendFrame->hs20_icon_req[WFA_HS20_ICON_LEN-1]='\0';
			DPRINT_INFO(WFA_OUT, "ICON_REQUEST [%s] ...\n", devSendFrame->hs20_icon_req);
		}		
		else if(strcasecmp(str, "NET_AUTH_TYPE") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			if(str[0] == '1')
				devSendFrame->fg_ANQP_NETWORK_AUTHENTICATION_TYPE_INFORMATION = 1;
			DPRINT_INFO(WFA_OUT, "NET_AUTH_TYPE ...\n");
		}

	}

	wfaEncodeTLV(WFA_STA_HS20_DEV_SEND_FRAME_TLV, sizeof(caDevSendFrame_t), (BYTE *)devSendFrame, aBuf);
	*aLen = 4+sizeof(caDevSendFrame_t);
	return WFA_SUCCESS;

}


int xcCmdProcStaAddCredential(char *pcmdStr, BYTE *aBuf, int *aLen)
{
	caStaAddCredential_t *staAddCred = (caStaAddCredential_t *) (aBuf+sizeof(wfaTLV));
	char *str;

	DPRINT_INFO(WFA_OUT, "start %s ...\n", __func__);

	if(aBuf == NULL)
		return WFA_FAILURE;

	memset(aBuf, 0, *aLen);

	staAddCred->intf[0] = '\0';
	staAddCred->type[0] = '\0';
	staAddCred->username[0] = '\0';
	staAddCred->password[0] = '\0';
	staAddCred->imsi[0] = '\0';
	staAddCred->plmn_mnc[0] = '\0';
	staAddCred->plmn_mcc[0] = '\0';
	staAddCred->root_ca[0] = '\0';
	staAddCred->realm[0] = '\0';
	staAddCred->prefer = 0;
	staAddCred->fqdn[0] = '\0';

	for(;;)
	{
		str = strtok_r(NULL, ",", &pcmdStr);
		if(str == NULL || str[0] == '\0')
			break;

		if(strcasecmp(str, "interface") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staAddCred->intf, str, WFA_IF_NAME_LEN-1);
			staAddCred->intf[WFA_IF_NAME_LEN-1]='\0';
			DPRINT_INFO(WFA_OUT, "[%s] staAddCred->intf : %s ...\n", __func__, staAddCred->intf);
		}
		else if(strcasecmp(str, "type") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staAddCred->type, str, WFA_HS20_TYPE_LEN-1);
			staAddCred->type[WFA_HS20_TYPE_LEN-1]='\0';
			DPRINT_INFO(WFA_OUT, "[%s] staAddCred->type : %s ...\n", __func__, staAddCred->type);
		}
		else if(strcasecmp(str, "username") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staAddCred->username, str, WFA_HS20_LEN_32-1);
			staAddCred->username[WFA_HS20_LEN_32-1]='\0';
			DPRINT_INFO(WFA_OUT, "[%s] staAddCred->username : %s ...\n", __func__, staAddCred->username);
		}
		else if(strcasecmp(str, "password") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staAddCred->password, str, WFA_HS20_LEN_256-1);
			staAddCred->password[WFA_HS20_LEN_256-1]='\0';
			DPRINT_INFO(WFA_OUT, "[%s] staAddCred->password : %s ...\n", __func__, staAddCred->password);
		}
		else if(strcasecmp(str, "imsi") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staAddCred->imsi, str, WFA_HS20_LEN_32-1);
			staAddCred->imsi[WFA_HS20_LEN_32-1]='\0';
			DPRINT_INFO(WFA_OUT, "[%s] staAddCred->imsi : %s ...\n", __func__, staAddCred->imsi);
		}
		else if(strcasecmp(str, "plmn_mnc") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staAddCred->plmn_mnc, str, WFA_HS20_LEN_32-1);
			staAddCred->plmn_mnc[WFA_HS20_LEN_32-1]='\0';
			DPRINT_INFO(WFA_OUT, "[%s] staAddCred->plmn_mnc : %s ...\n", __func__, staAddCred->plmn_mnc);
		}
		else if(strcasecmp(str, "plmn_mcc") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staAddCred->plmn_mcc, str, WFA_HS20_LEN_32-1);
			staAddCred->plmn_mcc[WFA_HS20_LEN_32-1]='\0';
			DPRINT_INFO(WFA_OUT, "[%s] staAddCred->plmn_mcc : %s ...\n", __func__, staAddCred->plmn_mcc);
		}
		else if(strcasecmp(str, "root_ca") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staAddCred->root_ca, str, WFA_HS20_LEN_32-1);
			staAddCred->root_ca[WFA_HS20_LEN_32-1]='\0';
			DPRINT_INFO(WFA_OUT, "[%s] staAddCred->root_ca : %s ...\n", __func__, staAddCred->root_ca);
		}
		else if(strcasecmp(str, "realm") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staAddCred->realm, str, WFA_HS20_LEN_32-1);
			staAddCred->realm[WFA_HS20_LEN_32-1]='\0';
			DPRINT_INFO(WFA_OUT, "[%s] staAddCred->realm : %s ...\n", __func__, staAddCred->realm);
		}
		else if(strcasecmp(str, "prefer") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			staAddCred->prefer = atoi(str);
			DPRINT_INFO(WFA_OUT, "[%s] staAddCred->prefer : %d ...\n", __func__, staAddCred->prefer);
		}
		else if(strcasecmp(str, "Home_FQDN") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staAddCred->fqdn, str, WFA_HS20_LEN_32-1);
			staAddCred->fqdn[WFA_HS20_LEN_32-1]='\0';
			DPRINT_INFO(WFA_OUT, "[%s] staAddCred->fqdn : %s ...\n", __func__, staAddCred->fqdn);
		}
		else if(strcasecmp(str, "clientCertificate") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staAddCred->clientCA, str, WFA_HS20_LEN_32-1);
			staAddCred->clientCA[WFA_HS20_LEN_32-1]='\0';
			DPRINT_INFO(WFA_OUT, "[%s] staAddCred->clientCA : %s ...\n", __func__, staAddCred->clientCA);
		}
	}

	wfaEncodeTLV(WFA_STA_HS20_STA_ADD_CREDENTIAL_TLV, sizeof(caStaAddCredential_t), (BYTE *)staAddCred, aBuf);

	*aLen = 4+sizeof(caStaAddCredential_t);

	return WFA_SUCCESS;
}


int xcCmdProcStaScan(char *pcmdStr, BYTE *aBuf, int *aLen)
{

	caStaScan_t *staScan = (caStaScan_t *) (aBuf+sizeof(wfaTLV));
	char *str;

	DPRINT_INFO(WFA_OUT, "start %s ...\n", __func__);

	if(aBuf == NULL)
		return WFA_FAILURE;

	memset(aBuf, 0, *aLen);

	staScan->intf[0] = '\0';
	staScan->hessid[0] = '\0';
	staScan->accs_net_type[0] = '\0';

	for(;;)
	{
		str = strtok_r(NULL, ",", &pcmdStr);
		if(str == NULL || str[0] == '\0')
			break;

		if(strcasecmp(str, "interface") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staScan->intf, str, WFA_IF_NAME_LEN-1);
			staScan->intf[WFA_IF_NAME_LEN-1]='\0';
			DPRINT_INFO(WFA_OUT, "[%s] staScan->intf : %s ...\n", __func__, staScan->intf);
		}
		else if(strcasecmp(str, "hessid") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staScan->hessid, str, WFA_MAC_ADDR_STR_LEN-1);
			staScan->hessid[WFA_MAC_ADDR_STR_LEN-1]='\0';
			DPRINT_INFO(WFA_OUT, "[%s] staScan->hessid : %s ...\n", __func__, staScan->hessid);
		}
		else if(strcasecmp(str, "accs_net_type") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staScan->accs_net_type, str, 2);
			staScan->accs_net_type[2]='\0';
			DPRINT_INFO(WFA_OUT, "[%s] staScan->accs_net_type : %d ...\n", __func__, staScan->accs_net_type);
		}
	}

	wfaEncodeTLV(WFA_STA_HS20_STA_SCAN_TLV, sizeof(caStaScan_t), (BYTE *)staScan, aBuf);

	*aLen = 4+sizeof(caStaScan_t);

	return WFA_SUCCESS;

}


int xcCmdProcDevSetParameter(char *pcmdStr, BYTE *aBuf, int *aLen)
{

	caDevSetParameter_t *devSetParameter = (caDevSetParameter_t *) (aBuf+sizeof(wfaTLV));
	char *str;

	DPRINT_INFO(WFA_OUT, "start %s ...\n", __func__);

	if(aBuf == NULL)
		return WFA_FAILURE;

	memset(aBuf, 0, *aLen);

	devSetParameter->intf[0]  = '\0';
	devSetParameter->clearARP = 0;


	for(;;)
	{
		str = strtok_r(NULL, ",", &pcmdStr);
		if(str == NULL || str[0] == '\0')
			break;

		if(strcasecmp(str, "interface") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(devSetParameter->intf, str, WFA_IF_NAME_LEN-1);
			devSetParameter->intf[WFA_IF_NAME_LEN-1]='\0';
			DPRINT_INFO(WFA_OUT, "[%s] devSetParameter->intf : %s ...\n", __func__, devSetParameter->intf);
		}
		else if(strcasecmp(str, "ClearARP") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			devSetParameter->clearARP= atoi(str);
			DPRINT_INFO(WFA_OUT, "[%s] devSetParameter->clearARP : %d ...\n", __func__, devSetParameter->clearARP);
		}

	}

	wfaEncodeTLV(WFA_STA_HS20_DEV_SET_PARAMETER_TLV, sizeof(caDevSetParameter_t), (BYTE *)devSetParameter, aBuf);

	*aLen = 4+sizeof(caDevSetParameter_t);

	return WFA_SUCCESS;

}


int xcCmdProcDevGetParameter(char *pcmdStr, BYTE *aBuf, int *aLen)
{
	return WFA_FAILURE;
}


int xcCmdProcStaOSU(char *pcmdStr, BYTE *aBuf, int *aLen)
{

	caStaOSU_t *staOSU = (caStaOSU_t *) (aBuf+sizeof(wfaTLV));
	char *str;

	DPRINT_INFO(WFA_OUT, "start %s ...\n", __func__);

	if(aBuf == NULL)
		return WFA_FAILURE;

	memset(aBuf, 0, *aLen);

	staOSU->intf[0]  = '\0';
	staOSU->fname[0] = '\0';


	for(;;)
	{
		str = strtok_r(NULL, ",", &pcmdStr);
		if(str == NULL || str[0] == '\0')
			break;

		if(strcasecmp(str, "interface") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staOSU->intf, str, WFA_IF_NAME_LEN-1);
			staOSU->intf[WFA_IF_NAME_LEN-1]='\0';
			DPRINT_INFO(WFA_OUT, "[%s] staOSU->intf : %s ...\n", __func__, staOSU->intf);
		}
		else if(strcasecmp(str, "osuFriendlyName") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staOSU->fname, str, WFA_HS20_LEN_64-1);
			staOSU->fname[WFA_HS20_LEN_64-1]='\0';
			DPRINT_INFO(WFA_OUT, "[%s] staOSU->fname : %s ...\n", __func__, staOSU->fname);

		}

	}

	wfaEncodeTLV(WFA_STA_HS20_STA_OSU_TLV, sizeof(caStaOSU_t), (BYTE *)staOSU, aBuf);

	*aLen = 4+sizeof(caStaOSU_t);

	return WFA_SUCCESS;

}


int xcCmdProcStaPolicyUpdate(char *pcmdStr, BYTE *aBuf, int *aLen)
{

	caStaPolicyUpdate_t *staPU = (caStaPolicyUpdate_t *) (aBuf+sizeof(wfaTLV));
	char *str;

	DPRINT_INFO(WFA_OUT, "start %s ...\n", __func__);

	if(aBuf == NULL)
		return WFA_FAILURE;

	memset(aBuf, 0, *aLen);

	staPU->intf[0]  	= '\0';
	staPU->PolicyUpdate = 0;
	staPU->Timeout		= 0;

	for(;;)
	{
		str = strtok_r(NULL, ",", &pcmdStr);
		if(str == NULL || str[0] == '\0')
			break;

		if(strcasecmp(str, "interface") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			strncpy(staPU->intf, str, WFA_IF_NAME_LEN-1);
			staPU->intf[WFA_IF_NAME_LEN-1]='\0';
			DPRINT_INFO(WFA_OUT, "[%s] staPU->intf : %s ...\n", __func__, staPU->intf);
		}
		else if(strcasecmp(str, "PolicyUpdate") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			staPU->PolicyUpdate = atoi(str);
			DPRINT_INFO(WFA_OUT, "[%s] staPU->PolicyUpdate : %d ...\n", __func__, staPU->PolicyUpdate);
		}
		else if(strcasecmp(str, "Timeout") == 0)
		{
			str = strtok_r(NULL, ",", &pcmdStr);
			staPU->Timeout = atoi(str);
			DPRINT_INFO(WFA_OUT, "[%s] staPU->Timeout : %d ...\n", __func__, staPU->Timeout);
		}

	}

	wfaEncodeTLV(WFA_STA_HS20_STA_POLICY_UPDATE_TLV, sizeof(caStaPolicyUpdate_t), (BYTE *)staPU, aBuf);

	*aLen = 4+sizeof(caStaPolicyUpdate_t);

	return WFA_SUCCESS;

}


#endif

int xcCmdProcStaSetPwrSave(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    caStaSetPwrSave_t *setps = (caStaSetPwrSave_t *) (aBuf+sizeof(wfaTLV));
    char *str;

    if(aBuf == NULL)
       return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
           break;

        if(strcasecmp(str, "interface") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           strncpy(setps->intf, str, 15);
        }
        else if(strcasecmp(str, "mode") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           strncpy(setps->mode, str, 64);
        }
    }

    wfaEncodeTLV(WFA_STA_SET_PWRSAVE_TLV, sizeof(caStaSetPwrSave_t), (BYTE *)setps, aBuf);
    *aLen = 4+sizeof(caStaSetPwrSave_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaSetWMM(char *pcmdStr, BYTE *aBuf, int *aLen)
{
#ifdef WFA_WMM_AC
    caStaSetWMM_t *setwmm = (caStaSetWMM_t *) (aBuf+sizeof(wfaTLV));
    char *str;
    wfaTLV *hdr = (wfaTLV *)aBuf;

    DPRINT_INFO(WFA_OUT, "start xcCmdProcStaSetWMM ...\n");
    DPRINT_INFO(WFA_OUT, "params:  %s\n", pcmdStr);
    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);
    /* Some default values, in case they are not specified*/
    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setwmm->intf, str, 15);
        }
        else if(strcasecmp(str, "GROUP") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
	    if(strcasecmp(str,"WMMAC") == 0)
              setwmm->group = GROUP_WMMAC;
	    else if(strcasecmp(str,"WMM-CONFIG") == 0)
            {
              setwmm->group = GROUP_WMMCONF;
              setwmm->actions.config.frag_thr = 2346;
              setwmm->actions.config.rts_thr = 2346;
              setwmm->actions.config.wmm = 1;
            }
        }
        else if(strcasecmp(str, "ACTION") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
	    if(strcasecmp(str,"addts") == 0)
            {
               //Put default values for the tspec element
	       setwmm->action = WMMAC_ADDTS;
               setwmm->actions.addts.accesscat = WMMAC_AC_BE;
               setwmm->actions.addts.tspec.tsinfo.dummy1 = 1;
               setwmm->actions.addts.tspec.tsinfo.dummy2 = 0;
            }
	    else if(strcasecmp(str,"delts") == 0)
	       setwmm->action = WMMAC_DELTS;
	    DPRINT_INFO(WFA_OUT,"action is %d\n",setwmm->action);
        }
        else if(strcasecmp(str, "RTS_thr") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.config.rts_thr = atoi(str);
        }
        else if(strcasecmp(str, "wmm") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
	    if(atoi(str) != 0)
            setwmm->actions.config.wmm = 1;
	    else
            setwmm->actions.config.wmm = 0;
        }
        else if(strcasecmp(str, "Frag_thr") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.config.frag_thr = atoi(str);
        }
        else if(strcasecmp(str, "DIALOG_TOKEN") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.addts.dialog_token = atoi(str);
        }
        else if(strcasecmp(str, "TID") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            if(setwmm->action == WMMAC_ADDTS)
               setwmm->actions.addts.tspec.tsinfo.TID  = atoi(str);
            else
               setwmm->actions.delts = atoi(str);
        }
        else if(strcasecmp(str, "SENDTRIG") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
	    	if(strcasecmp(str,"true") == 0)
            	   setwmm->send_trig=1;
			else
            	   setwmm->send_trig=0;
        }
        else if(strcasecmp(str, "DEST") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setwmm->dipaddr, str, 15);
        }
        else if(strcasecmp(str, "trigac") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            if(strcasecmp(str,"VO") == 0)
               setwmm->trig_ac= WMMAC_AC_VO;
            else if(strcasecmp(str,"VI") == 0)
               setwmm->trig_ac= WMMAC_AC_VI;
            else if(strcasecmp(str,"BE") == 0)
               setwmm->trig_ac= WMMAC_AC_BE;
            else if(strcasecmp(str,"BK") == 0)
               setwmm->trig_ac= WMMAC_AC_BK;
        }
        else if(strcasecmp(str, "DIRECTION") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
	    if(strcasecmp(str,"UP") == 0)
               setwmm->actions.addts.tspec.tsinfo.direction = WMMAC_UPLINK;
	    else if(strcasecmp(str,"DOWN") == 0)
               setwmm->actions.addts.tspec.tsinfo.direction = WMMAC_DOWNLINK;
	    else if(strcasecmp(str,"BIDI") == 0)
               setwmm->actions.addts.tspec.tsinfo.direction = WMMAC_BIDIR;
        }
        else if(strcasecmp(str, "PSB") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
	    if(strcasecmp(str,"UAPSD") == 0)
            setwmm->actions.addts.tspec.tsinfo.PSB = 1;
	    else
            setwmm->actions.addts.tspec.tsinfo.PSB = 0;
        }
        else if(strcasecmp(str, "UP") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.addts.tspec.tsinfo.UP = atoi(str);
        }
        else if(strcasecmp(str, "Fixed") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            if(strcasecmp(str, "true") == 0)
               setwmm->actions.addts.tspec.Fixed = 1;
            else
               setwmm->actions.addts.tspec.Fixed = 0;
        }
        //else if(strcasecmp(str, "MSDU") == 0)
        else if(strcasecmp(str, "SIZE") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.addts.tspec.size = atoi(str);
        }
        else if(strcasecmp(str, "MAXSIZE") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.addts.tspec.maxsize = atoi(str);
        }
        else if(strcasecmp(str, "MIN_SRVC_INTRVL") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.addts.tspec.min_srvc = atoi(str);
        }
        else if(strcasecmp(str, "MAX_SRVC_INTRVL") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.addts.tspec.max_srvc = atoi(str);
        }
        else if(strcasecmp(str, "INACTIVITY") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.addts.tspec.inactivity = atoi(str);
        }
        else if(strcasecmp(str, "SUSPENSION") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.addts.tspec.suspension = atoi(str);
        }
        else if(strcasecmp(str, "SRVCSTARTTIME") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.addts.tspec.srvc_strt_tim = atoi(str);
        }
        else if(strcasecmp(str, "MINDATARATE") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.addts.tspec.mindatarate = atoi(str);
        }
        else if(strcasecmp(str, "MEANDATARATE") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.addts.tspec.meandatarate = atoi(str);
        }
        else if(strcasecmp(str, "PEAKDATARATE") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.addts.tspec.peakdatarate = atoi(str);
        }
        else if(strcasecmp(str, "BURSTSIZE") == 0
                      || strcasecmp(str, "MSDUAGGR") == 0)
        {
            // which is used is depending on BurstSizeDef
            // additional checking will be needed.
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.addts.tspec.burstsize = atoi(str);
        }
        else if(strcasecmp(str, "DELAYBOUND") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.addts.tspec.delaybound = atoi(str);
        }
        else if(strcasecmp(str, "PHYRATE") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.addts.tspec.PHYrate = atoi(str);
        }
        else if(strcasecmp(str, "SBA") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.addts.tspec.sba = atof(str);
        }
        else if(strcasecmp(str, "MEDIUM_TIME") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            setwmm->actions.addts.tspec.medium_time = atoi(str);
        }
        else if(strcasecmp(str, "ACCESSCAT") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
	    if(strcasecmp(str,"VO") == 0)
               setwmm->actions.addts.accesscat = WMMAC_AC_VO;
	    else if(strcasecmp(str,"VI") == 0)
               setwmm->actions.addts.accesscat = WMMAC_AC_VI;
	    else if(strcasecmp(str,"BE") == 0)
               setwmm->actions.addts.accesscat = WMMAC_AC_BE;
	    else if(strcasecmp(str,"BK") == 0)
               setwmm->actions.addts.accesscat = WMMAC_AC_BK;
        }
        else if(strcasecmp(str, "infoAck") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
	    if(strcasecmp(str,"HT") == 0)
            {
                setwmm->actions.addts.tspec.tsinfo.infoAck = 1;
            }
            else // normal
            {
                setwmm->actions.addts.tspec.tsinfo.infoAck = 0;
            }
        }
        else if(strcasecmp(str, "BurstSizeDef") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
	    if(strcasecmp(str,"SET") == 0)
            {
                setwmm->actions.addts.tspec.tsinfo.bstSzDef = 1;
            }
            else // CLEAR
            {
                setwmm->actions.addts.tspec.tsinfo.bstSzDef = 0;
            }
        }
    }
    if(setwmm->action == WMMAC_ADDTS)
       printf("ADDTS AC PARAMS: dialog id: %d, TID: %d, DIRECTION: %d, PSB: %d, UP: %d, INFOACK: %d BURST SIZE DEFN: %d\
	 Fixed %d, MSDU Size: %d, Max MSDU Size %d, MIN SERVICE INTERVAL: %d, MAX SERVICE INTERVAL: %d\
        ,INACTIVITY: %d,SUSPENSION %d,SERVICE START TIME: %d,MIN DATARATE: %d,MEAN DATA RATE: %d\
        , PEAK DATA RATE: %d,BURSTSIZE or MSDU Aggreg: %d,DELAY BOUND: %d,PHYRATE: %d, SPLUSBW: %f,MEDIUM TIME: %d, ACCESSCAT: %d\n"\
        ,setwmm->actions.addts.dialog_token,setwmm->actions.addts.tspec.tsinfo.TID\
        ,setwmm->actions.addts.tspec.tsinfo.direction,setwmm->actions.addts.tspec.tsinfo.PSB,setwmm->actions.addts.tspec.tsinfo.UP\
        ,setwmm->actions.addts.tspec.tsinfo.infoAck,setwmm->actions.addts.tspec.tsinfo.bstSzDef\
        ,setwmm->actions.addts.tspec.Fixed,setwmm->actions.addts.tspec.size, setwmm->actions.addts.tspec.maxsize,\
         setwmm->actions.addts.tspec.min_srvc,\
         setwmm->actions.addts.tspec.max_srvc,setwmm->actions.addts.tspec.inactivity,setwmm->actions.addts.tspec.suspension,\
         setwmm->actions.addts.tspec.srvc_strt_tim,setwmm->actions.addts.tspec.mindatarate,setwmm->actions.addts.tspec.meandatarate\
        ,setwmm->actions.addts.tspec.peakdatarate,setwmm->actions.addts.tspec.burstsize,\
         setwmm->actions.addts.tspec.delaybound,setwmm->actions.addts.tspec.PHYrate,setwmm->actions.addts.tspec.sba,\
	 setwmm->actions.addts.tspec.medium_time,setwmm->actions.addts.accesscat);
    else
	 printf("DELTS AC PARAMS: TID:  %d\n", setwmm->actions.delts);

    hdr->tag =  WFA_STA_SET_WMM_TLV;
    hdr->len = sizeof(caStaSetWMM_t);

    memcpy(aBuf+4, setwmm, sizeof(caStaSetWMM_t));

    *aLen = 4+sizeof(caStaSetWMM_t);
#endif
    return WFA_SUCCESS;
}

int xcCmdProcStaSetEapFAST(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    caStaSetEapFAST_t *setsec = (caStaSetEapFAST_t *) (aBuf+sizeof(wfaTLV));
    char *str;

#ifndef WFA_PC_CONSOLE

    if(aBuf == NULL)
       return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->intf, str, 15);
        }
        else if(strcasecmp(str, "ssid") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->ssid, str, 64);
        }
        else if(strcasecmp(str, "username") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strcpy(setsec->username, str);
        }
        else if(strcasecmp(str, "password") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strcpy(setsec->passwd, str);
        }
        else if(strcasecmp(str, "keyMgmtType") == 0)
        {
            str=strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->keyMgmtType, str, strlen(str));
        }
        else if(strcasecmp(str, "encpType") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->encrptype, str, strlen(str));
        }
        else if(strcasecmp(str, "trustedRootCA") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->trustedRootCA, str,31);
        }
        else if(strcasecmp(str, "innerEAP") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strcpy(setsec->innerEAP, str);
        }
        else if(strcasecmp(str, "validateServer") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            if(strcasecmp(str, "yes") == 0)
            {
               setsec->validateServer=1;
            }
            else if(strcasecmp(str, "no") == 0)
            {
               setsec->validateServer=0;
            }
        }
        else if(strcasecmp(str, "pacFile") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strcpy(setsec->pacFileName, str);
        }
        else if(strcasecmp(str, "pmf") == 0)
        {
            str = strtok_r (NULL, ",", &pcmdStr);

            if(strcasecmp(str, "enable") == 0
                || strcasecmp(str, "optional") == 0)
               setsec->pmf = WFA_ENABLED;
            else if(strcasecmp(str, "required") == 0)
               setsec->pmf = WFA_REQUIRED;
            else
               setsec->pmf = WFA_DISABLED;
        }
    }

#endif

    wfaEncodeTLV(WFA_STA_SET_EAPFAST_TLV, sizeof(caStaSetEapFAST_t), (BYTE *)setsec, aBuf);

    *aLen = 4+sizeof(caStaSetEapFAST_t);

    return WFA_SUCCESS;
}


int xcCmdProcStaSetEapAKA(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    caStaSetEapAKA_t *setsec = (caStaSetEapAKA_t *) (aBuf+sizeof(wfaTLV));
    char *str;

#ifndef WFA_PC_CONSOLE

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->intf, str, 15);
        }
        else if(strcasecmp(str, "ssid") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->ssid, str, 64);
        }
        else if(strcasecmp(str, "username") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strcpy(setsec->username, str);
        }
        else if(strcasecmp(str, "password") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strcpy(setsec->passwd, str);
        }
        else if(strcasecmp(str, "keyMgmtType") == 0)
        {
            str=strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->keyMgmtType, str, strlen(str));
        }
        else if(strcasecmp(str, "encpType") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(setsec->encrptype, str, strlen(str));
        }
        else if(strcasecmp(str, "triplet1") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy((char *)setsec->tripletSet[0], str, 63);
            DPRINT_INFO(WFA_OUT, "Triplet1 : %s\n", setsec->tripletSet[0]);
            setsec->tripletCount = 1;
        }
        else if(strcasecmp(str, "triplet2") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy((char *)setsec->tripletSet[1], str, 63);
            DPRINT_INFO(WFA_OUT, "Triplet2 : %s\n", setsec->tripletSet[1]);
            setsec->tripletCount=2;
        }
        else if(strcasecmp(str, "triplet3") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy((char *)setsec->tripletSet[2], str, 63);
            DPRINT_INFO(WFA_OUT, "Triplet1 : %s\n", setsec->tripletSet[2]);
            setsec->tripletCount = 3;
        }
        else if(strcasecmp(str, "pmf") == 0)
        {
            str = strtok_r (NULL, ",", &pcmdStr);

            if(strcasecmp(str, "enable") == 0
                || strcasecmp(str, "optional") == 0)
               setsec->pmf = WFA_ENABLED;
            else if(strcasecmp(str, "required") == 0)
               setsec->pmf = WFA_REQUIRED;
            else
               setsec->pmf = WFA_DISABLED;
        }
    }

#endif

    wfaEncodeTLV(WFA_STA_SET_EAPAKA_TLV, sizeof(caStaSetEapAKA_t), (BYTE *)setsec, aBuf);

    *aLen = 4+sizeof(caStaSetEapAKA_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaSetSystime(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    caStaSetSystime_t *systime = (caStaSetSystime_t *) (aBuf+sizeof(wfaTLV));
    char *str;

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "month") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            systime->month=atoi(str);
            DPRINT_INFO(WFA_OUT, "\n month %i \n", systime->month);
        }
        else if(strcasecmp(str, "date") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            systime->date=atoi(str);
            DPRINT_INFO(WFA_OUT, "\n date %i \n", systime->date);
        }
        else if(strcasecmp(str, "year") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            systime->year=atoi(str);
            DPRINT_INFO(WFA_OUT, "\n year %i \n", systime->year);
        }
        else if(strcasecmp(str, "hours") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            systime->hours=atoi(str);
            DPRINT_INFO(WFA_OUT, "\n hours %i \n", systime->hours);
        }
        else if(strcasecmp(str, "minutes") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            systime->minutes=atoi(str);
            DPRINT_INFO(WFA_OUT, "\n minutes %i \n", systime->minutes);
        }
        else if(strcasecmp(str, "seconds") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            systime->seconds=atoi(str);
            DPRINT_INFO(WFA_OUT, "\n seconds %i \n", systime->seconds);
        }
    }

    wfaEncodeTLV(WFA_STA_SET_SYSTIME_TLV, sizeof(caStaSetSystime_t), (BYTE *)systime, aBuf);

    *aLen = 4+sizeof(caStaSetSystime_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaDisconnect(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    dutCommand_t *disc = (dutCommand_t *) (aBuf+sizeof(wfaTLV));
    char *str;

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(disc->intf, str, 15);
        }
    }

    wfaEncodeTLV(WFA_STA_DISCONNECT_TLV, sizeof(dutCommand_t), (BYTE *)disc, aBuf);

    *aLen = 4+sizeof(dutCommand_t);
    return WFA_SUCCESS;

}

#ifdef WFA_STA_TB
/* Check for enable/disable and return WFA_ENABLE/WFA_DISABLE. WFA_INVALID_BOOL if invalid */
int wfaStandardBoolParsing (char *str)
{
    int rc;

    if(strcasecmp(str, "enable") == 0)
        rc=WFA_ENABLED;
    else if(strcasecmp(str, "disable") == 0)
        rc=WFA_DISABLED;
    else
        rc=WFA_INVALID_BOOL;

    return rc;
}

#endif

int xcCmdProcStaSendFrame(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    char *str;
    dutCommand_t *cmd = (dutCommand_t *) (aBuf+sizeof(wfaTLV));
    caStaSendFrame_t *sf = &cmd->cmdsu.sf;

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(cmd->intf, str, 15);
            DPRINT_INFO(WFA_OUT, "interface %s\n", cmd->intf);
        }
        else if (strcasecmp(str, "frame") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            if (strcasecmp(str, "PMF") == 0)
            {
                pmfFrame_t *pmf = &sf->frameType.pmf;

                sf->frame = FM_TYPE_PMF;

                for(;;)
                {
                    str = strtok_r(NULL, ",", &pcmdStr);
                    if(str == NULL || str[0] == '\0')
                        break;

                    if (strcasecmp(str, "type") == 0)
                    {
                        str = strtok_r(NULL, ",", &pcmdStr);
                        if (strcasecmp(str, "disassoc") == 0)
                        {
                            pmf->type = PMF_TYPE_DISASSOC;
                        }
                        else if (strcasecmp(str, "saquery") == 0)
                        {
                            pmf->type = PMF_TYPE_SAQUERY;
                        }
                        else if (strcasecmp(str, "assocreq") == 0)
                        {
                            pmf->type = PMF_TYPE_ASSOCREQ;
                        }
                        else if (strcasecmp(str, "reassocreq") == 0)
                        {
                            pmf->type = PMF_TYPE_REASSOCREQ;
                        }
                        else if (strcasecmp(str, "deauth") == 0)
                        {
                            pmf->type = PMF_TYPE_DEAUTH;
                        }
                    }
                    else if (strcasecmp(str, "protected") == 0)
                    {
                        str = strtok_r(NULL, ",", &pcmdStr);
                        if (strcasecmp(str, "correctKey") == 0)
                        {
                            pmf->protected = PMF_PROT_CORRECTKEY;
                        }
                        else if (strcasecmp(str, "incorrectKey") == 0)
                        {
                            pmf->protected = PMF_PROT_INCORRECTKEY;
                        }
                        else if (strcasecmp(str, "unprotected") == 0)
                        {
                            pmf->protected = PMF_PROT_UNPROTECTED;
                        }
                    }
                } /* for */
            } /* if PMF */
            else if (strcasecmp(str, "TDLS") == 0)
            {
                tdlsFrame_t *tdls = &sf->frameType.tdls;

                sf->frame = FM_TYPE_TDLS;
                for(;;)
                {
                    str = strtok_r(NULL, ",", &pcmdStr);
                    if(str == NULL || str[0] == '\0')
                        break;

                    if (strcasecmp(str, "type") == 0)
                    {
                        str = strtok_r(NULL, ",", &pcmdStr);
                        if (strcasecmp(str, "discovery") == 0)
                        {
                            tdls->type = TDLS_TYPE_DISCOVERY;
                        }
                        else if (strcasecmp(str, "setup") == 0)
                        {
                            tdls->type = TDLS_TYPE_SETUP;
                        }
                        else if (strcasecmp(str, "teardown") == 0)
                        {
                            tdls->type = TDLS_TYPE_TEARDOWN;
                        }
#if 0 /* TTG to decide whether to have this needed */
                        else if (strcasecmp(str, "channelswitch") == 0)
                        {
                            tdls->type = TDLS_TYPE_CHANNELSWITCH;
                        }
#endif
                        else if (strcasecmp(str, "psnull") == 0)
                        {
                            tdls->type = TDLS_TYPE_NULLFRAME;
                        }
                    }
                    else if (strcasecmp(str, "peer") == 0)
                    {
                        str = strtok_r(NULL, ",", &pcmdStr);
                        strncpy(tdls->peer, str, 17);
                    }
                    else if (strcasecmp(str, "timeout") == 0)
                    {
                        str = strtok_r(NULL, ",", &pcmdStr);
                        tdls->timeout = atoi(str);
                        if(tdls->timeout <301)
                           return WFA_FAILURE;
                    }
                    else if(strcasecmp(str, "bssid") == 0)
                    {
                        str = strtok_r(NULL, ",", &pcmdStr);
                        strncpy(tdls->bssid, str, 17);
                    }
                    else if(strcasecmp(str, "switchtime") == 0)
                    {
                        str = strtok_r(NULL, ",", &pcmdStr);
                        tdls->switchtime = atoi(str);
                    }
                    else if(strcasecmp(str, "channel") == 0)
                    {
                        str = strtok_r(NULL, ",", &pcmdStr);
                        tdls->channel = atoi(str);
                    }
                    else if(strcasecmp(str, "channelOffset") == 0)
                    {
                        str = strtok_r(NULL, ",", &pcmdStr);
                        strncpy(tdls->offset, str, 4);
                    }
                    else if(strcasecmp(str, "status") == 0)
                    {
                        str = strtok_r(NULL, ",", &pcmdStr);
                        tdls->status = atoi(str);
                        if(tdls->status != 0 && tdls->status != 37)
                           return WFA_FAILURE;
                    }
                    else if(strcasecmp(str, "reason") == 0)
                    {
                        str = strtok_r(NULL, ",", &pcmdStr);
                        tdls->reason = atoi(str);
                    }

                 } /* for */
            } /* TDLS */
            else if (strcasecmp(str, "VENT") == 0)
            {
                ventFrame_t *vent = &sf->frameType.vent;

                sf->frame = FM_TYPE_VENT;
                for(;;)
                {
                    str = strtok_r(NULL, ",", &pcmdStr);
                    if(str == NULL || str[0] == '\0')
                        break;

                    if (strcasecmp(str, "type") == 0)
                    {
                        str = strtok_r(NULL, ",", &pcmdStr);
                        if (strcasecmp(str, "neigreq") == 0)
                        {
                            vent->type = VENT_TYPE_NEIGREQ;
                        }
                        if (strcasecmp(str, "transmgmt") == 0)
                        {
                            vent->type = VENT_TYPE_TRANSMGMT;
                            str = strtok_r(NULL, ",", &pcmdStr);
                            strncpy(vent->ssid, str, WFA_SSID_NAME_LEN);
                        }
                    }
                }
            }
        }
    } /* for */

    wfaEncodeTLV(WFA_STA_SENDFRAME_TLV, sizeof(dutCommand_t), (BYTE *)cmd, aBuf);

    *aLen = 4 + sizeof(dutCommand_t);

    return WFA_SUCCESS;
}


int xcCmdProcStaTestBedCmd(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    dutCommand_t *info = (dutCommand_t *) (aBuf+sizeof(wfaTLV));

    DPRINT_INFO(WFA_OUT, "This is a TestBed Station Command ONLY\n");

    wfaEncodeTLV(WFA_STA_SEND_NEIGREQ_TLV, sizeof(dutCommand_t), (BYTE *)info, aBuf);

    *aLen = 4 + sizeof(dutCommand_t);

    return WFA_SUCCESS;

}

#ifdef WFA_STA_TB
int xcCmdProcStaPresetTestParameters(char *pcmdStr, BYTE *aBuf, int *aLen)
{

    printf("\n xcCmdProcStaPresetTestParameters \n");

    caStaPresetParameters_t *presetTestParams = (caStaPresetParameters_t *) (aBuf+sizeof(wfaTLV));
    char *str;
    caStaPresetParameters_t initParams = { "0", 0, 0, 0x00, 0x0000, 0x00, 0x0000, 0x00, 0, 0x00, 0, 0xFF};

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    memcpy(presetTestParams, &initParams, sizeof(caStaPresetParameters_t));

	presetTestParams->provprot = 0;
	presetTestParams->certname[0] = '\0';
	presetTestParams->certfp[0]   = '\0';

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           strncpy(presetTestParams->intf, str, 15);
        }
        else if(strcasecmp(str, "mode") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           printf("modeis %s\n", str);

           if(strcasecmp(str, "11b") == 0 || strcasecmp(str, "b") == 0)
              presetTestParams->wirelessMode = eModeB;
           else if(strcasecmp(str, "11g") == 0 || strcasecmp(str, "g") == 0 || strcasecmp(str, "bg") ==0 )
              presetTestParams->wirelessMode = eModeBG;
           else if(strcasecmp(str, "11a") == 0 || strcasecmp(str, "a") == 0)
              presetTestParams->wirelessMode = eModeA;
           else if(strcasecmp(str, "11abg") == 0 || strcasecmp(str, "abg") == 0)
              presetTestParams->wirelessMode = eModeABG;
           else if(strcasecmp(str, "11na") == 0)
              presetTestParams->wirelessMode = eModeAN;
           else if(strcasecmp(str, "11ng") == 0)
              presetTestParams->wirelessMode = eModeGN;
           else if(strcasecmp(str, "11nl") == 0)
              presetTestParams->wirelessMode = eModeNL;   // n+abg

           presetTestParams->modeFlag = 1;
           printf("\nSetting Mode as %d\n", presetTestParams->wirelessMode);
        }
        else if(strcasecmp(str, "powersave") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           printf("powersave is %s\n", str);
           if(strcasecmp(str, "on") == 0 || strcasecmp(str, "pspoll")==0)
              presetTestParams->legacyPowerSave = 1;
           else if (strcasecmp(str, "fast") == 0)
              presetTestParams->legacyPowerSave = 2;
           else
              presetTestParams->legacyPowerSave = 0;

           presetTestParams->psFlag = 1;
           printf("\nSetting legacyPowerSave as %d\n", presetTestParams->legacyPowerSave);
        }
        else if(strcasecmp(str, "wmm") == 0)
        {
           presetTestParams->wmmFlag = 1;
           str = strtok_r(NULL, ",", &pcmdStr);
           printf("wmm is %s\n", str);

           if(strcasecmp(str, "on") == 0)
              presetTestParams->wmmState = 1;
           else if(strcasecmp(str, "off") == 0)
              presetTestParams->wmmState = 0;
        }
        else if(strcasecmp(str, "ht") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           if(strcasecmp(str, "on") == 0)
           {
              presetTestParams->ht = 1;
           }
           else
           {
              presetTestParams->ht = 0;
           }
        }
        else if(strcasecmp(str, "reset") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           if(strcasecmp(str, "11n") == 0)
           {
              presetTestParams->reset = eResetProg11n;
              printf("reset to %s\n", str);
           }
        }
        else if(strcasecmp(str, "ft_oa") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           if(strcasecmp(str, "Enable") == 0)
           {
              presetTestParams->ftoa = eEnable;
              printf("ft_oa enabled\n");
           }
           else
           {
              presetTestParams->ftoa = eDisable;
           }
        }
        else if(strcasecmp(str, "ft_ds") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           if(strcasecmp(str, "Enable") == 0)
           {
              presetTestParams->ftds = eEnable;
              printf("ft_ds enabled\n");
           }
           else
           {
              presetTestParams->ftds = eDisable;
           }
        }
        else if(strcasecmp(str, "active_scan") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           if(strcasecmp(str, "Enable") == 0)
           {
              presetTestParams->activescan = eEnable;
              printf("active scan enabled\n");
           }
           else
           {
              presetTestParams->activescan = eDisable;
           }
        }
#if 0
        else if(strcasecmp(str, "ignoreChswitchProhibit") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           if(strcasecmp(str, "Enabled") == 0)
           {
              presetTestParams->ignChSwitchProh = eEnable;
           }
           else
           {
              presetTestParams->ignChSwitchProh = eDisable;
           }
        }
#endif
        else if(strcasecmp(str, "tdls") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           if(strcasecmp(str, "Enabled") == 0)
           {
              presetTestParams->tdls = eEnable;
           }
           else
           {
              presetTestParams->tdls = eDisable;
           }
        }
        else if(strcasecmp(str, "tdlsmode") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           if(strcasecmp(str, "Default") == 0)
           {
              presetTestParams->tdlsMode = eDef;
           }
           else if(strcasecmp(str, "HiLoMac") == 0)
           {
              presetTestParams->tdlsMode = eHiLoMac;
           }
           else if(strcasecmp(str, "ExistLink") == 0)
           {
              presetTestParams->tdlsMode = eExistLink;
           }
           else if(strcasecmp(str, "APProhibit") == 0)
           {
              presetTestParams->tdlsMode = eAPProhibit;
           }
           else if(strcasecmp(str, "WeakSecurity") == 0)
           {
              presetTestParams->tdlsMode = eWeakSec;
           }
           else if(strcasecmp(str, "IgnoreChswitchProhibit") == 0)
           {
              presetTestParams->tdlsMode = eIgnChnlSWProh;
           }
        }
#if defined MTK_HS20_SIGMA // R2
		else if(strncasecmp(str, "program", 7) == 0)
		{
		   str = strtok_r(NULL, ",", &pcmdStr);
		   strncpy(presetTestParams->prog, str, WFA_HS20_PROGRAM_LEN-1);
		   presetTestParams->prog[WFA_HS20_PROGRAM_LEN-1]='\0';	   
		}
		else if(strncasecmp(str, "ppsmoID", 7) == 0)
		{
		   str = strtok_r(NULL, ",ID", &pcmdStr);
		   presetTestParams->ppsmo = atoi(str);	   
		}
		else if(strncasecmp(str, "FileType", 8) == 0)
		{
		   str = strtok_r(NULL, ",", &pcmdStr);
		   strncpy(presetTestParams->filetype, str, WFA_HS20_R2_FILETYPE_LEN-1);
		   presetTestParams->filetype[WFA_HS20_R2_FILETYPE_LEN-1]='\0';	   
		}
		else if(strncasecmp(str, "FileName", 8) == 0)
		{
		   str = strtok_r(NULL, ",", &pcmdStr);
		   strncpy(presetTestParams->filename, str, WFA_HS20_R2_FILENAME_LEN-1);
		   presetTestParams->filename[WFA_HS20_R2_FILENAME_LEN-1]='\0';  
		}
		else if(strncasecmp(str, "FilePath", 8) == 0)
		{
		   str = strtok_r(NULL, ",", &pcmdStr);
		   strncpy(presetTestParams->filepath, str, WFA_HS20_R2_FILEPATH_LEN-1);
		   presetTestParams->filepath[WFA_HS20_R2_FILEPATH_LEN-1]='\0';   
		}
        else if(strncasecmp(str, "ProvisioningProto", 17) == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           if(strncasecmp(str, "OMADM", 5) == 0)
           {
              presetTestParams->provprot = eOMADM;
           }
           else if(strncasecmp(str, "SOAP", 4) == 0)
           {
              presetTestParams->provprot = eSOAP;
           }
           else 
           {
				printf("Wrong ProvisioningProto parameter: (%s)\n", str);
				exit(1);              
           }
        }
		else if(strncasecmp(str, "QoS_Map", 7) == 0)
		{
		   str = strtok_r(NULL, ",", &pcmdStr);
		   presetTestParams->qosmap = atoi(str);	   
		}		
		
#endif
    }

#if 0 // R2

	if(strncasecmp(presetTestParams->filetype, "PPSMO", 5) == 0){ 
		char CmdStr[512];
		char buf[1024];
		FILE *pp, *qq, *rr, *ss;

#if 1
		// Download PPSMO
#if 0
		sprintf(CmdStr, "wget %s -O %s ", strcat(strcat(presetTestParams->filepath, "/"), presetTestParams->filename), presetTestParams->filename);
		if( (pp = popen(CmdStr, "r")) == NULL )
		{
			printf("popen() error!\n");
			exit(1);
		}
		while(fgets(buf, sizeof(buf), pp))
		{
			printf("%s", buf);
		}
		pclose(pp);

		sprintf(CmdStr, "adb push %s /mnt/asec/", presetTestParams->filename);
		if( (qq = popen(CmdStr, "r")) == NULL )
		{
			printf("popen2() error!\n");
			exit(1);
		}
		while(fgets(buf, sizeof(buf), qq))
		{
			printf("%s", buf);
		}
		pclose(qq);
#endif

		// Parsing PPSMO to find whether if ther is root_ca
		{
			xmlDoc *document;
			xmlNode *root, *node1, *child1, *node2, *child2, *node3, *child3, *node4, *child4, *node5, *child5, *node6, *child6;
			xmlChar *key1, *key2, *key3, *key4, *key5;
			int fgCred01, fgCred02, fgGetCertURL, fgGetCertFP;
			char *certURL, *certFP, *certName; 
			
			xmlKeepBlanksDefault(0);
			document = xmlReadFile(presetTestParams->filename, NULL, 0);
			root = xmlDocGetRootElement(document);
			fgCred01 = 0;
			fgCred02 = 0;
			fgGetCertURL = 0;
			fgGetCertFP  = 0;
			
			//printf("\n Root is ::%s:: <%i> \n",root->name,root->type);
			child1 = root->children;
		
			for(node1 = child1;node1;node1 = node1->next){
				if ((!xmlStrcmp(node1->name, (const xmlChar *)"Node")) ){
					child2 = node1->children;
					for(node2 = child2;node2;node2 = node2->next){
						if ((!xmlStrcmp(node2->name, (const xmlChar *)"Node")) ){
							child3 = node2->children;
							for(node3 = child3;node3;node3 = node3->next){

								//printf("\n node3 is ::%s:: <%i>\n",node3->name, node3->type);
								if ((!xmlStrcmp(node3->name, (const xmlChar *)"NodeName"))){
									key1 = xmlNodeListGetString(document, node3->xmlChildrenNode, 1);

									if ((!xmlStrcmp(key1, (const xmlChar *)"Cred01"))){
										//printf("\n key1 is ::%s::\n",key1);
										fgCred01 = 1;
									}
									else if((!xmlStrcmp(key1, (const xmlChar *)"Cred02"))){
										//printf("\n key1 is ::%s::\n",key1);
										fgCred02 = 1;
									}
									else {
										break;
									}
								}


								if ((!xmlStrcmp(node3->name, (const xmlChar *)"Node")) ){
									child4 = node3->children;
									for(node4 = child4;node4;node4 = node4->next){

										if ((!xmlStrcmp(node4->name, (const xmlChar *)"NodeName"))){
											key2 = xmlNodeListGetString(document, node4->xmlChildrenNode, 1);
											if (xmlStrcmp(key2, (const xmlChar *)"AAAServerTrustRoot")){
												break;
											}
										}

										
										if ((!xmlStrcmp(node4->name, (const xmlChar *)"Node")) ){
											child5 = node4->children;
											for(node5 = child5;node5;node5 = node5->next){
												if ((!xmlStrcmp(node5->name, (const xmlChar *)"NodeName"))){
													key3 = xmlNodeListGetString(document, node5->xmlChildrenNode, 1);
													printf("\n Cred [%s]\n",key3);
												}

												if ((!xmlStrcmp(node5->name, (const xmlChar *)"Node")) ){
													child6 = node5->children;
													for(node6 = child6;node6;node6 = node6->next){
														if ((!xmlStrcmp(node6->name, (const xmlChar *)"NodeName"))){
															key4 = xmlNodeListGetString(document, node6->xmlChildrenNode, 1);
															if((!xmlStrcmp(key4, (const xmlChar *)"CertURL"))){
																fgGetCertURL = 1;
															}
															if((!xmlStrcmp(key4, (const xmlChar *)"CertSHA256Fingerprint"))){
																fgGetCertFP = 1;
															}

														}
												
														if ((!xmlStrcmp(node6->name, (const xmlChar *)"Value"))){
															key5 = xmlNodeListGetString(document, node6->xmlChildrenNode, 1);
															if(fgGetCertURL){
																certURL = (char *)key5;
																printf("\n CertURL [%s]\n",certURL);
																certName = strrchr(certURL,'/');
																certName = certName + 1;
																printf("\n Cert Filename [%s]\n",certName);
																strncpy(presetTestParams->certname, certName, WFA_HS20_R2_FILENAME_LEN-1);
																fgGetCertURL = 0;
															}
															if(fgGetCertFP){
																certFP = (char *)key5;
																printf("\n CertSHA256Fingerprint [%s]\n",certFP);
																strncpy(presetTestParams->certfp, certFP, 63);
																fgGetCertFP = 0;
															}

														}
												
													}
												}

											}
										}

									}
								}

		
							}
						
						}

					}

				}

			}
		
			printf("\n END PARSING\n");

#if 1

			if(presetTestParams->certname[0] != '\0'){

				sprintf(CmdStr, "wget %s -O %s ", certURL, presetTestParams->certname);
				if( (rr = popen(CmdStr, "r")) == NULL )
				{
					printf("popen3() error!\n");
					exit(1);
				}
				while(fgets(buf, sizeof(buf), rr))
				{
					printf("%s", buf);
				}
				pclose(rr);
		
				sprintf(CmdStr, "adb push %s /data/misc/wpa_supplicant", presetTestParams->certname);
				if( (ss = popen(CmdStr, "r")) == NULL )
				{
					printf("popen4() error!\n");
					exit(1);
				}
				while(fgets(buf, sizeof(buf), ss))
				{
					printf("%s", buf);
				}
				pclose(ss);


			}
#endif

			

		}
		
	
#else
		sprintf(CmdStr, "D::\\Sigma\\bin\\wget.exe %s -O %s ", strcat(strcat(presetTestParams->filepath, "/"), presetTestParams->filename), presetTestParams->filename);
		system(CmdStr);
		sprintf(CmdStr, "D::\\Sigma\\bin\\adb.exe push %s /mnt/asec/", presetTestParams->filename);
		system(CmdStr);
#endif
		
	}
#endif


    wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_TLV, sizeof(caStaPresetParameters_t), (BYTE *)presetTestParams, aBuf);

    *aLen = 4 + sizeof(caStaPresetParameters_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaResetDefault(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    caStaResetDefault_t *reset = (caStaResetDefault_t *) (aBuf+sizeof(wfaTLV));
    char *str;

    if(aBuf == NULL)
       return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
           break;

        if(strcasecmp(str, "interface") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           strncpy(reset->intf, str, 15);
        }
        else if(strcasecmp(str, "prog") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           strncpy(reset->prog, str, 64);
        }
    }

    wfaEncodeTLV(WFA_STA_RESET_DEFAULT_TLV, sizeof(caStaResetDefault_t), (BYTE *)reset, aBuf);
    *aLen = 4+sizeof(caStaResetDefault_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaSetRadio(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    char *str;
    dutCommand_t *cmd = (dutCommand_t *) (aBuf+sizeof(wfaTLV));
    caStaSetRadio_t *sr = &cmd->cmdsu.sr;

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(cmd->intf, str, 15);
            DPRINT_INFO(WFA_OUT, "interface %s\n", cmd->intf);
        }
        else if (strcasecmp(str, "mode") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            if (strcasecmp(str, "off") == 0)
            {
                sr->mode = WFA_OFF;
            }
            else
            {
                sr->mode = WFA_ON;
            }
        }
    }

    wfaEncodeTLV(WFA_STA_SET_RADIO_TLV, sizeof(dutCommand_t), (BYTE *)cmd, aBuf);
    *aLen = 4+sizeof(dutCommand_t);
    return WFA_SUCCESS;
}

int xcCmdProcStaSetWireless(char *pcmdStr, BYTE *aBuf, int *aLen)
{

    dutCommand_t *dutcmd = (dutCommand_t *) (aBuf+sizeof(wfaTLV));
    caStaSetWireless_t *staWirelessParams = (caStaSetWireless_t *) &dutcmd->cmdsu.setWireless;
    char *str;

    DPRINT_INFO(WFA_OUT,"xcCmdProcStaSetWireless Starts...");

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
                break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(staWirelessParams->intf, str, 15);
        }
        else if(strcasecmp(str, "band") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(staWirelessParams->band,str,7);
            DPRINT_INFO(WFA_OUT, "\n Band -%s- \n", staWirelessParams->band);
        }
        else if(strcasecmp(str, "rts_force") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            staWirelessParams->rts_force=wfaStandardBoolParsing(str);
            if (staWirelessParams->rts_force<0)
            {
                DPRINT_INFO(WFA_OUT, "Invalid rts_force Value %s\n",str);
                return WFA_FAILURE;
            }
            DPRINT_INFO(WFA_OUT, "\n rts_force -%i- \n", staWirelessParams->rts_force);
        }
         else if(strcasecmp(str, "dyn_bw_sgnl") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            staWirelessParams->dyn_bw_sgnl=wfaStandardBoolParsing(str);
            if (staWirelessParams->dyn_bw_sgnl<0)
            {
                DPRINT_INFO(WFA_OUT, "Invalid dyn_bw_sgnl Value %s\n",str);
                return WFA_FAILURE;
            }
            DPRINT_INFO(WFA_OUT, "\n dyn_bw_sgnl -%i- \n", staWirelessParams->dyn_bw_sgnl);
        }
        else if(strcasecmp(str, "bw_sgnl") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            staWirelessParams->bw_sgnl=wfaStandardBoolParsing(str);
            if (staWirelessParams->bw_sgnl<0)
            {
                DPRINT_INFO(WFA_OUT, "Invalid bw_sgnl Value %s\n",str);
                return WFA_FAILURE;
            }
            DPRINT_INFO(WFA_OUT, "\n bw_sgnl -%i- \n", staWirelessParams->bw_sgnl);
        }
        else if(strcasecmp(str, "noack") == 0)
        {
            char *ackpol;
            int ackpolcnt = 0;
            char *setvalues =strtok_r(NULL, ",", &pcmdStr);

            if(setvalues != NULL)
            {
                while((ackpol = strtok_r(NULL, ":", &setvalues)) != NULL && ackpolcnt < 4)
                {
                    if(strcasecmp(str, "enable") == 0)
                       staWirelessParams->noAck[ackpolcnt] = 1;
                    else if(strcasecmp(str, "disable") == 0)
                       staWirelessParams->noAck[ackpolcnt] = 0;

                    ackpolcnt++;
                }
           }
        }
    }

    wfaEncodeTLV(WFA_STA_SET_WIRELESS_TLV, sizeof(dutCommand_t), (BYTE *)dutcmd, aBuf);
    *aLen = 4+sizeof(dutCommand_t);
    return WFA_SUCCESS;
}

int xcCmdProcStaSendADDBA(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    caStaSetSendADDBA_t *staSendADDBA = (caStaSetSendADDBA_t *) (aBuf+sizeof(wfaTLV));
    char *str;

    DPRINT_INFO(WFA_OUT,"xcCmdProcStaSendADDBA Starts...");

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(staSendADDBA->intf, str, 15);
        }
        else if(strcasecmp(str, "tid") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            staSendADDBA->tid = atoi(str);
            DPRINT_INFO(WFA_OUT, "\n TID -%i- \n", staSendADDBA->tid);
        }
    }

    wfaEncodeTLV(WFA_STA_SEND_ADDBA_TLV, sizeof(caStaSetSendADDBA_t), (BYTE *)staSendADDBA, aBuf);
    *aLen = 4+sizeof(caStaSetSendADDBA_t);

    return WFA_SUCCESS;
}

int xcCmdProcStaSetRIFS(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    caStaSetRIFS_t *staSetRIFS = (caStaSetRIFS_t *)(aBuf+sizeof(wfaTLV));
    char *str;

    DPRINT_INFO(WFA_OUT, "xcCmdProcSetRIFS starts ...\n");

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(staSetRIFS->intf, str, 15);
        }
        else if(strcasecmp(str, "action") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            staSetRIFS->action = wfaStandardBoolParsing(str);
            DPRINT_INFO(WFA_OUT, "\n TID -%i- \n", staSetRIFS->action);
        }
    }

    wfaEncodeTLV(WFA_STA_SET_RIFS_TEST_TLV, sizeof(caStaSetRIFS_t), (BYTE *)staSetRIFS, aBuf);
    *aLen = 4+sizeof(caStaSetRIFS_t);

    return WFA_SUCCESS;

}


int xcCmdProcStaSendCoExistMGMT(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    caStaSendCoExistMGMT_t *staSendMGMT = (caStaSendCoExistMGMT_t *)(aBuf+sizeof(wfaTLV));
    char *str;

    DPRINT_INFO(WFA_OUT, "xcCmdProcSendCoExistMGMT starts ...\n");

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "interface") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(staSendMGMT->intf, str, 15);
        }
        else if(strcasecmp(str, "type") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(staSendMGMT->type, str, 15);
        }
        else if(strcasecmp(str, "value") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(staSendMGMT->value, str, 15);
        }
    }

    wfaEncodeTLV(WFA_STA_SEND_COEXIST_MGMT_TLV, sizeof(caStaSendCoExistMGMT_t), (BYTE *)staSendMGMT, aBuf);
    *aLen = 4+sizeof(caStaSendCoExistMGMT_t);

    return WFA_SUCCESS;
}

caSta11n_t init11nParams = {"wifi0", 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,0xFFFF, 0xFFFF, "", "", 0xFF, 0xFF, 0xFF, 0xFF};

int xcCmdProcStaSet11n(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    caSta11n_t *v11nParams = (caSta11n_t *) (aBuf+sizeof(wfaTLV));
    char *str;

    DPRINT_INFO(WFA_OUT,"xcCmdProcStaSet11n Starts...");

    if(aBuf == NULL)
        return WFA_FAILURE;

    memset(aBuf, 0, *aLen);
    memcpy(v11nParams, &init11nParams, sizeof(caSta11n_t));

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
            break;

        if(strcasecmp(str, "ampdu") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            v11nParams->ampdu=wfaStandardBoolParsing(str);
            if (v11nParams->ampdu<0)
            {
                DPRINT_INFO(WFA_OUT, "Invalid AMPDU Value %s\n",str);
                return WFA_FAILURE;
            }
            DPRINT_INFO(WFA_OUT, "\n AMPDU -%i- \n", v11nParams->ampdu);
        }
        else if(strcasecmp(str, "40_intolerant") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            v11nParams->_40_intolerant=wfaStandardBoolParsing(str);
            if (v11nParams->_40_intolerant<0)
            {
                DPRINT_INFO(WFA_OUT, "Invalid _40_intolerant Value %s\n",str);
                return WFA_FAILURE;
            }
            DPRINT_INFO(WFA_OUT, "\n _40_intolerant -%i- \n", v11nParams->_40_intolerant);
        }
        else if(strcasecmp(str, "sgi20") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            v11nParams->sgi20=wfaStandardBoolParsing(str);
            if (v11nParams->sgi20<0)
            {
                DPRINT_INFO(WFA_OUT, "Invalid sgi20 Value %s\n",str);
                return WFA_FAILURE;
            }
            DPRINT_INFO(WFA_OUT, "\n sgi20 -%i- \n", v11nParams->sgi20);
        }
        else if(strcasecmp(str, "amsdu") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            v11nParams->amsdu=wfaStandardBoolParsing(str);
            if (v11nParams->amsdu<0)
            {
                DPRINT_INFO(WFA_OUT, "Invalid amsdu Value %s\n",str);
                return WFA_FAILURE;
            }
            DPRINT_INFO(WFA_OUT, "\n amsdu -%i- \n", v11nParams->amsdu);
        }
        else if(strcasecmp(str, "addba_reject") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            v11nParams->addba_reject=wfaStandardBoolParsing(str);
            if (v11nParams->addba_reject<0)
            {
                DPRINT_INFO(WFA_OUT, "Invalid addba_reject Value %s\n",str);
                return WFA_FAILURE;
            }
            DPRINT_INFO(WFA_OUT, "\n addba_reject -%i- \n", v11nParams->addba_reject);
        }
        else if(strcasecmp(str, "greenfield") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            v11nParams->greenfield=wfaStandardBoolParsing(str);
            if (v11nParams->greenfield<0)
            {
                DPRINT_INFO(WFA_OUT, "Invalid greenfield Value %s\n",str);
                return WFA_FAILURE;
            }
            DPRINT_INFO(WFA_OUT, "\n greenfield -%i- \n", v11nParams->greenfield);
        }
        else if(strcasecmp(str, "mcs32") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            v11nParams->mcs32=wfaStandardBoolParsing(str);
            if (v11nParams->mcs32<0)
            {
                DPRINT_INFO(WFA_OUT, "Invalid mcs32 Value %s\n",str);
                return WFA_FAILURE;
            }
            DPRINT_INFO(WFA_OUT, "\n mcs32 -%i- \n", v11nParams->mcs32);
        }
        else if(strcasecmp(str, "rifs_test") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            v11nParams->rifs_test=wfaStandardBoolParsing(str);
            if (v11nParams->rifs_test<0)
            {
                DPRINT_INFO(WFA_OUT, "Invalid rifs_test Value %s\n",str);
                return WFA_FAILURE;
            }
            DPRINT_INFO(WFA_OUT, "\n rifs_test -%i- \n", v11nParams->rifs_test);
        }
        else if(strcasecmp(str, "width") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(v11nParams->width,str,7);
            DPRINT_INFO(WFA_OUT, "\n width -%s- \n", v11nParams->width);
        }
        else if(strcasecmp(str, "mcs_fixedrate") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            strncpy(v11nParams->mcs_fixedrate,str,4);
            DPRINT_INFO(WFA_OUT, "\n mcs fixedrate -%s- \n", v11nParams->mcs_fixedrate);
        }
        else if(strcasecmp(str, "stbc_rx") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            v11nParams->stbc_rx = atoi(str);
            DPRINT_INFO(WFA_OUT, "\n stbc rx -%d- \n", v11nParams->stbc_rx);
        }
        else if(strcasecmp(str, "smps") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            v11nParams->smps = atoi(str);
            DPRINT_INFO(WFA_OUT, "\n smps  -%d- \n", v11nParams->smps);
        }
        else if(strcasecmp(str, "txsp_stream") == 0 )
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            v11nParams->txsp_stream = atoi(str);
            DPRINT_INFO(WFA_OUT, "\n txsp_stream -%d- \n", v11nParams->txsp_stream);
        }
        else if(strcasecmp(str, "rxsp_stream") == 0)
        {
            str = strtok_r(NULL, ",", &pcmdStr);
            v11nParams->rxsp_stream = atoi(str);
            DPRINT_INFO(WFA_OUT, "\n rxsp_stream -%d- \n", v11nParams->rxsp_stream);
        }
    }

    wfaEncodeTLV(WFA_STA_SET_11N_TLV, sizeof(caSta11n_t), (BYTE *)v11nParams, aBuf);
    *aLen = 4+sizeof(caSta11n_t);
    return WFA_SUCCESS;
}

#endif


int xcCmdProcStaSetRFeature(char *pcmdStr, BYTE *aBuf, int *aLen)
{
    dutCommand_t *dutcmd = (dutCommand_t *) (aBuf+sizeof(wfaTLV));
    caStaRFeat_t *rfeat = (caStaRFeat_t *) &dutcmd->cmdsu.rfeat;
    char *str;

    printf("\n xcCmdProcStaSetRFeature \n");

    if(aBuf == NULL)
       return WFA_FAILURE;

    memset(aBuf, 0, *aLen);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
        if(str == NULL || str[0] == '\0')
           break;

        if(strcasecmp(str, "interface") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           strncpy(dutcmd->intf, str, 15);
        }
        else if(strcasecmp(str, "prog") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           strncpy(rfeat->prog, str, 8);
        }
        else if(strcasecmp(str, "uapsd") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           if(strcasecmp(str, "enable") == 0)
              rfeat->uapsd = eEnable;
           else
              rfeat->uapsd = eDisable;
        }
        else if(strcasecmp(str, "peer") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           strncpy(rfeat->peer, str, 17);
        }
        else if(strcasecmp(str, "tpktimer") == 0)
        {
           str = strtok_r(NULL, ",", &pcmdStr);
           if(strcasecmp(str, "enable") == 0)
              rfeat->tpktimer= eEnable;
           else
              rfeat->tpktimer = eDisable;
        }
#if 0 //defined MTK_HS20_SIGMA // R2
		else if(strcasecmp(str, "PolicyUpdate") == 0)
		{
		   str = strtok_r(NULL, ",", &pcmdStr);
		   rfeat->policyupdate= atoi(str);
		}
		else if(strcasecmp(str, "UserName") == 0)
		{
		   str = strtok_r(NULL, ",", &pcmdStr);
		   strncpy(rfeat->username, str, 128);
		}
		else if(strcasecmp(str, "Password") == 0)
		{
		   str = strtok_r(NULL, ",", &pcmdStr);
		   strncpy(rfeat->password, str, 128);
		}
#endif
        else if (strcasecmp(str, "ChSwitchMode") == 0)
        {
            
            str = strtok_r(NULL, ",", &pcmdStr);
            if(strcasecmp(str, "Initiate") == 0)
                rfeat->chSwitch = eEnable;
            else
                rfeat->chSwitch = eDisable;

            printf("ChSwitchMode %d \n", rfeat->chSwitch );
        }
        else if (strcasecmp(str, "OffChNum") == 0)
        {
            
        
            str = strtok_r(NULL, ",", &pcmdStr);
            rfeat->offChNum = atoi(str);
            printf("OffChNum %d \n",rfeat->offChNum );
        }
        else if (strcasecmp(str, "SecChOffset") == 0)
        {

        
            str = strtok_r(NULL, ",", &pcmdStr);
            if (strcasecmp(str, "20") == 0)
                rfeat->secChOffset = 0;
            else if (strcasecmp(str, "40above") == 0)
                    rfeat->secChOffset = 1;
            else if (strcasecmp(str, "40below") == 0)
                    rfeat->secChOffset = 3;

            printf("SecChOffset %d \n", rfeat->secChOffset); 
        }

    }

    wfaEncodeTLV(WFA_STA_SET_RFEATURE_TLV, sizeof(dutCommand_t), (BYTE *)dutcmd, aBuf);
    *aLen = 4+sizeof(dutCommand_t);

    return WFA_SUCCESS;
}
