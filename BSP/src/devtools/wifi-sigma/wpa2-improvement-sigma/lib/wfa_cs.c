 
/****************************************************************************
 *  (c) Copyright 2007 Wi-Fi Alliance.  All Rights Reserved
 *
 *
 *  LICENSE
 *
 *  License is granted only to Wi-Fi Alliance members and designated
 *  contractors ($B!H(BAuthorized Licensees$B!I(B)..AN  Authorized Licensees are granted
 *  the non-exclusive, worldwide, limited right to use, copy, import, export
 *  and distribute this software:
 *  (i) solely for noncommercial applications and solely for testing Wi-Fi
 *  equipment; and
 *  (ii) solely for the purpose of embedding the software into Authorized
 *  Licensee$B!G(Bs proprietary equipment and software products for distribution to
 *  its customers under a license with at least the same restrictions as
 *  contained in this License, including, without limitation, the disclaimer of
 *  warranty and limitation of liability, below..AN  The distribution rights
 *  granted in clause
 *  (ii), above, include distribution to third party companies who will
 *  redistribute the Authorized Licensee$B!G(Bs product to their customers with or
 *  without such third party$B!G(Bs private label. Other than expressly granted
 *  herein, this License is not transferable or sublicensable, and it does not
 *  extend to and may not be used with non-Wi-Fi applications..AN  Wi-Fi Alliance
 *  reserves all rights not expressly granted herein..AN 
 *.AN 
 *  Except as specifically set forth above, commercial derivative works of
 *  this software or applications that use the Wi-Fi scripts generated by this
 *  software are NOT AUTHORIZED without specific prior written permission from
 *  Wi-Fi Alliance.
 *.AN 
 *  Non-Commercial derivative works of this software for internal use are
 *  authorized and are limited by the same restrictions; provided, however,
 *  that the Authorized Licensee shall provide Wi-Fi Alliance with a copy of
 *  such derivative works under a perpetual, payment-free license to use,
 *  modify, and distribute such derivative works for purposes of testing Wi-Fi
 *  equipment.
 *.AN 
 *  Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 *  or promote products that are derived from or that use this software without
 *  specific prior written permission from Wi-Fi Alliance.
 *
 *  THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A.AN PARTICULAR PURPOSE,
 *  ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
 *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ******************************************************************************
 */

/* 
 *   File: wfa_cs.c -- configuration and setup
 *   This file contains all implementation for the dut setup and control 
 *   functions, such as network interfaces, ip address and wireless specific
 *   setup with its supplicant.
 *
 *   The current implementation is to show how these functions
 *   should be defined in order to support the Agent Control/Test Manager 
 *   control commands. To simplify the current work and avoid any GPL licenses,
 *   the functions mostly invoke shell commands by calling linux system call,
 *   system("<commands>"). 
 *
 *   It depends on the differnt device and platform, vendors can choice their
 *   own ways to interact its systems, supplicants and process these commands
 *   such as using the native APIs.
 *
 *   Revision History:
 *        2006/03/10  -- initially created by qhu
 *        2006/06/01  -- BETA Release by qhu
 *        2006/06/13  -- 00.02 Release by qhu
 *        2006/06/30  -- 00.10 Release by qhu
 *        2006/07/10  -- 01.00 Release by qhu
 *        2006/09/01  -- 01.05 Release by qhu
 *        2006/10/26  -- 01.06 Released by qhu
 *                       replace hardcoded buf size with macro
 *        2006/12/02  -- bugs: 1. fixes incorrect order of getipconfig.sh
 *                                input parameters reported by p.schwann
 *                             2. will add a new network for wap_cli command
 *                                in case the network id 0 not present,
 *                                recommended by c.benson
 *                                the solution is to reimplement with calling
 *                                native C API
 *        2007/01/11  -- 01.10 released by qhu
 *        2007/02/15  -- WMM Extension Beta released by qhu, mkaroshi
 *        2007/03/18  -- add file close statements
 *        2007/03/21  -- rename the file to avoid the confusion.
 *        2007/03/30  -- 01.40 WPA2 and Official WMM Beta Release by qhu
 *        2007/04/20  -- 02.00 WPA2 and Official WMM Release by qhu
 *        2007/08/15 --  02.10 WMM-Power Save release by qhu
 *        2007/10/10 --  02.20 Voice SOHO beta -- qhu
 *        2007/11/07 --  02.30 Voice HSO -- qhu
 *        2007/12/10 --  02.32 Add a function to upload test results.
 *        2008/01/03 --  02.34 Support the result upload command.
 *        2008/03/12 --  02.41 Bug #16, incorrect file descriptor used. Change 
 *                       the "tmpfile" to "tmpfd" and a few places. Make a macro
 *                       WFA_STAUT_IF in file "inc/wfa_cs.h" for WLAN interface
 *                       name in the function "wfaDeviceListIF()
 *                      
 *                       Not A Bug. Put back to the function from 
 *                       wfaSetEncryption1() to wfaSetEncryption() for 
 *                       supporting WEP. Porting could select which should be 
 *                       used according to WEP support or not.
 *                        
 *        
 */ 
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdarg.h>


#if __CYGWIN__ // MTK_P2P_SIGMA, MTK_HS20_SIGMA
#include <cygwin/types.h>
#include <cygwin/socket.h>
#include <cygwin/if.h>
#include <sys/select.h>
#include <poll.h>
#else
#include <linux/types.h>
#include <linux/socket.h>
#include <poll.h>
#endif /* __CYGWIN__ MTK_P2P_SIGMA, MTK_HS20_SIGMA */

#include "wfa_portall.h"
#include "wfa_debug.h"
#include "wfa_ver.h"
#include "wfa_main.h"
#include "wfa_types.h"
#include "wfa_ca.h"
#include "wfa_tlv.h"
#include "wfa_sock.h"
#include "wfa_tg.h"
#include "wfa_cmds.h"
#include "wfa_rsp.h"
#include "wfa_utils.h"
#ifdef WFA_WMM_PS_EXT
#include "wfa_wmmps.h"
#endif

#define MTK_HS20_CMD(supp_cmd_fmt, ... ) \
	sprintf(gCmdStr, "wpa_cli " supp_cmd_fmt, ##__VA_ARGS__); \
	puts("\n\t"); \
	puts(gCmdStr); \
	if (system(gCmdStr)) printf("\t\tSYSYTEM MTK_HS20_CMD FAIL: \n\t\t\t%s \n", gCmdStr);

#define MTK_WPA3_CMD MTK_HS20_CMD
#ifdef ANDROID_AOSP
char ctrl_if[] = "-p" CTRL_IFACE_PATH;
#else
char ctrl_if[1] = {0};
#endif
#ifdef MTK_11N_SIGMA_LAST
#define WPA_SUPPLICANT_SOCKET_PATH "/tmp/wpa_supplicant"
#define EAP_CERT_PATH "/data/misc/wifi"
#else
#define WPA_SUPPLICANT_SOCKET_PATH "/tmp/wpa_supplicant"
#endif

#ifdef MTK_SPECIFIC_PING_SIGMA
#define SIGMA_PING "/data/ping_sigma"
#else
#define SIGMA_PING "ping"
#endif

#ifdef MTK_11N_SIGMA 
char gWpaCmdStr[WFA_CMD_STR_SZ];




void mtk_printf(const char *fmt, ...);
#define MTK_WPA_CMD(supp_cmd_fmt, ... )	\
	sprintf(gWpaCmdStr, "wpa_cli " supp_cmd_fmt, ##__VA_ARGS__); \
	puts("\n\t"); \
	puts(gWpaCmdStr); \
	if (system(gWpaCmdStr)) printf("\t\tSYSYTEM CMD FAIL: \n\t\t\t%s \n", gWpaCmdStr);

#define MTK_CREATE_WPA_CMD(supp_cmd_fmt, ... ) \
	memset(gWpaCmdStr, 0, WFA_CMD_STR_SZ); \
	sprintf(gWpaCmdStr, "wpa_cli " supp_cmd_fmt, ##__VA_ARGS__); \
	mtk_printf("%s\n", gWpaCmdStr);

#define BIN_PATH ""
/*
* printf time stamp like android log
*/
void build_timestamp(char *time_buf, int buf_len)
{
	char timebuf[32];
	struct timeval timeval;
	struct tm *tm;

	memset(timebuf, 0, 32);
	memset(time_buf, 0, 128);

	gettimeofday(&timeval, NULL);

	tm = localtime(&timeval.tv_sec);
	strftime(timebuf, sizeof(timebuf), "%m-%d %H:%M:%S", tm);
	snprintf(time_buf, 128, "%s.%03ld", timebuf, timeval.tv_usec / 1000);
}


void mtk_printf(const char *fmt, ...)
{
	char msg[4096];
	char time_str[128];
	va_list params;
	va_start(params, fmt);
	vsnprintf(msg, sizeof(msg), fmt, params);
	build_timestamp(time_str, sizeof(time_str));
	printf("%s %s", time_str, msg);
	va_end(params);
}
void mtk_fprintf(FILE *fp, const char *fmt, ...)
{
	char msg[4096];
	char time_str[128];
	va_list params;
	va_start(params, fmt);
	vsnprintf(msg, sizeof(msg), fmt, params);
	build_timestamp(time_str, sizeof(time_str));
	fprintf(fp, "%s %s", time_str, msg);
	va_end(params);
}
/*
* use popen() to do shell cmd
* with fread() get the desired msg
*/
int mtk_run_shell_cmd(char *cmd, char *reply,
			size_t buflen,
			size_t *reply_len,
			void *ret,
			void (*cb)(char *msg, size_t len, void *ret))
{
	FILE *pp;
	if (gDebugSigma)
		mtk_printf("%s running cmd: %s\n", __func__, cmd);
	pp = popen(cmd, "r"); /* read is enough */
	if (!pp) {
		mtk_printf("%s cmd: %s failed\n", __func__, cmd);
		return -1;
	}
	if (reply && reply_len) {
		memset(reply, 0, buflen);
		*reply_len = fread(reply, sizeof(char), buflen, pp);
		if (gDebugSigma)
			mtk_printf("popen reply: %s\n", reply);
	}
	if (cb)
		cb(reply, *reply_len, ret);

	pclose(pp); 
	return 0;
}

/*
*ADD_NETWORK
* interface:
* which interface used; p2p0 or wlan0
* return:
* network id
*/
int mtk_add_network(char *interface)
{
	char buf[8];
	size_t reply_len;

	MTK_CREATE_WPA_CMD("-i %s -p %s add_network",
			interface,
			WPA_SUPPLICANT_SOCKET_PATH);
	mtk_run_shell_cmd(gWpaCmdStr, buf, 8, &reply_len, NULL, NULL);
	return atoi(buf);
}


/*
* SET
* interface: wlan0 or p2p0
* field: sepecific feild
* value: value
*/
int mtk_set_global(char *interface, char *field, char *value)
{
	char buf[128];
	size_t len = 0;

	MTK_CREATE_WPA_CMD("-i %s -p %s set %s %s",
			interface,
			WPA_SUPPLICANT_SOCKET_PATH,
			field, value);
	return mtk_run_shell_cmd(gWpaCmdStr, buf, 128, &len, NULL, NULL);
}
/*
* SET_NETWORK
* interface: wlan0 or p2p0
* network_id: id from add_network
* field: sepecific feild
* value: value
*/
int mtk_set_network(char *interface, int network_id, char *field, char *value)
{
	char buf[128];
	size_t len = 0;

	MTK_CREATE_WPA_CMD("-i %s -p %s set_network %d %s %s",
			interface,
			WPA_SUPPLICANT_SOCKET_PATH,
			network_id, field, value);
	return mtk_run_shell_cmd(gWpaCmdStr, buf, 128, &len, NULL, NULL);
}

int mtk_enable_network(char *interface, int network_id)
{
	char buf[128];
	size_t len = 0;
	MTK_CREATE_WPA_CMD("-i %s -p %s enable_network %d",
			interface,
			WPA_SUPPLICANT_SOCKET_PATH, network_id);
	return mtk_run_shell_cmd(gWpaCmdStr, buf, 128, &len, NULL, NULL);
}

int mtk_disable_network(char *interface, int network_id)
{
	char buf[128];
	size_t len = 0;
	MTK_CREATE_WPA_CMD("-i %s -p %s disable_network %d",
			interface,
			WPA_SUPPLICANT_SOCKET_PATH, network_id);
	return mtk_run_shell_cmd(gWpaCmdStr, buf, 128, &len, NULL, NULL);
}
int mtk_disconnect(char *interface)
{
	char buf[128];
	size_t len = 0;
	MTK_CREATE_WPA_CMD("-i %s -p %s disconnect",
			interface,
			WPA_SUPPLICANT_SOCKET_PATH);
	return mtk_run_shell_cmd(gWpaCmdStr, buf, 128, &len, NULL, NULL);
}
int mtk_reconnect(char *interface)
{
	char buf[128];
	size_t len = 0;
	MTK_CREATE_WPA_CMD("-i %s -p %s reconnect",
			interface,
			WPA_SUPPLICANT_SOCKET_PATH);
	return mtk_run_shell_cmd(gWpaCmdStr, buf, 128, &len, NULL, NULL);
}
enum {
	REMOVE_ALL,
	REMOVE_SPECIFIC,
	REMOVE_MAX
};

int mtk_remove_network(char *interface, unsigned char remove_type, int network_id)
{
	char buf[128];
	size_t len = 0;
	switch (remove_type) {
	case REMOVE_ALL:
		MTK_CREATE_WPA_CMD("-i %s -p %s remove_network all",
				interface,
				WPA_SUPPLICANT_SOCKET_PATH);
		return mtk_run_shell_cmd(gWpaCmdStr, buf, 128, &len, NULL, NULL);
	case REMOVE_SPECIFIC:
		MTK_CREATE_WPA_CMD("-i %s -p %s remove_network %d",
				interface,
				WPA_SUPPLICANT_SOCKET_PATH,
				network_id);
		return mtk_run_shell_cmd(gWpaCmdStr, buf, 128, &len, NULL, NULL);
	default:
		mtk_printf("unknow remove type\n");
		return -2;
	}
}

int mtk_select_network(char *interface, int network_id)
{
	char buf[128];
	size_t len = 0;
	MTK_CREATE_WPA_CMD("-i %s -p %s select_network %d",
			interface,
			WPA_SUPPLICANT_SOCKET_PATH, network_id);
	return mtk_run_shell_cmd(gWpaCmdStr, buf, 128, &len, NULL, NULL);
}

int mtk_set_wep_key(char *interface, int network_id,
						char *key_type,
						int key_index, char *key)
{
	char buf[128];
	size_t len = 0;
	if (key_type &&
		!strcmp(key_type, "wep_tx_keyidx")) {
		MTK_CREATE_WPA_CMD("-i %s -p %s set_network %d wep_tx_keyidx %d",
				interface,
				WPA_SUPPLICANT_SOCKET_PATH, network_id,
				key_index);
		return mtk_run_shell_cmd(gWpaCmdStr, buf, 128, &len, NULL, NULL);
	} else {
		MTK_CREATE_WPA_CMD("-i %s -p %s set_network %d wep_key%i %s",
				interface,
				WPA_SUPPLICANT_SOCKET_PATH, network_id,
				key_index, key);
		return mtk_run_shell_cmd(gWpaCmdStr, buf, 128, &len, NULL, NULL);
	}
}
enum ipconfig_type {
	IPCONFIG_DHCP,
	IPCONFIG_MANUAL,
	IPCONFIG_MAX
};
int mtk_config_ip(char *interface, unsigned char config_type,
				char *ipaddr, char *mask, char *gw)
{
	char ipcmd[128];
	int ret = 0;
	if (!interface) {
		mtk_printf("%s unknown interface\n", __func__);
		return -1;
	}
	switch (config_type) {
	case IPCONFIG_DHCP:
		mtk_printf("%s ipconfig with dhcp\n", __func__);
		memset(ipcmd, 0, 128);
		snprintf(ipcmd, 128, "netcfg %s dhcp", interface);
		return mtk_run_shell_cmd(ipcmd, NULL, 0, NULL, NULL, NULL);

	case IPCONFIG_MANUAL:
		mtk_printf("%s ipconfig with manual\n", __func__);
		if (!ipaddr || !mask) {
			mtk_printf("%s unknown ipaddr & mask\n", __func__);
			return -2;
		}
		memset(ipcmd, 0, 128);

		snprintf(ipcmd, 128, "ifconfig %s %s netmask %s",
			interface, ipaddr, mask);
		ret = mtk_run_shell_cmd(ipcmd, NULL, 0, NULL, NULL, NULL);
		if (gw && gw[0]) {
			memset(ipcmd, 0, 128);
			snprintf(ipcmd, 128, BIN_PATH"busybox route add default gw %s",
				gw);
			return mtk_run_shell_cmd(ipcmd, NULL, 0, NULL, NULL, NULL);
		}
		return ret;
	default:
		mtk_printf("%s unknown ipconfig type", __func__);
		return -2;
	}
}
enum dns_type{
	DNS_PRI,
	DNS_SEC,
	DNS_MAX
};
int mtk_config_dns(char *interface, unsigned char type, char *val)
{
	char dnscmd[128];
	if (!interface)
		return -1;
	switch (type) {
	case DNS_PRI:
		memset(dnscmd, 0, 128);
		snprintf(dnscmd, 128, "setprop dhcp.%s.dns1 %s\n", interface, val);
		mtk_run_shell_cmd(dnscmd, NULL, 0, NULL, NULL, NULL);
		memset(dnscmd, 0, 128);
		snprintf(dnscmd, 128, "setprop net.dns1 %s\n", val);
		return mtk_run_shell_cmd(dnscmd, NULL, 0, NULL, NULL, NULL);
	case DNS_SEC:
		memset(dnscmd, 0, 128);
		snprintf(dnscmd, 128, "setprop dhcp.%s.dns2 %s\n", interface, val);
		mtk_run_shell_cmd(dnscmd, NULL, 0, NULL, NULL, NULL);
		memset(dnscmd, 0, 128);
		snprintf(dnscmd, 128, "setprop net.dns2 %s\n", val);
		return mtk_run_shell_cmd(dnscmd, NULL, 0, NULL, NULL, NULL);
	default:
		mtk_printf("%s unknown dns type\n", __func__);
		return -2;
	}
}

/* network status got from wpa_cli status cmd */
struct network_status {
	char bssid[20]; /* 11:22:33:44:55:66 */
	char freq[8];
	char ssid[64];
	char id[8];
	char mode[64];
	char pairwise_cipher[12];
	char group_cipher[12];
	char key_mgmt[24];
	char wpa_state[32];
	char ip_address[20];
	char address[20];
	char p2p_device_address[20];
	char uuid[128];
};

/* tokenize according to the new line
* restore whole line to the argv[i]
* return:
* number of lines
*/
static int tokenize_line(char *cmd, char *argv[], int len)
{
	char *pos;
	char *start;
	int argc = 0;

	start = pos = cmd;
	for (;;) {
		argv[argc] = pos;
		argc++;
		while (*pos != '\n') {
			pos++;
			if (pos - start >= len)
				break;
		}
		if (*pos == '\n') {
			*pos++ = '\0';
			if (pos - start >= len)
				break;
		}
	}

	return argc;
}

/*
* the output of wpa_cli status is like:
*status
*bssid=56:14:4b:62:21:18
*ssid=and-Business
*id=0
*mode=station
*pairwise_cipher=NONE
*group_cipher=NONE
*key_mgmt=NONE
*wpa_state=COMPLETED
*ip_address=10.50.13.33
*p2p_device_address=02:08:22:ec:30:fc
*address=00:08:22:ec:30:fc
*uuid=92c89e98-41e1-585c-9dd3-93295c36ee3f
* store them to struct network_status;
*/
int mtk_network_status(char *ifname, struct network_status *status)
{
	char statusbuf[1024];
	char *field[20];
	size_t reply_len = 0;
	char *statuargv[64];
	int argc, i;
	MTK_CREATE_WPA_CMD("-i %s -p %s status",
			ifname, WPA_SUPPLICANT_SOCKET_PATH);
	mtk_run_shell_cmd(gWpaCmdStr, statusbuf, sizeof(statusbuf), &reply_len, NULL, NULL);
	if (reply_len) {
		argc = tokenize_line(statusbuf, field, reply_len);
		/* just for debug */
		for (i = 0; i < argc; i++) {
			mtk_printf("argv[%i]: %s\n", i, field[i]);
			if (!strncmp("bssid", field[i], strlen("bssid"))) {
				char *p = strchr(field[i], '=');
				if (p) {
					p++;
					strcpy(status->bssid, p);
				}
				mtk_printf("bssid: %s\n", status->bssid);
			} else if (!strncmp("ssid", field[i], strlen("ssid"))) {
				char *p = strchr(field[i], '=');
				if (p) {
					p++;
					strcpy(status->ssid, p);
				}
				mtk_printf("ssid: %s\n", status->ssid);
			} else if (!strncmp("freq", field[i], strlen("freq"))) {
				char *p = strchr(field[i], '=');
				if (p) {
					p++;
					strcpy(status->freq, p);
				}
				mtk_printf("freq: %s\n", status->freq);
			} else if (!strncmp("id", field[i], strlen("id"))) {
				char *p = strchr(field[i], '=');
				if (p) {
					p++;
					strcpy(status->id, p);
				}
				mtk_printf("id: %s\n", status->id);
			} else if (!strncmp("mode", field[i], strlen("mode"))) {
				char *p = strchr(field[i], '=');
				if (p) {
					p++;
					strcpy(status->mode, p);
				}
				mtk_printf("mode: %s\n", status->mode);
			} else if (!strncmp("pairwise_cipher", field[i], strlen("pairwise_cipher"))) {
				char *p = strchr(field[i], '=');
				if (p) {
					p++;
					strcpy(status->pairwise_cipher, p);
				}
				mtk_printf("pairwise_cipher: %s\n", status->pairwise_cipher);
			} else if (!strncmp("group_cipher", field[i], strlen("group_cipher"))) {
				char *p = strchr(field[i], '=');
				if (p) {
					p++;
					strcpy(status->group_cipher, p);
				}
				mtk_printf("group_cipher: %s\n", status->group_cipher);
			} else if (!strncmp("key_mgmt", field[i], strlen("key_mgmt"))) {
				char *p = strchr(field[i], '=');
				if (p) {
					p++;
					strcpy(status->key_mgmt, p);
				}
				mtk_printf("key_mgmt: %s\n", status->key_mgmt);
			} else if (!strncmp("wpa_state", field[i], strlen("wpa_state"))) {
				char *p = strchr(field[i], '=');
				if (p) {
					p++;
					strcpy(status->wpa_state, p);
				}
				mtk_printf("wpa_state: %s\n", status->wpa_state);
			} else if (!strncmp("ip_address", field[i], strlen("ip_address"))) {
				char *p = strchr(field[i], '=');
				if (p) {
					p++;
					strcpy(status->ip_address, p);
				}
				mtk_printf("ip_address: %s\n", status->ip_address);
			} else if (!strncmp("address", field[i], strlen("address"))) {
				char *p = strchr(field[i], '=');
				if (p) {
					p++;
					strcpy(status->address, p);
				}
				mtk_printf("address: %s\n", status->address);
			} else if (!strncmp("uuid", field[i], strlen("uuid"))) {
				char *p = strchr(field[i], '=');
				if (p) {
					p++;
					strcpy(status->uuid, p);
				}
				mtk_printf("uuid: %s\n", status->uuid);
			} else if (!strncmp("p2p_device_address", field[i],
					strlen("p2p_device_address"))) {
				char *p = strchr(field[i], '=');
				if (p) {
					p++;
					strcpy(status->p2p_device_address, p);
				}
				mtk_printf("p2p_device_address: %s\n", status->p2p_device_address);
			} else
				mtk_printf("feild %s not used for now\n", field[i]);
		}
	}
	return 0;
}
struct network_config {
	int isDhcp;
	char ipaddr[WFA_IP_ADDR_STR_LEN];
	char ipaddr6[IPV6_ADDRESS_STRING_LEN];
	char ipaddr_brd[WFA_IP_ADDR_STR_LEN];
	char mask[WFA_IP_MASK_STR_LEN];
	char dns[WFA_MAX_DNS_NUM][WFA_IP_ADDR_STR_LEN];
	char mac[WFA_MAC_ADDR_STR_LEN];
	char mac_brd[WFA_MAC_ADDR_STR_LEN];
	char mtu[16];
	char qdisc[16];
	char state[16];
	char qlen[16];
};

/*
* The output of ip addr show ifname:
*12: wlan0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq state DOWN qlen 1000
*    link/ether 00:08:22:e2:6b:fd brd ff:ff:ff:ff:ff:ff
*    inet 192.168.1.122/24 brd 192.168.1.255 scope global wlan0
*     valid_lft forever preferred_lft forever
* store them to struct network_config
*
* The output of ifconfig ifname:
* wlan0: ip 192.168.1.122 mask 255.255.255.0 flags [up broadcast multicast]
*  store them to struct network_config
*/
int mtk_get_ipconfig(char *ifname, struct network_config *config)
{
	char ipconfigbuf[64];
	char outputbuf[1024];
	char *argv[24]; /* 24 lines seems enought */
	int argc = 0;
	int i;
	size_t outputlen = 0;
	memset(ipconfigbuf, 0, 64);
	snprintf(ipconfigbuf, 64, "ip addr show %s", ifname);
	mtk_run_shell_cmd(ipconfigbuf, outputbuf, 1024, &outputlen, NULL, NULL);
	if (outputlen) {
		argc = tokenize_line(outputbuf, argv, outputlen);
		char *mtu, *qdisc, *state, *qlen, *ether, *inet, *inet6, *brd;
		char *dest;
		for (i = 0; i < argc; i++) {
			mtk_printf("%s argv[%d]: %s\n", __func__, i, argv[i]);
			mtu = strstr(argv[i], "mtu");
			qdisc = strstr(argv[i], "qdisc");
			state = strstr(argv[i], "state");
			qlen = strstr(argv[i], "qlen");
			ether = strstr(argv[i], "ether");
			inet = strstr(argv[i], "inet");
			inet6 = strstr(argv[i], "inet6");
			brd = strstr(argv[i], "brd");
			if (mtu) {
				dest = config->mtu;
				mtk_printf("%s found mtu\n", __func__);
				while(*mtu != ' ')
					mtu++;
				mtu++; /* now mtu points 1500*/
				while(*mtu != ' ' && *mtu != '\n')
					*dest++ = *mtu++;
			}
			if (qdisc) {
				dest = config->qdisc;
				mtk_printf("%s found qdisc\n", __func__);
				while(*qdisc != ' ')
					qdisc++;
				qdisc++; /* now qdisc points mq*/
				while(*qdisc != ' ' && *qdisc != '\n')
					*dest++ = *qdisc++;
			}
			if (state) {
				dest = config->state;
				mtk_printf("%s found state\n", __func__);
				while(*state != ' ')
					state++;
				state++; /* now state points DOWN*/
				while(*state != ' ' && *state != '\n')
					*dest++ = *state++;
			}
			if (qlen) {
				dest = config->qlen;
				mtk_printf("%s found qlen\n", __func__);
				while(*qlen != ' ')
					qlen++;
				qlen++; /* now qlen points 1000*/
				while(*qlen != ' ' && *qlen != '\n')
					*dest++ = *qlen++;
			}
			if (ether) {
				dest = config->mac;
				mtk_printf("%s found ether\n", __func__);
				while(*ether != ' ')
					ether++;
				ether++; /* now ether points ether*/
				while(*ether != ' ' && *ether != '\n')
					*dest++ = *ether++;
				strcpy(config->mac_brd, "ff:ff:ff:ff:ff:ff");
			}
			/* process IPv4 address */
			if (inet && !inet6) {
				dest = config->ipaddr;
				mtk_printf("%s found inet\n", __func__);
				while(*inet != ' ')
					inet++;
				inet++; /* now ether points ether*/
				while(*inet != ' ' && *inet != '\n' &&
					*inet != '/')
					*dest++ = *inet++;
				if (brd) {
					dest = config->ipaddr_brd;
					while(*brd != ' ')
						brd++;
					brd++; /* now ether points ether*/
					while(*brd != ' ' && *brd != '\n' &&
						*brd != '/')
						*dest++ = *brd++;
				}
			}
			/* process IPv6 address */
			if (inet && inet6) {
				dest = config->ipaddr6;
				mtk_printf("%s found inet6\n", __func__);
				while(*inet6 != ' ')
					inet6++;
				inet6++; /* now ether points ether*/
				while(*inet6 != ' ' && *inet6 != '\n' &&
					*inet6 != '/')
					*dest++ = *inet6++;
			}
		}
	}
	memset(ipconfigbuf, 0, 64);
	snprintf(ipconfigbuf, 64, "ifconfig %s", ifname);
	mtk_run_shell_cmd(ipconfigbuf, outputbuf, 1024, &outputlen, NULL, NULL);
	if (outputlen) {
		argc = tokenize_line(outputbuf, argv, outputlen);
		for (i = 0; i < argc; i++) {
			mtk_printf("debug: %s argv[%d]: %s\n", __func__, i, argv[i]);
			char *mask = strstr(argv[i], "mask");
			char *dest;
			if (mask) {
				dest = config->mask;
				while(*mask != ' ')
					mask++;
				mask++; /* now ether points ether*/
				while(*mask != ' ' && *mask != '\n' &&
					*mask != '/')
					*dest++ = *mask++;

			}
		}
	}
	return 0;
}

/*
*dump network, used for debug
*/
static void dump_network(struct network_config *n)
{
	mtk_printf("ipaddr %s\n", n->ipaddr);
	mtk_printf("ipaddr6 %s\n", n->ipaddr6);
	mtk_printf("ipaddr_brd %s\n", n->ipaddr_brd);
	mtk_printf("mask %s\n", n->mask);
	mtk_printf("dns0 %s\n", n->dns[0]);
	mtk_printf("dns1 %s\n", n->dns[1]);
	mtk_printf("mac %s\n", n->mac);
	mtk_printf("mac_brd %s\n", n->mac_brd);
	mtk_printf("mtu %s\n", n->mtu);
	mtk_printf("qdisc %s\n", n->qdisc);
	mtk_printf("state %s\n", n->state);
	mtk_printf("qlen %s\n", n->qlen);
}
/*
* ping die msage
* --- 192.168.43.1 ping statistics ---
*52 packets transmitted, 52 received, 0% packet loss, time 51079ms
*rtt min/avg/max/mdev = 5.555/562.602/2543.449/739.340 ms, pipe 3
*/
struct ping_status {
	int used;
	int exit_req;
	int exit_rsp;
	char transmitted[16];
	char received[16];
	char loss[16];
	int streamid;
	char pingcmd[124];
	/* ping pthread id */
	pthread_t ppid;
	int pid;
};
void dump_ping(struct ping_status *p)
{
	mtk_printf("streamid %d\n", p->used);
	mtk_printf("streamid %d\n", p->streamid);
	mtk_printf("transmitted %s\n", p->transmitted);
	mtk_printf("received %s\n", p->received);
	mtk_printf("loss %s\n", p->loss);
}
static struct ping_status pingstatus[5];

struct ping_status *get_pingstatus(void)
{
	int i = 0;
	for (i = 0; i< sizeof(pingstatus)/sizeof(pingstatus[0]); i++)
	{
		if (pingstatus[i].used == 0) {
			memset(&pingstatus[i], 0, sizeof(struct ping_status));
			pingstatus[i].used = 1;
			return &pingstatus[i];
		}
	}
	mtk_printf("no available pingstatus found\n");
	return NULL;
}

struct ping_status * find_pingstatus(int streamId)
{
	int i = 0;

	for (i = 0; i< sizeof(pingstatus)/sizeof(pingstatus[0]); i++)
	{
		if (pingstatus[i].streamid == streamId) {
			mtk_printf("target pingstatus found for streamid:%d\n", streamId);
			return &pingstatus[i];
		}
	}
	mtk_printf("no target pingstatus found\n");
	return NULL;
}

int put_pingstatus(struct ping_status *pPingStatus)
{
	int i = 0;

	if (!pPingStatus) {
		mtk_printf("pPingStatus is NULL, put failed\n");
	}

	for (i = 0; i< sizeof(pingstatus)/sizeof(pingstatus[0]); i++)
	{
		if (pPingStatus == &pingstatus[i]) {
			pingstatus[i].used = 0;
			memset(&pingstatus[i], 0, sizeof (struct ping_status));
			return 0;
		}
	}
	mtk_printf("no target found for pPingStatus\n");
	return -1;
}


static void *start_ping_child(void *param)
{
	FILE *pp;
	char *ss;
	char *die_msg = NULL;
	char *transmitted, *received, *loss, *time;
	char *dest;
	char buf[1024];
	struct ping_status *p = param;

	pp = popen(p->pingcmd, "r");
	while (ss = fgets(buf, 100, pp)) {
		if (p->exit_req)
			break;
		mtk_printf("%s:p_thread:0x%x, exit_req:%d\n", __func__, pthread_self(), p->exit_req);
		mtk_printf("buf: %s\n", ss);
		if (strstr(ss, "icmp_seq") || strstr(ss, "unreachable")) {
/*
 * ping fail case 1 (stdio)
 * PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.
 * From 192.168.1.57: icmp_seq=1 Destination Host Unreachable
 * From 192.168.1.57: icmp_seq=2 Destination Host Unreachable
 * From 192.168.1.57: icmp_seq=3 Destination Host Unreachable
 */

/*
 * ping fail case 2 (stderr)
 * connect: Network is unreachable
 */

/*
 * ping ok (stdio)
 * PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.
 * 64 bytes from 192.168.1.1: icmp_seq=1 ttl=64 time=14.0 ms
 * 64 bytes from 192.168.1.1: icmp_seq=2 ttl=64 time=6.93 ms
 * 64 bytes from 192.168.1.1: icmp_seq=3 ttl=64 time=11.8 ms
 */
			int trans, rece;

			trans = atoi(p->transmitted);
			trans++;
			snprintf(p->transmitted, 16, "%d", trans);

			if (strstr(ss, "time")) {
				rece = atoi(p->received);
				rece++;
				snprintf(p->received, 16, "%d", rece);
			}
			snprintf(p->loss, 16, "%.0f%%", (1-((float)rece/(float)trans))*100);

		}
	}
	pclose(pp);
	dump_ping(p);
	p->exit_rsp = 1;
	return NULL;
}
/*
*kill ping sub-thread
*start_ping_child will get ping status
*/
#if 0
void kill_ping(void)
{
	FILE *pp;
	char buf[128 * 4]; /* Max buf for 4 ping cmd that not been killed */
	char pingPid[64];
	char *argv[3];
	int argc;
	char *pos = pingPid;
	char *pingShell = NULL;
	char *pid = NULL;
	size_t readlen = 0;
	int i;

	pid_t ppid = 0;
	memset(buf, 0, 128 * 4);
	memset(pingPid, 0, 64);
	mtk_printf("%s Killing ping...\n", __func__);
	mtk_run_shell_cmd("ps ping", buf, 128 * 4, &readlen, NULL, NULL);
	if (readlen) {
		argc = tokenize_line(buf, argv, readlen);
		for (i = 0; i < argc; i++) {
			mtk_printf("%s argv[%d]: %s\n", __func__, i, argv[i]);
			if (strstr(argv[i], "ping")) {
				pid = argv[i];
				/* move pid until encount space */
				while (*pid != ' ')
					pid++;

				/* skip space */
				mtk_printf("pid %s\n", pid);
				while (*pid == ' ' || *pid == '\t')
					pid++;
				mtk_printf("pid %s\n", pid);
				/* copy pid string to pingPid
				*USER     PID   PPID  VSIZE  RSS     WCHAN    PC        NAME
				*root      23504 13498 1004   304   00000000 b6eff848 R ping
				*/
				while (*pid != ' ') {
					mtk_printf("char %c\n", *pid);
					*pos++ = *pid++;
				}
				ppid = atoi(pingPid);
				mtk_printf("ppid %d\n", ppid);
				kill(ppid, SIGINT);
			}
		}
	}
}
#endif
enum {
	IFCONFIG_UP,
	IFCONFIG_DOWN,
	IFCONFIG_IP,	/* set ip addr using ifconfig wlan0 192.168.1.1 */
	IFCONFIG_DUMP,	/* dump interface using ifconfig wlan0 */
	IFCONFIG_SHOW_INTERFACE,	/* netcfg */
	IFCONFIG_MAX
};

int mtk_ifconfig(char *interface, unsigned char updown, char *ipaddr)
{
	char buf[128];
	char ifconfigcmd[64];
	size_t len = 0;

	switch (updown) {
	case IFCONFIG_UP:
		memset(ifconfigcmd, 0, 64);
		snprintf(ifconfigcmd, 64, "ifconfig %s up", interface);
		return mtk_run_shell_cmd(ifconfigcmd, buf, 128, &len,
					NULL, NULL);
	case IFCONFIG_DOWN:
		memset(ifconfigcmd, 0, 64);
		snprintf(ifconfigcmd, 64, "ifconfig %s down", interface);
		return mtk_run_shell_cmd(ifconfigcmd, buf, 128, &len,
					NULL, NULL);
	case IFCONFIG_IP:
		memset(ifconfigcmd, 0, 64);
		snprintf(ifconfigcmd, 64, "ifconfig %s %s",
				interface, ipaddr);
		return mtk_run_shell_cmd(ifconfigcmd, buf, 128, &len,
					NULL, NULL);
	case IFCONFIG_DUMP:
		memset(ifconfigcmd, 0, 64);
		snprintf(ifconfigcmd, 64, "ifconfig %s", interface);
		return mtk_run_shell_cmd(ifconfigcmd, buf, 128, &len,
					NULL, NULL);
	case IFCONFIG_SHOW_INTERFACE:
		memset(ifconfigcmd, 0, 64);
		snprintf(ifconfigcmd, 64, "netcfg");
		return mtk_run_shell_cmd(ifconfigcmd, buf, 128, &len,
					NULL, NULL);
	default:
		mtk_printf("Unknown ifconfig type %d\n", updown);
	}
	return -2;
}
int mtk_wpa_reassociate(char *interface)
{
	char buf[128];
	size_t len = 0;
	MTK_CREATE_WPA_CMD("-i %s -p %s reassociate",
			interface,
			WPA_SUPPLICANT_SOCKET_PATH);
	return mtk_run_shell_cmd(gWpaCmdStr, buf, 128, &len, NULL, NULL);
}
/*
* parse ssid from WKV(*+8021 to WKV\(*+8021
*/
int mtk_parse_ssid(char *dest, int dest_len,
			char *src, int src_len)
{
	char *pos = dest;
	int len = 0;
	static char *magic = "();<>\"'\\&";
	while (len < src_len &&
		len < dest_len) {
		/*if (*src != '(') {*/
		if (!strchr(magic, *src)) {
			*pos++ = *src++;
			len++;
		} else if (*src != '\0') {
			*pos++ = '\\';
			*pos++ = *src++;
			len += 2;
		} else
			len++;
	}
	*pos = '\0';
	return 0;
}
#endif /* MTK_11N_SIGMA */
static unsigned int fgIsDhcpOn = 0;
#define CERTIFICATES_PATH    "/etc/wpa_supplicant"

/* Some device may only support UDP ECHO, activate this line */
//#define WFA_PING_UDP_ECHO_ONLY 1

#define WFA_ENABLED 1

extern unsigned short wfa_defined_debug;
int wfaExecuteCLI(char *CLI);

/* Since the two definitions are used all over the CA function */
char gCmdStr[WFA_CMD_STR_SZ];
dutCmdResponse_t gGenericResp;
int wfaTGSetPrio(int sockfd, int tgClass);
void create_apts_msg(int msg, unsigned int txbuf[],int id);

int sret = 0;

extern char e2eResults[];
//extern char *e2eResults;
FILE *e2efp = NULL;
int chk_ret_status()
{
    char *ret = getenv(WFA_RET_ENV);

    if(*ret == '1')
       return WFA_SUCCESS;
    else
       return WFA_FAILURE;
}

/*
 * agtCmdProcGetVersion(): response "ca_get_version" command to controller
 *  input:  cmd --- not used
 *          valLen -- not used
 *  output: parms -- a buffer to store the version info response.
 */
int agtCmdProcGetVersion(int len, BYTE *parms, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *getverResp = &gGenericResp;

    DPRINT_INFO(WFA_OUT, "entering agtCmdProcGetVersion ...\n");

    getverResp->status = STATUS_COMPLETE;
    wSTRNCPY(getverResp->cmdru.version, WFA_SYSTEM_VER, WFA_VERNAM_LEN);

    wfaEncodeTLV(WFA_GET_VERSION_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)getverResp, respBuf);

    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

    return WFA_SUCCESS;
}

/*
 * wfaStaAssociate():
 *    The function is to force the station wireless I/F to re/associate 
 *    with the AP.
 */
int wfaStaAssociate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *assoc = (dutCommand_t *)caCmdBuf;
   char *ifname = assoc->intf;
   dutCmdResponse_t *staAssocResp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "entering wfaStaAssociate ...\n");
   /*
    * if bssid appears, station should associate with the specific
    * BSSID AP at its initial association. 
    * If it is different to the current associating AP, it will be forced to 
    * roam the new AP
    */
    FILE *fd;
    char *filename = MTK_WPA_CLI_OUTPUT_BUFFER;
    char idx[16];
    int  idx_i;
    fd = fopen(filename, "r+");
    if ((NULL == fd) || (NULL == fgets(idx, 16, fd))) {
        printf("fail: %s \n", filename);
        staAssocResp->status = STATUS_ERROR;
        wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);
        *respLen = WFA_TLV_HDR_LEN + 4;
        return WFA_FAILURE;
    } else {
        idx_i = atoi(idx);
        DPRINT_INFO(WFA_OUT, "[%s]The network index is [%d]", __func__, idx_i);
    }
#ifdef MTK_11N_SIGMA
    //sprintf(gCmdStr, "wpa_cli -i %s %s select_network %d", WFA_STAUT_IF, ctrl_if, idx_i);
	mtk_select_network(ifname, idx_i);
	//mtk_reconnect(ifname);
#else

   if(assoc->cmdsu.assoc.bssid[0] != '\0')
   {
      /* if (the first association) */
      /* just do initial association to the BSSID */

 
      /* else (station already associate to an AP) */
      /* Do forced roaming */

   }
   else
   {
      /* use 'ifconfig' command to bring down the interface (linux specific) */
      sprintf(gCmdStr, "ifconfig %s down", ifname);
      sret = system(gCmdStr);

      /* use 'ifconfig' command to bring up the interface (linux specific) */
      sprintf(gCmdStr, "ifconfig %s up", ifname);
      sret = system(gCmdStr);

      /* 
       *  use 'wpa_cli' command to force a 802.11 re/associate 
       *  (wpa_supplicant specific) 
       */
      sprintf(gCmdStr, "wpa_cli -i%s reassociate", ifname);
      sret = system(gCmdStr);
   }
#endif
   /*
    * Then report back to control PC for completion.
    * This does not have failed/error status. The result only tells
    * a completion.
    */
   staAssocResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS; 
}

#define WFA_TIME_DIFF(before, after, rtime, dtime) \
             dtime = rtime + (after.tv_sec*1000000 + after.tv_usec) - (before.tv_sec*1000000 + before.tv_usec);

void pause_time(int delay)
{
    struct timeval now, stop;
    int diff;
    int remain_time = 0;

    wGETTIMEOFDAY(&stop, 0);

    stop.tv_usec += delay;
    if(stop.tv_usec > 1000000)
    {
        stop.tv_usec -=1000000;
        stop.tv_sec +=1;
    }

    do
    {
        wGETTIMEOFDAY(&now, 0);
        WFA_TIME_DIFF(now, stop, remain_time, diff);
    }
    while(diff>0);
}
/*
 * wfaStaReAssociate():
 *    The function is to force the station wireless I/F to re/associate 
 *    with the AP.
 */
int wfaStaReAssociate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *reassoc = (dutCommand_t *)caCmdBuf;
    char *ifname = reassoc->intf;
   dutCmdResponse_t *staAssocResp = &gGenericResp;

   int i;

    FILE *tmpfile1 = NULL;
    FILE *tmpfile2 = NULL;
    FILE *tmpfile3 = NULL;
    char ssid_id[8];
    char ssid_str[WFA_SSID_NAME_LEN];
    char conn_bssid[64];
    char *tmpfilename1 = "/tmp/bssid2ssid.txt";
    char *tmpfilename2 = "/tmp/ssid2id.txt";
    char *tmpfilename3 = "/tmp/conn_status.txt";

    MTK_HS20_CMD("-i %s -p %s ap_scan 1 ", ifname, WPA_SUPPLICANT_SOCKET_PATH);
    MTK_HS20_CMD("-i %s -p %s ap_scan 1 ", ifname, WPA_SUPPLICANT_SOCKET_PATH);
    MTK_HS20_CMD("-i %s -p %s ap_scan 1 ", ifname, WPA_SUPPLICANT_SOCKET_PATH);
    MTK_HS20_CMD("-i %s -p %s reassociate \n", ifname, WPA_SUPPLICANT_SOCKET_PATH);

    //make sure connection
    for(i=0; i<20; i++) {
        MTK_HS20_CMD("-i %s -p %s status | grep ^wpa_state= | cut -f2- -d= > %s \n",
                        ifname,
                        WPA_SUPPLICANT_SOCKET_PATH,
                        tmpfilename3);
        tmpfile3 = fopen(tmpfilename3, "r+");

        if(fscanf(tmpfile3, "%s", conn_bssid) != EOF) {
            if(/*conn_bssid != NULL &&*/ strncmp(conn_bssid, "COMPLETED", 9) == 0) {
                MTK_HS20_CMD("-i %s -p %s status | grep bssid | cut -f 2 -d = > %s \n",
                                ifname,
                                WPA_SUPPLICANT_SOCKET_PATH,
                                tmpfilename3);
                tmpfile3 = fopen(tmpfilename3, "r+");

                if(fscanf(tmpfile3, "%s", conn_bssid) != EOF) {
                    if(/*conn_bssid != NULL &&*/ strncmp(conn_bssid, reassoc->cmdsu.assoc.bssid, 17) == 0) {
                        DPRINT_INFO(WFA_OUT, "Reassociation to %s is connected ...\n", conn_bssid);
                        break;
                    } else {
                        DPRINT_INFO(WFA_OUT, "Reassociation to other target(tgt: %s)(ori: %s) ...\n",
                                                conn_bssid, reassoc->cmdsu.assoc.bssid);
                    }
                }
                break;
            }
        } else {
            DPRINT_INFO(WFA_OUT, "Reassociation times %d ...\n", i);
        }
        pause_time(1000000);
    }
    fclose(tmpfile3);
    pause_time(2000000);

    if(fgIsDhcpOn) {
        printf("Requesting DHCP IP!\n");

#if 0 /* MTK_WPA3_SIGMA */
        if(fgIsIpv6Dhcp)
            sprintf(gCmdStr,"dhclient -6 %s", ifname);
        else
            sprintf(gCmdStr,"dhclient %s", ifname);

        printf("%s[%u] %s", __FUNCTION__, __LINE__, gCmdStr);
        system(gCmdStr);
#else
        system("dhcp -i wlan0");
#endif
        printf("DHCP DONE!\n");
    }
#if 0
   DPRINT_INFO(WFA_OUT, "entering wfaStaAssociate ...\n");
#ifdef MTK_11N_SIGMA
	if (reassoc->cmdsu.assoc.bssid[0] != '\0') {
		/* UCC want to do specific associate
		* Maybe could implement as network_set id bssid xx:xx:xx:xx:xx:xx
		*/
		mtk_printf("%s UCC want to associate specific bssid... not ready now\n");
	} else {
		mtk_ifconfig("wlan0", IFCONFIG_DOWN, NULL);
		mtk_ifconfig("wlan0", IFCONFIG_UP, NULL);
		mtk_wpa_reassociate("wlan0");
	}
#else
   /*
    * if bssid appears, station should associate with the specific
    * BSSID AP at its initial association. 
    * If it is different to the current associating AP, it will be forced to 
    * roam the new AP
    */
   if(reassoc->cmdsu.assoc.bssid[0] != '\0')
   {
      /* if (the first association) */
      /* just do initial association to the BSSID */

 
      /* else (station already associate to an AP) */
      /* Do forced roaming */

   }
   else
   {
       /* use 'ifconfig' command to bring down the interface (linux specific) */
       sprintf(gCmdStr, "ifconfig %s down", ifname);
       sret = system(gCmdStr);

       /* use 'ifconfig' command to bring up the interface (linux specific) */
       sprintf(gCmdStr, "ifconfig %s up", ifname);

       /* 
        *  use 'wpa_cli' command to force a 802.11 re/associate 
        *  (wpa_supplicant specific) 
        */
       sprintf(gCmdStr, "wpa_cli -i%s reassociate", ifname);
       sret = system(gCmdStr);
    }
#endif
#endif
    /*
     * Then report back to control PC for completion.
     * This does not have failed/error status. The result only tells
     * a completion.
     */
    staAssocResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS; 
}

/*
 * wfaStaIsConnected():
 *    The function is to check whether the station's wireless I/F has 
 *    already connected to an AP.
 */
int wfaStaIsConnected(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *connStat = (dutCommand_t *)caCmdBuf;
   dutCmdResponse_t *staConnectResp = &gGenericResp;
   char *ifname = connStat->intf;
   FILE *tmpfile = NULL;
   char result[32];


   DPRINT_INFO(WFA_OUT, "Entering isConnected ...\n"); 

#ifdef WFA_NEW_CLI_FORMAT
   sprintf(gCmdStr, "wfa_chkconnect %s\n", ifname); 
   sret = system(gCmdStr);

   if(chk_ret_status() == WFA_SUCCESS)
      staConnectResp->cmdru.connected = 1;
   else
      staConnectResp->cmdru.connected = 0;
#else
   /*
    * use 'wpa_cli' command to check the interface status
    * none, scanning or complete (wpa_supplicant specific)
    */
#ifdef MTK_11N_SIGMA
	struct network_status networkstatus;
	memset(&networkstatus, 0, sizeof(struct network_status));
	mtk_network_status("wlan0", &networkstatus);
	if (strncmp(networkstatus.wpa_state, "COMPLETED", 9) == 0)
		staConnectResp->cmdru.connected = 1;
	else
		staConnectResp->cmdru.connected = 0;

#else
   sprintf(gCmdStr, "/sbin/wpa_cli -i%s status | grep ^wpa_state= | cut -f2- -d= > /tmp/.isConnected", ifname);
   sret = system(gCmdStr);

   /*
    * the status is saved in a file.  Open the file and check it.
    */
   tmpfile = fopen("/tmp/.isConnected", "r+");
   if(tmpfile == NULL)
   {
      staConnectResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_IS_CONNECTED_RESP_TLV, 4, (BYTE *)staConnectResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return WFA_FAILURE;
   }

   sret = fscanf(tmpfile, "%s", (char *)result);

   if(strncmp(result, "COMPLETED", 9) == 0)
      staConnectResp->cmdru.connected = 1;
   else
      staConnectResp->cmdru.connected = 0;
#endif
#endif

   /*
    * Report back the status: Complete or Failed.
    */
   staConnectResp->status = STATUS_COMPLETE;
   
   wfaEncodeTLV(WFA_STA_IS_CONNECTED_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)staConnectResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   return WFA_SUCCESS;
}

/*
 * wfaStaGetIpConfig():
 * This function is to retriev the ip info including
 *     1. dhcp enable
 *     2. ip address
 *     3. mask 
 *     4. primary-dns
 *     5. secondary-dns
 *
 *     The current implementation is to use a script to find these information
 *     and store them in a file. 
 */
int wfaStaGetIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    int slen, ret, i = 0;
    dutCommand_t *getIpConf = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *ipconfigResp = &gGenericResp; 
    char *ifname = getIpConf->intf;
    caStaGetIpConfigResp_t *ifinfo = &ipconfigResp->cmdru.getIfconfig;

    FILE *tmpfd;
    char string[256];
    char *str;

#ifdef MTK_11N_SIGMA
	struct network_config networkconfig;
	memset(&networkconfig, 0, sizeof(struct network_config));
	mtk_get_ipconfig("wlan0", &networkconfig);
	dump_network(&networkconfig);
	/* Dhcp is always aviliable in 11n STA mode */
	ifinfo->isDhcp = 1;
	if (networkconfig.ipaddr[0])
		strncpy(ifinfo->ipaddr, networkconfig.ipaddr, 15);
	else
		strcpy(ifinfo->ipaddr, "none");

	ifinfo->ipaddr[15]='\0';
	if (networkconfig.mask[0])
		strncpy(ifinfo->mask, networkconfig.mask, 15);
	else
		strcpy(ifinfo->mask, "none");
	ifinfo->mask[15] = '\0';
	/* we really need dns? */
	strcpy(ifinfo->dns[0], "none");
	strcpy(ifinfo->dns[1], "none");
        strncpy(ifinfo->mac, networkconfig.mac, 17);
#else
    /*
     * check a script file (the current implementation specific)
     */
    ret = access("/usr/local/sbin/getipconfig.sh", F_OK);
    if(ret == -1)
    {
       ipconfigResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);   
       *respLen = WFA_TLV_HDR_LEN + 4;

       DPRINT_ERR(WFA_ERR, "file not exist\n");
       return WFA_FAILURE; 

    }

    strcpy(ifinfo->dns[0], "0");
    strcpy(ifinfo->dns[1], "0");
    
    /*
     * Run the script file "getipconfig.sh" to check the ip status 
     * (current implementation  specific). 
     * note: "getipconfig.sh" is only defined for the current implementation
     */
    sprintf(gCmdStr, "getipconfig.sh /tmp/ipconfig.txt %s\n", ifname); 

    sret = system(gCmdStr);

    /* open the output result and scan/retrieve the info */
    tmpfd = fopen("/tmp/ipconfig.txt", "r+");

    if(tmpfd == NULL)
    {
      ipconfigResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return WFA_FAILURE;
    }

    for(;;)
    {
        if(fgets(string, 256, tmpfd) == NULL)
           break; 

        /* check dhcp enabled */
        if(strncmp(string, "dhcpcli", 7) ==0)
        {
            str = strtok(string, "=");
            str = strtok(NULL, "=");
            if(str != NULL)
               ifinfo->isDhcp = 1;
            else
               ifinfo->isDhcp = 0;
        }

        /* find out the ip address */
        if(strncmp(string, "ipaddr", 6) == 0)
        {
            str = strtok(string, "=");
            str = strtok(NULL, " ");
            if(str != NULL)
            {
               wSTRNCPY(ifinfo->ipaddr, str, 15);
               ifinfo->ipaddr[15]='\0';
            }
            else
               wSTRNCPY(ifinfo->ipaddr, "none", 15);
        }

        /* check the mask */
        if(strncmp(string, "mask", 4) == 0)
        {
            char ttstr[16];
            char *ttp = ttstr;

            str = strtok_r(string, "=", &ttp);
            if(*ttp != '\0')
            {
               strcpy(ifinfo->mask, ttp);
               slen = strlen(ifinfo->mask);
               ifinfo->mask[slen-1] = '\0';
            }
            else
               strcpy(ifinfo->mask, "none");
        }

        /* find out the dns server ip address */
        if(strncmp(string, "nameserv", 8) == 0)
        {
            char ttstr[16];
            char *ttp = ttstr;
            
            str = strtok_r(string, " ", &ttp);
            if(str != NULL && i < 2)
            {
               strcpy(ifinfo->dns[i], ttp);
               slen = strlen(ifinfo->dns[i]);
               ifinfo->dns[i][slen-1] = '\0';
            }
            else
               strcpy(ifinfo->dns[i], "none");

            i++;
        }
     }
#endif
     /*
      * Report back the results
      */
     ipconfigResp->status = STATUS_COMPLETE;
     wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)ipconfigResp, respBuf);   

     *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

#if 0
     DPRINT_INFO(WFA_OUT, "%i %i %s %s %s %s %i\n", ipconfigResp->status, 
        ifinfo->isDhcp, ifinfo->ipaddr, ifinfo->mask, 
            ifinfo->dns[0], ifinfo->dns[1], *respLen);
#endif

#if !defined(MTK_11N_SIGMA) && !defined(__CYGWIN__)
     fclose(tmpfd);
#endif
     return WFA_SUCCESS;
}

/*
 * wfaStaSetIpConfig():
 *   The function is to set the ip configuration to a wireless I/F.
 *   1. IP address
 *   2. Mac address
 *   3. default gateway
 *   4. dns nameserver (pri and sec).  
 */
int wfaStaSetIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *setIpConf = (dutCommand_t *)caCmdBuf;
   caStaSetIpConfig_t *ipconfig = &setIpConf->cmdsu.ipconfig;
   dutCmdResponse_t *staSetIpResp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "entering wfaStaSetIpConfig ...\n");

   if (fgIsDhcpOn) {
        /* TODO */
        sprintf(gCmdStr, "dhcp -i %s", WFA_STAUT_IF);
        sret = system(gCmdStr);
        printf("system: %s\n",gCmdStr);
        staSetIpResp->status = STATUS_COMPLETE;
        wfaEncodeTLV(WFA_STA_SET_IP_CONFIG_RESP_TLV, 4, (BYTE *)staSetIpResp, respBuf);
        *respLen = WFA_TLV_HDR_LEN + 4;
        return WFA_SUCCESS;
    }
   /*
    * Use command 'ifconfig' to configure the interface ip address, mask.
    * (Linux specific).
    */
#ifdef MTK_11N_SIGMA
	if (ipconfig->isDhcp) {
		mtk_config_ip("wlan0", IPCONFIG_DHCP, NULL, NULL, NULL);
		goto _SUCCESS;
	} else {
		mtk_config_ip("wlan0", IPCONFIG_MANUAL, ipconfig->ipaddr,
			ipconfig->mask, ipconfig->defGateway);
	}
   //sprintf(gCmdStr, "/sbin/ifconfig %s %s netmask %s > /dev/null 2>&1 ", ipconfig->intf, ipconfig->ipaddr, ipconfig->mask);
   //sret = system(gCmdStr);

   /* use command 'route add' to set set gatewway (linux specific) */ 
   //if(ipconfig->defGateway[0] != '\0')
   //{
      //sprintf(gCmdStr, "/sbin/route add default gw %s > /dev/null 2>&1", ipconfig->defGateway);
      //sret = system(gCmdStr);
   //}
	if (ipconfig->pri_dns[0])
		mtk_config_dns("wlan0", DNS_PRI, ipconfig->pri_dns);
	if (ipconfig->sec_dns[0])
		mtk_config_dns("wlan0", DNS_SEC, ipconfig->sec_dns);

   /* set dns (linux specific) */
   //sprintf(gCmdStr, "cp /etc/resolv.conf /tmp/resolv.conf.bk");
   //sret = system(gCmdStr);
   //sprintf(gCmdStr, "echo nameserv %s > /etc/resolv.conf", ipconfig->pri_dns);
   //sret = system(gCmdStr);
   //sprintf(gCmdStr, "echo nameserv %s >> /etc/resolv.conf", ipconfig->sec_dns);
  // sret = system(gCmdStr);
_SUCCESS:
#else

   sprintf(gCmdStr, "/sbin/ifconfig %s %s netmask %s > /dev/null 2>&1 ", ipconfig->intf, ipconfig->ipaddr, ipconfig->mask);
   sret = system(gCmdStr);

   /* use command 'route add' to set set gatewway (linux specific) */ 
   if(ipconfig->defGateway[0] != '\0')
   {
      sprintf(gCmdStr, "/sbin/route add default gw %s > /dev/null 2>&1", ipconfig->defGateway);
      sret = system(gCmdStr);
   }

   /* set dns (linux specific) */
   sprintf(gCmdStr, "cp /etc/resolv.conf /tmp/resolv.conf.bk");
   sret = system(gCmdStr);
   sprintf(gCmdStr, "echo nameserv %s > /etc/resolv.conf", ipconfig->pri_dns);
   sret = system(gCmdStr);
   sprintf(gCmdStr, "echo nameserv %s >> /etc/resolv.conf", ipconfig->sec_dns);
   sret = system(gCmdStr);
#endif
   /*
    * report status
    */
   staSetIpResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_IP_CONFIG_RESP_TLV, 4, (BYTE *)staSetIpResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

/*
 * wfaStaVerifyIpConnection():
 * The function is to verify if the station has IP connection with an AP by
 * send ICMP/pings to the AP.
 */ 
int wfaStaVerifyIpConnection(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *verip = (dutCommand_t *)caCmdBuf;
   dutCmdResponse_t *verifyIpResp = &gGenericResp;

#ifndef WFA_PING_UDP_ECHO_ONLY
#ifdef MTK_11N_SIGMA
	struct ping_status *p = NULL;
	int ret = 0;

	p = get_pingstatus();
	if (p == NULL) {
		verifyIpResp->status = STATUS_COMPLETE;
		mtk_printf("%s no available pingstatus found\n", __func__);
		verifyIpResp->cmdru.connected = 0;
	} else {

		if(verip->cmdsu.verifyIp.timeout <= 0) {
			verip->cmdsu.verifyIp.timeout = 10;
		}

		snprintf(p->pingcmd, 124, SIGMA_PING" -c 3 -W %u %s",
					verip->cmdsu.verifyIp.timeout,
					verip->cmdsu.verifyIp.dipaddr);
		mtk_printf("%s Create pthread for ping\n", __func__);
		mtk_printf("%s Ping cmd: %s streamid: %d\n",
				__func__, p->pingcmd, p->streamid);
		pthread_create(&p->ppid, NULL, start_ping_child, p);
		/* sleep 5s to wait ping finished */
		sleep(5);
		p->exit_req = 1;
		mtk_printf("%s child ppid:0x%x, exit_req:%d\n", __func__, p->ppid, p->exit_req);
		while (p->exit_rsp == 0){
			mtk_printf("%s wait for ping thraed (0x%x) exit, exit_rsp:%d\n", __func__, p->ppid, p->exit_rsp);
			sleep(1);
		}
		if (p->transmitted[0] &&
		    p->received[0]) {
			verifyIpResp->status = STATUS_COMPLETE;
			verifyIpResp->cmdru.connected = 1;
		} else {
			verifyIpResp->status = STATUS_COMPLETE;
			mtk_printf("%s not connected\n", __func__);
			verifyIpResp->cmdru.connected = 0;
		}
		put_pingstatus(p);
	}
#else
   char strout[64], *pcnt;
   FILE *tmpfile;
   
   DPRINT_INFO(WFA_OUT, "Entering wfaStaVerifyIpConnection ...\n");

   /* set timeout value in case not set */
   if(verip->cmdsu.verifyIp.timeout <= 0)
   {
        verip->cmdsu.verifyIp.timeout = 10;
   }
   
   /* execute the ping command  and pipe the result to a tmp file */
   sprintf(gCmdStr, "ping %s -c 3 -W %u | grep loss | cut -f3 -d, 1>& /tmp/pingout.txt", verip->cmdsu.verifyIp.dipaddr, verip->cmdsu.verifyIp.timeout);
   sret = system(gCmdStr); 

   /* scan/check the output */
   tmpfile = fopen("/tmp/pingout.txt", "r+");
   if(tmpfile == NULL)
   {
      verifyIpResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, 4, (BYTE *)verifyIpResp, respBuf);   
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return WFA_FAILURE;
   }
   
   verifyIpResp->status = STATUS_COMPLETE;
   if(fscanf(tmpfile, "%s", strout) == EOF)
       verifyIpResp->cmdru.connected = 0;
   else
   {
       pcnt = strtok(strout, "%"); 
       
       /* if the loss rate is 100%, not able to connect */
       if(atoi(pcnt) == 100)
          verifyIpResp->cmdru.connected = 0;
       else
          verifyIpResp->cmdru.connected = 1;
   }

   fclose(tmpfile);
#endif
#else
   int btSockfd;
   struct pollfd fds[2];
   int timeout = 2000;
   char anyBuf[64];
   struct sockaddr_in toAddr;
   int done = 1, cnt = 0, ret, nbytes;

   verifyIpResp->status = STATUS_COMPLETE;
   verifyIpResp->cmdru.connected = 0;

   btSockfd = wfaCreateUDPSock("127.0.0.1", WFA_UDP_ECHO_PORT);

   if(btSockfd == -1)
   {
      verifyIpResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, 4, (BYTE *)verifyIpResp, respBuf);   
      *respLen = WFA_TLV_HDR_LEN + 4;
      return WFA_FAILURE;;
   }

   toAddr.sin_family = AF_INET;
   toAddr.sin_addr.s_addr = inet_addr(verip->cmdsu.verifyIp.dipaddr);
   toAddr.sin_port = htons(WFA_UDP_ECHO_PORT);

   while(done)
   {
       wfaTrafficSendTo(btSockfd, (char *)anyBuf, 64, (struct sockaddr *)&toAddr);
       cnt++;

       fds[0].fd = btSockfd;
       fds[0].events = POLLIN | POLLOUT; 

       ret = poll(fds, 1, timeout);
       switch(ret)
       {
           case 0:
             /* it is time out, count a packet lost*/
           break;
           case -1:
             /* it is an error */
           default:
           {
              switch(fds[0].revents)
              {
                  case POLLIN:
                  case POLLPRI:
                  case POLLOUT:
                  nbytes = wfaTrafficRecv(btSockfd, (char *)anyBuf, (struct sockaddr *)&toAddr);
                  if(nbytes != 0)
                      verifyIpResp->cmdru.connected = 1;
                      done = 0;
                  break;
                  default:
                  /* errors but not care */
                   ;
              } 
           }
       } 
       if(cnt == 3)
       {
          done = 0;
       }
   }
       
#endif

   wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)verifyIpResp, respBuf);   

   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
   
   return WFA_SUCCESS;
}

/*
 * wfaStaGetMacAddress()
 *    This function is to retrieve the MAC address of a wireless I/F.
 */
int wfaStaGetMacAddress(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *getMac = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *getmacResp = &gGenericResp;
    char *str;
    char *ifname = getMac->intf;

    FILE *tmpfd;
    char string[257];

    DPRINT_INFO(WFA_OUT, "Entering wfaStaGetMacAddress ...\n");
#ifdef MTK_11N_SIGMA
	struct network_config networkconfig;
	memset(&networkconfig, 0, sizeof(struct network_config));
	mtk_get_ipconfig("wlan0", &networkconfig);
	dump_network(&networkconfig);
        strncpy(getmacResp->cmdru.mac, networkconfig.mac, 17);
        getmacResp->status = STATUS_COMPLETE;
#else
    /*
     * run the script "getipconfig.sh" to find out the mac
     */
    //sprintf(gCmdStr, "getipconfig.sh /tmp/ipconfig.txt %s", ifname); 
    sprintf(gCmdStr, "ifconfig %s > /tmp/ipconfig.txt ", ifname); 
    sret = system(gCmdStr);

    tmpfd = fopen("/tmp/ipconfig.txt", "r+");
    if(tmpfd == NULL)
    {
      getmacResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_GET_MAC_ADDRESS_RESP_TLV, 4, (BYTE *)getmacResp, respBuf);   
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return WFA_FAILURE;
    }

    if(fgets((char *)&string[0], 256, tmpfd) == NULL)
    {
       getmacResp->status = STATUS_ERROR;
    }

    str = strtok(string, " ");
    while(str && ((strcmp(str,"HWaddr")) != 0))
    {
       str = strtok(NULL, " ");
    }
         
    /* get mac */
    if(str)
    {
        str = strtok(NULL, " ");
        strcpy(getmacResp->cmdru.mac, str);
        getmacResp->status = STATUS_COMPLETE;
    }
#endif
    wfaEncodeTLV(WFA_STA_GET_MAC_ADDRESS_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)getmacResp, respBuf);   

    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
#if !defined(MTK_11N_SIGMA) && !defined(__CYGWIN__)
    fclose(tmpfd);
#endif
    return WFA_SUCCESS;
}

/*
 * wfaStaGetStats():
 * The function is to retrieve the statistics of the I/F's layer 2 txFrames, 
 * rxFrames, txMulticast, rxMulticast, fcsErrors/crc, and txRetries.
 * Currently there is not definition how to use these info. 
 */
int wfaStaGetStats(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *statsResp = &gGenericResp;

   /* this is never used, you can skip this call */

   statsResp->status = STATUS_ERROR;
   wfaEncodeTLV(WFA_STA_GET_STATS_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)statsResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);


   return WFA_SUCCESS;
}

/*
 * wfaSetEncryption():
 *   The function is to set the wireless interface with WEP or none.
 *
 *   Since WEP is optional test, current function is only used for 
 *   resetting the Security to NONE/Plaintext (OPEN). To test WEP, 
 *   this function should be replaced by the next one (wfaSetEncryption1())
 *
 *   Input parameters: 
 *     1. I/F
 *     2. ssid
 *     3. encpType - wep or none
 *     Optional:
 *     4. key1
 *     5. key2
 *     6. key3
 *     7. key4
 *     8. activeKey Index
 */

int wfaSetEncryption1(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
   dutCmdResponse_t *setEncrypResp = &gGenericResp;
   
   /*
    * disable the network first
    */
   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", setEncryp->intf);
   sret = system(gCmdStr);

   /*
    * set SSID
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", setEncryp->intf, setEncryp->ssid);
   sret = system(gCmdStr);

   /*
    * Tell the supplicant for infrastructure mode (1)
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 mode 0", setEncryp->intf);
   sret = system(gCmdStr);

   /*
    * set Key management to NONE (NO WPA) for plaintext or WEP
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt NONE", setEncryp->intf);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", setEncryp->intf);
   sret = system(gCmdStr);

   setEncrypResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

/*
 *  Since WEP is optional, this function could be used to replace
 *  wfaSetEncryption() if necessary. 
 */
int wfaSetEncryption(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
   dutCmdResponse_t *setEncrypResp = &gGenericResp;
   int i;
#ifdef MTK_11N_SIGMA
	int network_id = -1;
	char ssid_buf[64];
	char ssid_buf_tmp[64];
	network_id = mtk_add_network(setEncryp->intf);
	/* add network first */
	/*
	* disable the network first
	*/
	mtk_disable_network(setEncryp->intf, network_id);

	/*
	* set SSID
	*/ 
	memset(ssid_buf, 0, 64);
	memset(ssid_buf_tmp, 0, 64);
	mtk_parse_ssid(ssid_buf_tmp, 64, setEncryp->ssid, 64);
	snprintf(ssid_buf, 64, "\\\"%s\\\"", ssid_buf_tmp);
	mtk_set_network(setEncryp->intf, network_id, "ssid", ssid_buf);
	//sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", setEncryp->intf, setEncryp->ssid);
	//sret = system(gCmdStr);

	/*
	* Tell the supplicant for infrastructure mode (1)
	*/

	mtk_set_network(setEncryp->intf, network_id, "mode", "0");
	//sprintf(gCmdStr, "wpa_cli -i %s set_network 0 mode 0", setEncryp->intf);
	//sret = system(gCmdStr);

	/*
	* set Key management to NONE (NO WPA) for plaintext or WEP
	*/

	mtk_set_network(setEncryp->intf, network_id, "key_mgmt", "NONE");

	//sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt NONE", setEncryp->intf);
	//sret = system(gCmdStr);

   /* set keys */
	if(setEncryp->encpType == 1) {
		  for (i=0; i<4; i++) {
			 if (setEncryp->keys[i][0] != '\0') {
				mtk_set_wep_key(setEncryp->intf,
					network_id, NULL, i, setEncryp->keys[i]);
			     //sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_key%i %s",
			           //setEncryp->intf, i, setEncryp->keys[i]);
			     //sret = system(gCmdStr);
			 }
		  }

		/* set active key */
		i = setEncryp->activeKeyIdx;
		if (setEncryp->keys[i][0] != '\0') {
			mtk_set_wep_key(setEncryp->intf,
					network_id, "wep_tx_keyidx", setEncryp->activeKeyIdx,
					NULL);

			//sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_tx_keyidx %i",
			//setEncryp->intf, setEncryp->activeKeyIdx);
			//sret = system(gCmdStr);
		}
	} else { /* clearly remove the keys -- reported by p.schwann */

		for (i = 0; i < 4; i++) {
			char wepkey[8];
			memset(wepkey, 0, 8);
			snprintf(wepkey, 8, "\"\"");
			mtk_set_wep_key(setEncryp->intf, network_id,
				NULL, i, wepkey);
		}
	}

	mtk_select_network(setEncryp->intf, network_id);

#else
   /*
    * disable the network first
    */
   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", setEncryp->intf);
   sret = system(gCmdStr);

   /*
    * set SSID
    */    
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", setEncryp->intf, setEncryp->ssid);
   sret = system(gCmdStr);

   /*
    * Tell the supplicant for infrastructure mode (1)
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 mode 0", setEncryp->intf);
   sret = system(gCmdStr);

   /*
    * set Key management to NONE (NO WPA) for plaintext or WEP
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt NONE", setEncryp->intf);
   sret = system(gCmdStr);

   /* set keys */
   if(setEncryp->encpType == 1)
   {
      for(i=0; i<4; i++)
      {
         if(setEncryp->keys[i][0] != '\0')
         {
             sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_key%i %s",
                   setEncryp->intf, i, setEncryp->keys[i]);
             sret = system(gCmdStr);
         }
      }

      /* set active key */
      i = setEncryp->activeKeyIdx;
      if(setEncryp->keys[i][0] != '\0')
      {
          sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_tx_keyidx %i",
            setEncryp->intf, setEncryp->activeKeyIdx);
          sret = system(gCmdStr);
      }
   }
   else /* clearly remove the keys -- reported by p.schwann */
   {
         
      for(i = 0; i < 4; i++)
      {
          sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_key%i \"\"", setEncryp->intf, i);
          sret = system(gCmdStr);
      }
   }

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", setEncryp->intf);
   sret = system(gCmdStr);
#endif
   setEncrypResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

int wfaStaSetSecurity(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    int ret = WFA_SUCCESS;
    caStaSetSecurity_t *setSecurity = (caStaSetSecurity_t *)caCmdBuf;
    dutCmdResponse_t *setSecurityResp = &gGenericResp;
    FILE *fd;
    char *filename = MTK_WPA_CLI_OUTPUT_BUFFER;
    char wpa_parameter[WFA_PARIWISE_CIPHER_LEN];
    char idx[16];
    int  idx_i;
    unsigned int fgIsOWE = FALSE;
    unsigned int fgIsSAE = FALSE;
    unsigned int fgIsReconfig = FALSE;
    unsigned int u4Pmf = 0;

    DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __func__);

    /* wpa_cli -i wlan0 add_network */
    MTK_WPA3_CMD("-i %s -p %s add_network > %s", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, filename);

    /* get net network index */
    fd = fopen(filename, "r+");
    if ((NULL == fd) || (NULL == fgets(idx, 16, fd))) {
        printf("fail: %s \n", filename);
        setSecurityResp->status = STATUS_ERROR;
        wfaEncodeTLV(WFA_STA_SET_SECURITY_RESP_TLV, 4, (BYTE *)setSecurityResp, respBuf);
        *respLen = WFA_TLV_HDR_LEN + 4;
        return WFA_FAILURE;
    } else {
        idx_i = atoi(idx);
        DPRINT_INFO(WFA_OUT, "[%s]The network index is [%d]", __func__, idx_i);
	//maintained_network_idx = idx_i;
    }

    /* wpa_cli -i wlan0 disable_network 0 */
    MTK_WPA3_CMD("-i %s -p %s disable_network %d", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i);

    /* wpa_cli -i wlan0 set_network 0 ssid "ssud" */
    MTK_WPA3_CMD("-i %s -p %s set_network %d ssid '\"%s\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, setSecurity->ssid);

    /* wpa_cli -i wlan0 set_network 0 pairwise xxxx */  // union of pariwiseCipher and encpType
    memset(wpa_parameter, 0, WFA_PARIWISE_CIPHER_LEN);
    if (setSecurity->type == SEC_TYPE_PSK)
        goto SET_PSK;

    if (strlen(setSecurity->pairwiseCipher)) {
        /* If there are multiple ciphers, space separated list will be provided. */
    if (strcasecmp(setSecurity->pairwiseCipher, "AES-GCMP-256")==0)
        strcat(wpa_parameter, "GCMP-256 ");  // wpa_parameter has the same length to pairwiseCipher. No overflow concern here.
	else if (strcasecmp(setSecurity->pairwiseCipher, "AES-CCMP-256")==0)
        strcat(wpa_parameter, "CCMP-256 ");
	else if (strcasecmp(setSecurity->pairwiseCipher, "AES-GCMP-128")==0)
        strcat(wpa_parameter, "GCMP ");
    else if (strcasecmp(setSecurity->pairwiseCipher, "AES-CCMP-128")==0)
        strcat(wpa_parameter, "CCMP ");
    else
        DPRINT_INFO(WFA_WNG, "Unknow pairwiseCipher %s", setSecurity->pairwiseCipher);
    } else if (strlen(setSecurity->encpType)) {
        if (strcasecmp(setSecurity->encpType, "TKIP")==0)
            strcat(wpa_parameter, "TKIP ");
        else if (strcasecmp(setSecurity->encpType, "AES-CCMP")==0)
            strcat(wpa_parameter, "CCMP ");
        else if (strcasecmp(setSecurity->encpType, "AES-GCMP")==0)
            strcat(wpa_parameter, "GCMP ");
        else
            DPRINT_INFO(WFA_WNG, "Unknow encpType %s", setSecurity->encpType);
        }
    if(strlen(wpa_parameter))
        MTK_WPA3_CMD("-i %s -p %s set_network %d pairwise %s", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, wpa_parameter);

        /* wpa_cli -i wlan0 set_network 0 group xxxx */  // union of groupCipher and encpType
        memset(wpa_parameter, 0, WFA_PARIWISE_CIPHER_LEN);
        if (strlen(setSecurity->groupCipher)) {
            /* If there are multiple ciphers, space separated list will be provided. */
            if (strcasecmp(setSecurity->groupCipher, "AES-GCMP-256")==0)
                strcat(wpa_parameter, "GCMP-256 ");  // wpa_parameter has the same length to pairwiseCipher. No overflow concern here.
            else if (strcasecmp(setSecurity->groupCipher, "AES-CCMP-256")==0)
                strcat(wpa_parameter, "CCMP-256 ");
            else if (strcasecmp(setSecurity->groupCipher, "AES-GCMP-128")==0)
                strcat(wpa_parameter, "GCMP ");
            else if (strcasecmp(setSecurity->groupCipher, "AES-CCMP-128")==0)
                strcat(wpa_parameter, "CCMP ");
            else
                DPRINT_INFO(WFA_WNG, "Unknow groupCipher %s", setSecurity->groupCipher);
            } else if(strlen(setSecurity->encpType)) {
                if (strcasecmp(setSecurity->encpType, "TKIP")==0)
                    strcat(wpa_parameter, "TKIP ");
                else if (strcasecmp(setSecurity->encpType, "AES-CCMP")==0)
                    strcat(wpa_parameter, "CCMP ");
                else if (strcasecmp(setSecurity->encpType, "AES-GCMP")==0)
                    strcat(wpa_parameter, "GCMP ");
                else
                    DPRINT_INFO(WFA_WNG, "Unknow encpType %s", setSecurity->encpType);
            }
            if(strlen(wpa_parameter))
                MTK_WPA3_CMD("-i %s -p %s set_network %d group %s", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, wpa_parameter);

            /* wpa_cli -i wlan0 set_network 0 group_mgmt xxxx */
            memset(wpa_parameter, 0, WFA_PARIWISE_CIPHER_LEN);
            if (strlen(setSecurity->groupMgmtCipher)) {
                /* If there are multiple ciphers, space separated list will be provided. */
                if (strcasecmp(setSecurity->groupMgmtCipher, "BIP-GMAC-256")==0)
                    strcat(wpa_parameter, "BIP-GMAC-256 ");  // wpa_parameter has the same length to pairwiseCipher. No overflow concern here.
                else if (strcasecmp(setSecurity->groupMgmtCipher, "BIP-CMAC-256")==0)
                    strcat(wpa_parameter, "BIP-CMAC-256 ");
                else if (strcasecmp(setSecurity->groupMgmtCipher, "BIP-GMAC-128")==0)
                    strcat(wpa_parameter, "BIP-GMAC-128 ");
                else if (strcasecmp(setSecurity->groupMgmtCipher, "BIP-CMAC-128")==0)
                    strcat(wpa_parameter, "AES-128-CMAC ");
                else
                    DPRINT_INFO(WFA_WNG, "Unknow groupMgmtCipher %s", setSecurity->groupMgmtCipher);
            }
            if(strlen(wpa_parameter))
                MTK_WPA3_CMD("-i %s -p %s set_network %d group_mgmt %s", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, wpa_parameter);

            /* wpa_cli -i wlan0 set_network 0 key_mgmt xxxx */
            u4Pmf = setSecurity->pmf;
            memset(wpa_parameter, 0, WFA_PARIWISE_CIPHER_LEN);
            if(strcasecmp(setSecurity->keyMgmtType, "SuiteB")==0)
            {
                strcat(wpa_parameter, "WPA-EAP-SUITE-B-192");
                u4Pmf = 2; // WPA3 UCC script may not send the mandatory PMF paramter ....
            }
            else if (strcasecmp(setSecurity->keyMgmtType, "OWE")==0 || setSecurity->type == SEC_TYPE_OWE)
            // Follow both defination in WiFi_TestSuite_Control_API_Specification_v10.2.0_security_v0.9 and UCC script cmds.
            {
                fgIsOWE = TRUE;
                strcat(wpa_parameter, "OWE");
                u4Pmf = 2; //WPA3 UCC script may not send the mandatory PMF paramter ....
            }
            else if(setSecurity->type == SEC_TYPE_SAE)
            {
                fgIsSAE = TRUE;
                strcat(wpa_parameter, "SAE");
                u4Pmf = 2; //WPA3 UCC script may not send the mandatory PMF paramter ....
            }
            else if(setSecurity->type == SEC_TYPE_PSK_SAE) //Transition compatibility mode that PSK and SAE are enabled
            {
                fgIsSAE = TRUE;
                strcat(wpa_parameter, "SAE WPA-PSK");
                u4Pmf = 2; //WPA3 UCC script may not send the mandatory PMF paramter ....
            }
            else if(setSecurity->type == SEC_TYPE_PSK) {
SET_PSK:
                strcat(wpa_parameter, "WPA-PSK");
                goto SET_PSK2;
	    }
            else if(setSecurity->type == SEC_TYPE_EAPTLS  ||
                    setSecurity->type == SEC_TYPE_EAPTTLS ||
                    setSecurity->type == SEC_TYPE_EAPPEAP ||
                    setSecurity->type == SEC_TYPE_EAPSIM  ||
                    setSecurity->type == SEC_TYPE_EAPFAST ||
                    setSecurity->type == SEC_TYPE_EAPAKA
                    )
                strcat(wpa_parameter, "WPA-EAP");
            else
                strcat(wpa_parameter, "NONE");

            if (strlen(wpa_parameter))
SET_PSK2:
                MTK_WPA3_CMD("-i %s -p %s set_network %d key_mgmt %s", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, wpa_parameter);

                if(setSecurity->type == SEC_TYPE_PSK)
                    goto SET_PSK3;
                /* wpa_cli -i wlan0 set_network 0 ieee80211w x */
                MTK_WPA3_CMD("-i %s -p %s set_network %d ieee80211w %d", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, u4Pmf);

SET_PSK3:
                /* wpa_cli -i wlan0 set_network 0 psk "xxxxxxxx" */
                if(setSecurity->type == SEC_TYPE_PSK || setSecurity->type == SEC_TYPE_SAE ||setSecurity->type == SEC_TYPE_PSK_SAE)
                MTK_WPA3_CMD("-i %s -p %s set_network %d psk '\"%s\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, setSecurity->secu.passphrase);

                switch(setSecurity->type)
                {
                    case SEC_TYPE_EAPTLS:
                        /* Default Setting in sigma program located at "Wi-FiTestSuite\radius_agent\radiator and hostapd certs.zip" */
                        MTK_WPA3_CMD("-i %s -p %s set_network %d eap TLS", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d ca_cert '\"%s/%s.pem\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, CERTIFICATES_PATH, setSecurity->secu.tls.trustedRootCA);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d client_cert '\"%s/%s.pem\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, CERTIFICATES_PATH, setSecurity->secu.tls.clientCertificate);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d identity '\"tls user\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d private_key '\"%s/%s.key\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, CERTIFICATES_PATH, setSecurity->secu.tls.clientCertificate);
                        //MTK_WPA3_CMD("-i %s set_network %d private_key_passwd '\"wifi\"'", setSecurity->intf, idx_i);
                        if(strcasecmp(setSecurity->keyMgmtType, "SuiteB")==0)
                        {
                            /* UCC does not set group_mgmt so that we hard code for that */
                            MTK_WPA3_CMD("-i %s -p %s set_network %d group_mgmt BIP-GMAC-256", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i);
                        }
                        break;

                    case SEC_TYPE_EAPTTLS:
                        MTK_WPA3_CMD("-i %s -p %s set_network %d eap TTLS", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d priority %d", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, (setSecurity->secu.ttls.prefer==1?1:0));
                        MTK_WPA3_CMD("-i %s -p %s set_network %d phase2 '\"auth=MSCHAPV2\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d identity '\"%s\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, setSecurity->secu.ttls.username);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d password '\"%s\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, setSecurity->secu.ttls.passwd);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d client_cert %s", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, setSecurity->secu.ttls.clientCertificate);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d private_key NULL", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d ca_cert '\"%s/%s.pem\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, CERTIFICATES_PATH, setSecurity->secu.ttls.trustedRootCA);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d imsi '\"none\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d sim_slot '\"-1\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d pcsc '\"none\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i);
                        //MTK_WPA3_CMD("-i %s set_network %d private_key_passwd '\"wifi\"'", setSecurity->intf, idx_i);
                        if(strcasecmp(setSecurity->keyMgmtType, "SuiteB")==0)
                        {
                            /* UCC does not set group_mgmt so that we hard code for that */
                            MTK_WPA3_CMD("-i %s -p %s set_network %d group_mgmt BIP-GMAC-256", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i);
                        }
                        break;

                    case SEC_TYPE_EAPPEAP:
                        MTK_WPA3_CMD("-i %s -p %s set_network %d eap PEAP", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d anonymous_identity '\"anonymous\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d identity '\"%s\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, setSecurity->secu.peap.username);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d password '\"%s\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, setSecurity->secu.peap.passwd);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d ca_cert '\"%s\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, setSecurity->secu.peap.trustedRootCA);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d phase1 '\"peaplabel=%i\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, setSecurity->secu.peap.peapVersion);
                        MTK_WPA3_CMD("-i %s -p %s set_network %d phase2 '\"auth=%s\"'", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, setSecurity->secu.peap.innerEAP);
                        //MTK_WPA3_CMD("-i %s set_network %d private_key_passwd '\"wifi\"'", setSecurity->intf, idx_i);
                        if(strcasecmp(setSecurity->keyMgmtType, "SuiteB")==0)
                        {
                            /* UCC does not set group_mgmt so that we hard code for that */
                            MTK_WPA3_CMD("-i %s -p %s set_network %d group_mgmt BIP-GMAC-256", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i);
                        }
                        break;

                    case SEC_TYPE_EAPSIM:
                        DPRINT_INFO(WFA_WNG, "[TODO] SEC_TYPE_EAPSIM\n");
                        break;

                    case SEC_TYPE_EAPFAST:
                        DPRINT_INFO(WFA_WNG, "[TODO] SEC_TYPE_EAPFAST\n");
                        break;

                    case SEC_TYPE_EAPAKA:
                        DPRINT_INFO(WFA_WNG, "[TODO] SEC_TYPE_EAPAKA\n");
                        break;

                    default:
                        break;
                }

                if (strlen(setSecurity->certType)) {
                    DPRINT_INFO(WFA_WNG, "[TODO] certType %s\n", setSecurity->certType);  // should do anything about it?
                }

                if (strlen(setSecurity->TLSCipher)) {
                    DPRINT_INFO(WFA_WNG, "[WARN] Set TLSCIpher %s, make sure your supplicant has patch \n", setSecurity->TLSCipher);  // your supplicant needs patch CL404517 at DaVanci server for OPENSSL_CIPHERS.
                    MTK_WPA3_CMD("-i %s -p %s openssl_ciphers %s", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, setSecurity->TLSCipher);
                    fgIsReconfig = TRUE;
                }

                if (strlen(setSecurity->SAEInvalidElement)) {
                    DPRINT_INFO(WFA_WNG, "[TODO] SAEInvalidElement %s\n", setSecurity->SAEInvalidElement); // ?
                }

                if (strlen(setSecurity->ecGroupID)) {
                    if(fgIsOWE == TRUE) {
                        MTK_WPA3_CMD("-i %s -p %s set_network %d owe_group %s", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i, setSecurity->ecGroupID);
                    } else if(fgIsSAE == TRUE) {
                        DPRINT_INFO(WFA_WNG, "Set SAE ecGroupID %s\n", setSecurity->ecGroupID);  // your supplicant needs patch CL404517 at DaVanci server for SAE_GROUPS.
                        MTK_WPA3_CMD("-i %s -p %s sae_groups %s", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, setSecurity->ecGroupID);
                        fgIsReconfig = TRUE;
                    }
                }

                /* wpa_cli -i wlan0 enable_network 0 */
                MTK_WPA3_CMD("-i %s -p %s enable_network %d", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH, idx_i);

                /* wpa_cli -i wlan0 save config */
                MTK_WPA3_CMD("-i %s -p %s save_config", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH);

                /* wpa_cli -i wlan0 reconfigure */
                if(fgIsReconfig == TRUE) {
                    MTK_WPA3_CMD("-i %s -p %s reconfigure", setSecurity->intf, WPA_SUPPLICANT_SOCKET_PATH);
                }

                setSecurityResp->status = STATUS_COMPLETE;
                wfaEncodeTLV(WFA_STA_SET_SECURITY_RESP_TLV, 4, (BYTE *)setSecurityResp, respBuf);
                *respLen = WFA_TLV_HDR_LEN + 4;
    return ret;
}

/*
 * wfaStaSetEapTLS():
 *   This is to set
 *   1. ssid
 *   2. encrypType - tkip or aes-ccmp
 *   3. keyManagementType - wpa or wpa2
 *   4. trustedRootCA
 *   5. clientCertificate
 */
int wfaStaSetEapTLS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapTLS_t *setTLS = (caStaSetEapTLS_t *)caCmdBuf;
   char *ifname = setTLS->intf;
   dutCmdResponse_t *setEapTlsResp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetEapTLS ...\n");

   /*
    * need to store the trustedROOTCA and clientCertificate into a file first.
    */
#ifdef WFA_NEW_CLI_FORMAT
   sprintf(gCmdStr, "wfa_set_eaptls -i %s %s %s %s", ifname, setTLS->ssid, setTLS->trustedRootCA, setTLS->clientCertificate);
   sret = system(gCmdStr);
#else
#ifdef MTK_11N_SIGMA

	char ssidbuf[64];
	char certpath[512];
	char ssidbuf_tmp[64];
	int network_id = mtk_add_network(ifname);
	memset(ssidbuf_tmp, 0, 64);
	memset(ssidbuf, 0, 64);
	mtk_parse_ssid(ssidbuf_tmp, 64, setTLS->ssid, 64);
	snprintf(ssidbuf, 64, "\\\"%s\\\"", ssidbuf_tmp);

	mtk_set_network(ifname, network_id, "ssid", ssidbuf);
	mtk_set_network(ifname, network_id, "key_mgmt", "WPA-EAP");
	//mtk_set_network(ifname, network_id, "proto", "WPA");
	mtk_set_network(ifname, network_id, "eap", "TLS");

	memset(certpath, 0, 512);
	snprintf(certpath, 512, "\\\"%s/%s.pem\\\"", EAP_CERT_PATH, setTLS->trustedRootCA);
	mtk_set_network(ifname, network_id, "ca_cert", certpath);

	memset(certpath, 0, 512);
	snprintf(certpath, 512, "\\\"%s/%s.pem\\\"", EAP_CERT_PATH, setTLS->clientCertificate);
	mtk_set_network(ifname, network_id, "client_cert", certpath);

	memset(certpath, 0, 512);
	snprintf(certpath, 512, "\\\"%s/%s.key\\\"", EAP_CERT_PATH, setTLS->clientCertificate);
	mtk_set_network(ifname, network_id, "private_key", certpath);

	mtk_set_network(ifname, network_id, "private_key_passwd", "\\\"wifi\\\"");

	memset(certpath, 0, 512);
	snprintf(certpath, 512, "\\\"%s\\\"", setTLS->username);
	mtk_set_network(ifname, network_id, "identity", certpath);
	mtk_select_network(ifname, network_id);
#else
   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
   sret = system(gCmdStr);

   /* ssid */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setTLS->ssid);
   sret = system(gCmdStr);

   /* key management */
   if(strcasecmp(setTLS->keyMgmtType, "wpa2-sha256") == 0)
   {
   }
   else if(strcasecmp(setTLS->keyMgmtType, "wpa2-eap") == 0)
   {
   }
   else if(strcasecmp(setTLS->keyMgmtType, "wpa2-ft") == 0)
   {

   }
   else if(strcasecmp(setTLS->keyMgmtType, "wpa") == 0)
   {
      sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   }
   else if(strcasecmp(setTLS->keyMgmtType, "wpa2") == 0)
   {
      // to take all and device to pick any one supported.
   }
   else
   {
      // ??
   }
   sret = system(gCmdStr);

   /* protocol WPA */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA", ifname);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap TLS", ifname);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ca_cert '\"%s\"'", ifname, setTLS->trustedRootCA);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"wifi-user@wifilabs.local\"'", ifname);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 private_key '\"%s/%s\"'", ifname, CERTIFICATES_PATH, setTLS->clientCertificate);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 private_key_passwd '\"wifi\"'", ifname);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
   sret = system(gCmdStr);
#endif
#endif

   setEapTlsResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_EAPTLS_RESP_TLV, 4, (BYTE *)setEapTlsResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

/*
 * The function is to set 
 *   1. ssid
 *   2. passPhrase
 *   3. keyMangementType - wpa/wpa2
 *   4. encrypType - tkip or aes-ccmp
 */
int wfaStaSetPSK(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetPSK_t *setPSK = (caStaSetPSK_t *)caCmdBuf;
   dutCmdResponse_t *setPskResp = &gGenericResp;

#ifdef WFA_NEW_CLI_FORMAT
   sprintf(gCmdStr, "wfa_set_psk %s %s %s", setPSK->intf, setPSK->ssid, setPSK->passphrase);
   sret = system(gCmdStr);
#else
#ifdef MTK_11N_SIGMA
	char pskbuf[128];
	char ssidbuf[64];
	char ssidbuf_tmp[64];
	int network_id = mtk_add_network(setPSK->intf);
	memset(ssidbuf, 0, 64);

	memset(ssidbuf_tmp, 0, 64);
	mtk_parse_ssid(ssidbuf_tmp, 64, setPSK->ssid, 64);
	snprintf(ssidbuf, 64, "\\\"%s\\\"", ssidbuf_tmp);

	mtk_set_network(setPSK->intf, network_id, "ssid", ssidbuf);
   //sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", setPSK->intf, setPSK->ssid); 
   //sret = system(gCmdStr);

   if(strcasecmp(setPSK->keyMgmtType, "wpa2-sha256") == 0)
   {
	mtk_printf("%s %d wpa2-sha256\n", __func__, __LINE__);
       //sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA2-SHA256", setPSK->intf);
       mtk_set_network(setPSK->intf, network_id, "key_mgmt", "WPA-PSK-SHA256");
   }
   else if(strcasecmp(setPSK->keyMgmtType, "wpa2") == 0)
   {
	mtk_printf("%s %d wpa2\n", __func__, __LINE__);
	mtk_set_network(setPSK->intf, network_id, "key_mgmt", "WPA-PSK");
     // take all and device to pick it supported.
   }
   else if(strcasecmp(setPSK->keyMgmtType, "wpa2-psk") == 0)
   {
	mtk_printf("%s %d wpa2-psk\n", __func__, __LINE__);
	mtk_set_network(setPSK->intf, network_id, "key_mgmt", "WPA-PSK");
   }
   else if(strcasecmp(setPSK->keyMgmtType, "wpa2-ft") == 0)
   {
      	mtk_printf("%s %d wpa2-ft\n", __func__, __LINE__);
	mtk_set_network(setPSK->intf, network_id, "key_mgmt", "FT-PSK");
   }
   else if (strcasecmp(setPSK->keyMgmtType, "wpa2-wpa-psk") == 0)
   {
	mtk_printf("%s %d wpa2-wpa-psk\n", __func__, __LINE__);
	mtk_set_network(setPSK->intf, network_id, "key_mgmt", "WPA-PSK");
   }
   else
	mtk_set_network(setPSK->intf, network_id, "key_mgmt", "WPA-PSK");
       //sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-PSK", setPSK->intf);

   //sret = system(gCmdStr);
   memset(pskbuf, 0, 128);
   snprintf(pskbuf, 128, "\\\"%s\\\"", setPSK->passphrase);
   /* No need to set key_mgmt according to the test, we only need SSID&PSk to get the PMK */
   mtk_set_network(setPSK->intf, network_id, "psk", pskbuf);
   //sprintf(gCmdStr, "wpa_cli -i %s set_network 0 psk '\"%s\"'", setPSK->intf, setPSK->passphrase); 
   //sret = system(gCmdStr);

   mtk_select_network(setPSK->intf, network_id);
   //sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", setPSK->intf);
   //sret = system(gCmdStr);

   /* if PMF enable */
   if(setPSK->pmf == WFA_ENABLED || setPSK->pmf == WFA_OPTIONAL)
   {

   }
   else if(setPSK->pmf == WFA_REQUIRED)
   {

   }
   else if(setPSK->pmf == WFA_F_REQUIRED)
   {

   }
   else if(setPSK->pmf == WFA_F_DISABLED)
   {

   }
   else
   {   /* Disable PMF */

   }

#else
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", setPSK->intf, setPSK->ssid); 
   sret = system(gCmdStr);

   if(strcasecmp(setPSK->keyMgmtType, "wpa2-sha256") == 0)
       sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA2-SHA256", setPSK->intf); 
   else if(strcasecmp(setPSK->keyMgmtType, "wpa2") == 0)
   {
     // take all and device to pick it supported.
   }
   else if(strcasecmp(setPSK->keyMgmtType, "wpa2-psk") == 0)
   {

   }
   else if(strcasecmp(setPSK->keyMgmtType, "wpa2-ft") == 0)
   {

   }
   else if (strcasecmp(setPSK->keyMgmtType, "wpa2-wpa-psk") == 0)
   {

   }
   else
       sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-PSK", setPSK->intf); 

   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 psk '\"%s\"'", setPSK->intf, setPSK->passphrase); 
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", setPSK->intf);
   sret = system(gCmdStr);

   /* if PMF enable */
   if(setPSK->pmf == WFA_ENABLED || setPSK->pmf == WFA_OPTIONAL)
   {

   }
   else if(setPSK->pmf == WFA_REQUIRED)
   {

   } 
   else if(setPSK->pmf == WFA_F_REQUIRED)
   {
   
   } 
   else if(setPSK->pmf == WFA_F_DISABLED)
   {
   
   } 
   else
   {   /* Disable PMF */

   }
#endif
#endif

   setPskResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setPskResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS; 
}

/*
 * wfaStaGetInfo(): 
 * Get vendor specific information in name/value pair by a wireless I/F.
 */
int wfaStaGetInfo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   dutCommand_t *getInfo = (dutCommand_t *)caCmdBuf;

   /*
    * Normally this is called to retrieve the vendor information
    * from a interface, no implement yet
    */
#ifdef MTK_11N_SIGMA
   sprintf(infoResp.cmdru.info, "interface,%s,vendor, MediaTek inc. ,cardtype,802.11a/b/g/n", getInfo->intf);
#else
   sprintf(infoResp.cmdru.info, "interface,%s,vendor,XXX,cardtype,802.11a/b/g", getInfo->intf);
#endif
   
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_GET_INFO_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}

/*
 * wfaStaSetEapTTLS():
 *   This is to set
 *   1. ssid
 *   2. username
 *   3. passwd
 *   4. encrypType - tkip or aes-ccmp
 *   5. keyManagementType - wpa or wpa2
 *   6. trustedRootCA
 */
int wfaStaSetEapTTLS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapTTLS_t *setTTLS = (caStaSetEapTTLS_t *)caCmdBuf;
   char *ifname = setTTLS->intf;
   dutCmdResponse_t *setEapTtlsResp = &gGenericResp;

#ifdef WFA_NEW_CLI_FORMAT
   sprintf(gCmdStr, "wfa_set_eapttls %s %s %s %s %s", ifname, setTTLS->ssid, setTTLS->username, setTTLS->passwd, setTTLS->trustedRootCA);
   sret = system(gCmdStr);
#else

#ifdef MTK_11N_SIGMA
	char ssidbuf[64];
	char certpath[512];
	char ssidbuf_tmp[64];
	int network_id = mtk_add_network(ifname);
	memset(ssidbuf_tmp, 0, 64);
	memset(ssidbuf, 0, 64);
	mtk_parse_ssid(ssidbuf_tmp, 64, setTTLS->ssid, 64);
	snprintf(ssidbuf, 64, "\\\"%s\\\"", ssidbuf_tmp);

	mtk_set_network(ifname, network_id, "ssid", ssidbuf);
	mtk_set_network(ifname, network_id, "key_mgmt", "WPA-EAP");
	if (wSTRNCMP(setTTLS->keyMgmtType, "wpa2", 4) == 0)
		mtk_set_network(ifname, network_id, "proto", "RSN");
	else
		mtk_set_network(ifname, network_id, "proto", "WPA");
	mtk_set_network(ifname, network_id, "eap", "TTLS");
	/* CA cert. Use the latest certs from Lab and put them to EAP_CERT_PATH. */

	if (setTTLS->trustedRootCA[0] != 0) {
		memset(certpath, 0, 512);
		snprintf(certpath, 512, "\\\"%s/%s.pem\\\"", EAP_CERT_PATH, setTTLS->trustedRootCA);
		mtk_set_network(ifname, network_id, "ca_cert", certpath);
	}

	memset(certpath, 0, 512);
	snprintf(certpath, 512, "\\\"%s\\\"", setTTLS->username);
	mtk_set_network(ifname, network_id, "identity", certpath);

	memset(certpath, 0, 512);
	snprintf(certpath, 512, "\\\"%s\\\"", setTTLS->passwd);
	mtk_set_network(ifname, network_id, "password", certpath);

	memset(ssidbuf_tmp, 0, sizeof(ssidbuf_tmp));
	if (strstr(setTTLS->encrptype, "ccmp"))
		strcat(ssidbuf_tmp, "CCMP");
	if (strstr(setTTLS->encrptype, "tkip"))
		strcat(ssidbuf_tmp, " TKIP");
	if (ssidbuf_tmp[0] == 0) {
		DPRINT_INFO(WFA_OUT, "no pairwise cipher is set, default set to CCMP TKIP\n");
		strcpy(ssidbuf_tmp, "CCMP TKIP");
	}
	mtk_set_network(ifname, network_id, "pairwise", ssidbuf_tmp);
	mtk_set_network(ifname, network_id, "phase2", "'\"auth=MSCHAPV2\"'");
	mtk_select_network(ifname, network_id);
#else

   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setTTLS->ssid);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setTTLS->username);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 password '\"%s\"'", ifname, setTTLS->passwd);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   sret = system(gCmdStr);

/* This may not need to set. if it is not set, default to take all */
//   sprintf(cmdStr, "wpa_cli -i %s set_network 0 pairwise '\"%s\"", ifname, setTTLS->encrptype);
   if(strcasecmp(setTTLS->keyMgmtType, "wpa2-sha256") == 0)
   {
   }
   else if(strcasecmp(setTTLS->keyMgmtType, "wpa2-eap") == 0)
   {
   }
   else if(strcasecmp(setTTLS->keyMgmtType, "wpa2-ft") == 0)
   {

   }
   else if(strcasecmp(setTTLS->keyMgmtType, "wpa") == 0)
   {

   }
   else if(strcasecmp(setTTLS->keyMgmtType, "wpa2") == 0)
   {
      // to take all and device to pick one it supported
   }
   else
   {
      // ??
   }
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap TTLS", ifname);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ca_cert '\"%s/%s\"'", ifname, CERTIFICATES_PATH, setTTLS->trustedRootCA);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA", ifname);
   sret = system(gCmdStr);

//   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 anonymous_identity '\"anonymous\"'", ifname);
//   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase2 '\"auth=MSCHAPV2\"'", ifname);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
   sret = system(gCmdStr);
#endif
#endif

   setEapTtlsResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_EAPTTLS_RESP_TLV, 4, (BYTE *)setEapTtlsResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

/*
 * wfaStaSetEapSIM():
 *   This is to set
 *   1. ssid
 *   2. user name
 *   3. passwd
 *   4. encrypType - tkip or aes-ccmp
 *   5. keyMangementType - wpa or wpa2
 */
int wfaStaSetEapSIM(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapSIM_t *setSIM = (caStaSetEapSIM_t *)caCmdBuf;
   char *ifname = setSIM->intf;
   dutCmdResponse_t *setEapSimResp = &gGenericResp;

#ifdef WFA_NEW_CLI_FORMAT
   sprintf(gCmdStr, "wfa_set_eapsim %s %s %s %s", ifname, setSIM->ssid, setSIM->username, setSIM->encrptype);
   sret = system(gCmdStr);
#else
#ifdef MTK_11N_SIGMA
	char ssidbuf[64];
	char buf[512];
	int network_id = mtk_add_network(ifname);

	mtk_set_global(ifname, "external_sim", "0");

	memset(buf, 0, sizeof(buf));
	memset(ssidbuf, 0, sizeof(ssidbuf));
	mtk_parse_ssid(buf, sizeof(buf), setSIM->ssid, sizeof(ssidbuf));
	snprintf(ssidbuf, sizeof(ssidbuf), "\\\"%s\\\"", buf);
	mtk_set_network(ifname, network_id, "ssid", ssidbuf);

	memset(buf, 0, sizeof(buf));
	snprintf(buf, sizeof(buf), "\\\"%s\\\"", setSIM->username);
	mtk_set_network(ifname, network_id, "imsi", buf);

	mtk_set_network(ifname, network_id, "identity", buf);

	memset(buf, 0, sizeof(buf));
	snprintf(buf, sizeof(buf), "\\\"%s\\\"", setSIM->passwd);

	mtk_set_network(ifname, network_id, "password", buf);

	/* sim_slot should be -1 if using milenage */
	mtk_set_network(ifname, network_id, "sim_slot", "\\\"-1\\\"");
	
	/* password for milenage should set in property */
	memset(buf, 0, sizeof(buf));
	snprintf(buf, sizeof(buf), "setprop wlan.softsim.sim %s", setSIM->passwd);
	system(buf);
	memset(buf, 0, sizeof(buf));
	if (strstr(setSIM->encrptype, "ccmp"))
		strcat(buf, "CCMP");
	if (strstr(setSIM->encrptype, "tkip"))
		strcat(buf, " TKIP");
	if (buf[0] == 0) {
		DPRINT_INFO(WFA_OUT, "no pairwise cipher is set, default set to CCMP TKIP\n");
		strcpy(buf, "CCMP TKIP");
	}
	mtk_set_network(ifname, network_id, "pairwise", buf);
	if (wSTRNCMP(setSIM->keyMgmtType, "wpa2", 4) == 0)
		mtk_set_network(ifname, network_id, "proto", "RSN");
	else
		mtk_set_network(ifname, network_id, "proto", "WPA");
	mtk_set_network(ifname, network_id, "key_mgmt", "WPA-EAP");

	mtk_select_network(ifname, network_id);
#else
   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setSIM->ssid);
   sret = system(gCmdStr);


   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setSIM->username);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 pairwise '\"%s\"'", ifname, setSIM->encrptype);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap SIM", ifname);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA", ifname);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
   sret = system(gCmdStr);

   if(strcasecmp(setSIM->keyMgmtType, "wpa2-sha256") == 0)
   {
      sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-SHA256", ifname);
   }
   else if(strcasecmp(setSIM->keyMgmtType, "wpa2-eap") == 0)
   {
      sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   }
   else if(strcasecmp(setSIM->keyMgmtType, "wpa2-ft") == 0)
   {
      sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-FT", ifname);
   }
   else if(strcasecmp(setSIM->keyMgmtType, "wpa") == 0)
   {
      sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   }
   else if(strcasecmp(setSIM->keyMgmtType, "wpa2") == 0)
   {
      // take all and device to pick one which is supported.
   }
   else
   {
      // ??
   }
   sret = system(gCmdStr);
#endif
#endif

   setEapSimResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_EAPSIM_RESP_TLV, 4, (BYTE *)setEapSimResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

/*
 * wfaStaSetPEAP()
 *   This is to set
 *   1. ssid
 *   2. user name
 *   3. passwd
 *   4. encryType - tkip or aes-ccmp
 *   5. keyMgmtType - wpa or wpa2
 *   6. trustedRootCA
 *   7. innerEAP
 *   8. peapVersion
 */
int wfaStaSetPEAP(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapPEAP_t *setPEAP = (caStaSetEapPEAP_t *)caCmdBuf;
   char *ifname = setPEAP->intf;
   dutCmdResponse_t *setPeapResp = &gGenericResp;

#ifdef WFA_NEW_CLI_FORMAT
   sprintf(gCmdStr, "wfa_set_peap %s %s %s %s %s %s %i %s", ifname, setPEAP->ssid, setPEAP->username, 
                                                          setPEAP->passwd, setPEAP->trustedRootCA,
							  setPEAP->encrptype, setPEAP->peapVersion,
							  setPEAP->innerEAP);
   sret = system(gCmdStr);
#elif defined(MTK_11N_SIGMA)
	char ssidbuf[64];
	char certpath[512];
	char buf[64];
	int network_id = mtk_add_network(ifname);
	int i = 0;
	memset(buf, 0, 64);
	memset(ssidbuf, 0, 64);
	mtk_parse_ssid(buf, 64, setPEAP->ssid, 64);
	snprintf(ssidbuf, 64, "\\\"%s\\\"", buf);

	mtk_set_network(ifname, network_id, "ssid", ssidbuf);
	mtk_set_network(ifname, network_id, "key_mgmt", "WPA-EAP");
	mtk_set_network(ifname, network_id, "eap", "PEAP");
	if (wSTRNCMP(setPEAP->keyMgmtType, "wpa2", 4) == 0)
		mtk_set_network(ifname, network_id, "proto", "RSN");
	else
		mtk_set_network(ifname, network_id, "proto", "WPA");
	/* CA cert. Use the latest certs from Lab and put them to EAP_CERT_PATH. */
	if (setPEAP->trustedRootCA[0] != 0) {
		wMEMSET(certpath, 0, sizeof(certpath));
		//wSPRINTF(certpath, "\\\""EAP_CERT_PATH"/%s.pem\\\"", setPEAP->trustedRootCA);
		wSPRINTF(certpath, "\\\"%s/%s.pem\\\"", EAP_CERT_PATH, setPEAP->trustedRootCA);
		mtk_set_network(ifname, network_id, "ca_cert", certpath);
	}
	/* identity */
	memset(buf, 0, sizeof(buf));
	snprintf(buf, sizeof(buf), "\\\"%s\\\"", setPEAP->username);
	mtk_set_network(ifname, network_id, "identity", buf);
	/* password */
	memset(buf, 0, sizeof(buf));
	snprintf(buf, sizeof(buf), "\\\"%s\\\"", setPEAP->passwd);
	mtk_set_network(ifname, network_id, "password", buf);
	/* pairwise */
	memset(buf, 0, sizeof(buf));
	if (strstr(setPEAP->encrptype, "ccmp"))
		strcat(buf, "CCMP");
	if (strstr(setPEAP->encrptype, "tkip"))
		strcat(buf, " TKIP");
	if (buf[0] == 0) {
		DPRINT_INFO(WFA_OUT, "no pairwise cipher is set, default set to CCMP TKIP\n");
		strcpy(buf, "CCMP TKIP");
	}
	mtk_set_network(ifname, network_id, "pairwise", buf);
	/* phase 1 */
	wMEMSET(buf, 0, sizeof(buf));
	wSPRINTF(buf, "'\"peapver=%i\"'", setPEAP->peapVersion);
	mtk_set_network(ifname, network_id, "phase1", buf);
	/* phase 2 */
	wMEMSET(buf, 0, sizeof(buf));
	i = 0;
	while (setPEAP->innerEAP[i] != 0) {
		setPEAP->innerEAP[i] = toupper(setPEAP->innerEAP[i]);
		i++;
	}
	wSPRINTF(buf, "'\"auth=%s\"'", setPEAP->innerEAP);
	mtk_set_network(ifname, network_id, "phase2", buf);

	mtk_select_network(ifname, network_id);
#else
   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setPEAP->ssid);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap PEAP", ifname);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 anonymous_identity '\"anonymous\"' ", ifname);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setPEAP->username);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 password '\"%s\"'", ifname, setPEAP->passwd);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ca_cert '\"%s/%s\"'", ifname, CERTIFICATES_PATH, setPEAP->trustedRootCA);
   sret = system(gCmdStr);

   /* if this not set, default to set support all */
   //sprintf(gCmdStr, "wpa_cli -i %s set_network 0 pairwise '\"%s\"'", ifname, setPEAP->encrptype);
   //sret = system(gCmdStr);

   if(strcasecmp(setPEAP->keyMgmtType, "wpa2-sha256") == 0)
   {
      sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-SHA256", ifname);
   }
   else if(strcasecmp(setPEAP->keyMgmtType, "wpa2-eap") == 0)
   {
      sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   }
   else if(strcasecmp(setPEAP->keyMgmtType, "wpa2-ft") == 0)
   {
      sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-FT", ifname);
   }
   else if(strcasecmp(setPEAP->keyMgmtType, "wpa") == 0)
   {
      sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   }
   else if(strcasecmp(setPEAP->keyMgmtType, "wpa2") == 0)
   {
      // take all and device to pick one which is supported.
   }
   else
   {
      // ??
   }
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase1 '\"peaplabel=%i\"'", ifname, setPEAP->peapVersion);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase2 '\"auth=%s\"'", ifname, setPEAP->innerEAP);
   sret = system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
   sret = system(gCmdStr);
#endif

   setPeapResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PEAP_RESP_TLV, 4, (BYTE *)setPeapResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

/*
 * wfaStaSetUAPSD()
 *    This is to set
 *    1. acBE
 *    2. acBK
 *    3. acVI
 *    4. acVO
 */
int wfaStaSetUAPSD(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *setUAPSDResp = &gGenericResp;
#if 0 /* used for only one specific device, need to update to reflect yours */
   caStaSetUAPSD_t *setUAPSD = (caStaSetUAPSD_t *)caCmdBuf;
   char *ifname = setUAPSD->intf;
   char tmpStr[10];
   char line[100];
   char *pathl="/etc/Wireless/RT61STA";
   BYTE acBE=1;
   BYTE acBK=1;
   BYTE acVO=1;
   BYTE acVI=1;
   BYTE APSDCapable;
   FILE *pipe;

   /*
    * A series of setting need to be done before doing WMM-PS
    * Additional steps of configuration may be needed.
    */

   /*
    * bring down the interface
    */
   sprintf(gCmdStr, "ifconfig %s down",ifname);
   sret = system(gCmdStr);
   /*
    * Unload the Driver
    */
   sprintf(gCmdStr, "rmmod rt61");
   sret = system(gCmdStr);
#ifndef WFA_WMM_AC
   if(setUAPSD->acBE != 1)
     acBE=setUAPSD->acBE = 0;
   if(setUAPSD->acBK != 1)
     acBK=setUAPSD->acBK = 0;
   if(setUAPSD->acVO != 1)
     acVO=setUAPSD->acVO = 0;
   if(setUAPSD->acVI != 1)
     acVI=setUAPSD->acVI = 0;
#else
     acBE=setUAPSD->acBE;
     acBK=setUAPSD->acBK;
     acVO=setUAPSD->acVO;
     acVI=setUAPSD->acVI;
#endif

   APSDCapable = acBE||acBK||acVO||acVI;
   /*
    * set other AC parameters
    */

   sprintf(tmpStr,"%d;%d;%d;%d",setUAPSD->acBE,setUAPSD->acBK,setUAPSD->acVI,setUAPSD->acVO);
   sprintf(gCmdStr, "sed -e \"s/APSDCapable=.*/APSDCapable=%d/g\" -e \"s/APSDAC=.*/APSDAC=%s/g\" %s/rt61sta.dat >/tmp/wfa_tmp",APSDCapable,tmpStr,pathl);
   sret = system(gCmdStr);
   
   sprintf(gCmdStr, "mv /tmp/wfa_tmp %s/rt61sta.dat",pathl);
   sret = system(gCmdStr);
  pipe = popen("uname -r", "r");
  /* Read into line the output of uname*/
       fscanf(pipe,"%s",line);
       pclose(pipe);

   /*
    * load the Driver
    */
   sprintf(gCmdStr, "insmod /lib/modules/%s/extra/rt61.ko",line);
   sret = system(gCmdStr);
   
   sprintf(gCmdStr, "ifconfig %s up",ifname);
   sret = system(gCmdStr);
#endif

   setUAPSDResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_UAPSD_RESP_TLV, 4, (BYTE *)setUAPSDResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;
   return WFA_SUCCESS;
}

int wfaDeviceGetInfo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *dutCmd = (dutCommand_t *)caCmdBuf;
   caDevInfo_t *devInfo = &dutCmd->cmdsu.dev;
   dutCmdResponse_t *infoResp = &gGenericResp;
   /*a vendor can fill in the proper info or anything non-disclosure */
   caDeviceGetInfoResp_t dinfo = {"WFA Lab", "DemoUnit", WFA_SYSTEM_VER};

   DPRINT_INFO(WFA_OUT, "Entering wfaDeviceGetInfo ...\n");

   if(devInfo->fw == 0)
      memcpy(&infoResp->cmdru.devInfo, &dinfo, sizeof(caDeviceGetInfoResp_t));
   else
   {
      // Call internal API to pull the version ID */
      memcpy(infoResp->cmdru.devInfo.firmware, "NOVERSION", 15);
   }

   infoResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_DEVICE_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   return WFA_SUCCESS;

}

/*
 * This funciton is to retrieve a list of interfaces and return
 * the list back to Agent control.
 * ********************************************************************
 * Note: We intend to make this WLAN interface name as a hardcode name.
 * Therefore, for a particular device, you should know and change the name
 * for that device while doing porting. The MACRO "WFA_STAUT_IF" is defined in 
 * the file "inc/wfa_ca.h". If the device OS is not linux-like, this most 
 * likely is hardcoded just for CAPI command responses.
 * *******************************************************************
 * 
 */
int wfaDeviceListIF(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *infoResp = &gGenericResp;
   dutCommand_t *ifList = (dutCommand_t *)caCmdBuf;
   caDeviceListIFResp_t *ifListResp = &infoResp->cmdru.ifList;

   DPRINT_INFO(WFA_OUT, "Entering wfaDeviceListIF ...\n");
   
   switch(ifList->cmdsu.iftype)
   {
      case IF_80211:
      infoResp->status = STATUS_COMPLETE;
      ifListResp->iftype = IF_80211; 
      strcpy(ifListResp->ifs[0], WFA_STAUT_IF);
      strcpy(ifListResp->ifs[1], "NULL");
      strcpy(ifListResp->ifs[2], "NULL");
      break;
      case IF_ETH:
      infoResp->status = STATUS_COMPLETE;
      ifListResp->iftype = IF_ETH; 
      strcpy(ifListResp->ifs[0], "eth0");
      strcpy(ifListResp->ifs[1], "NULL");
      strcpy(ifListResp->ifs[2], "NULL");
      break;
      default:
      {
         infoResp->status = STATUS_ERROR;
         wfaEncodeTLV(WFA_DEVICE_LIST_IF_RESP_TLV, 4, (BYTE *)infoResp, respBuf);   
         *respLen = WFA_TLV_HDR_LEN + 4;

         return WFA_SUCCESS; 
      }
   }
   
   wfaEncodeTLV(WFA_DEVICE_LIST_IF_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   return WFA_SUCCESS;
}

int wfaStaDebugSet(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *debugResp = &gGenericResp;
   dutCommand_t *debugSet = (dutCommand_t *)caCmdBuf;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaDebugSet ...\n");

   if(debugSet->cmdsu.dbg.state == 1) /* enable */
      wfa_defined_debug |= debugSet->cmdsu.dbg.level;
   else
      wfa_defined_debug = (~debugSet->cmdsu.dbg.level & wfa_defined_debug);

   debugResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)debugResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);


   return WFA_SUCCESS;
}


/*
 *   wfaStaGetBSSID():
 *     This function is to retrieve BSSID of a specific wireless I/F.
 */ 
int wfaStaGetBSSID(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   char string[64]; 
   char *str;
   FILE *tmpfd;
   dutCmdResponse_t *bssidResp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaGetBSSID ...\n");
   /* retrieve the BSSID */
#ifdef MTK_11N_SIGMA
	struct network_status networkstatus;
	memset(&networkstatus, 0, sizeof(struct network_status));
	mtk_network_status("wlan0", &networkstatus);
	if (strncmp(networkstatus.wpa_state, "COMPLETED", 9) == 0) {
		strcpy(bssidResp->cmdru.bssid, networkstatus.bssid);
		bssidResp->status = STATUS_COMPLETE;
	} else {
		bssidResp->status = STATUS_COMPLETE;
		strcpy(bssidResp->cmdru.bssid, "00:00:00:00:00:00");
		mtk_printf("%s network not connected\n", __func__);
	}
#else

   sprintf(gCmdStr, "wpa_cli status > /tmp/bssid.txt");

   sret = system(gCmdStr);

   tmpfd = fopen("/tmp/bssid.txt", "r+");
   if(tmpfd == NULL)
   {
      bssidResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_GET_BSSID_RESP_TLV, 4, (BYTE *)bssidResp, respBuf);   
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return WFA_FAILURE;
   }

   for(;;)
   {
      if(fscanf(tmpfd, "%s", string) == EOF)
      {
         bssidResp->status = STATUS_COMPLETE; 
         strcpy(bssidResp->cmdru.bssid, "00:00:00:00:00:00");
         break; 
      }

      if(strncmp(string, "bssid", 5) == 0)
      {
         str = strtok(string, "=");
         str = strtok(NULL, "=");
         if(str != NULL)
         {
            strcpy(bssidResp->cmdru.bssid, str);
            bssidResp->status = STATUS_COMPLETE;
            break;
         }
      }
   }
#endif
   wfaEncodeTLV(WFA_STA_GET_BSSID_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)bssidResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

#if !defined(MTK_11N_SIGMA) && !defined(__CYGWIN__)
   fclose(tmpfd);
#endif
   return WFA_SUCCESS;
}

/*
 * wfaStaSetIBSS()
 *    This is to set
 *    1. ssid
 *    2. channel
 *    3. encrypType - none or wep
 *    optional
 *    4. key1
 *    5. key2
 *    6. key3
 *    7. key4
 *    8. activeIndex - 1, 2, 3, or 4
 */
int wfaStaSetIBSS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetIBSS_t *setIBSS = (caStaSetIBSS_t *)caCmdBuf;
   dutCmdResponse_t *setIbssResp = &gGenericResp;
   int i;

   /*
    * disable the network first
    */ 
   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", setIBSS->intf); 
   sret = system(gCmdStr);

   /*
    * set SSID
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", setIBSS->intf, setIBSS->ssid); 
   sret = system(gCmdStr);

   /*
    * Set channel for IBSS
    */
   sprintf(gCmdStr, "iwconfig %s channel %i", setIBSS->intf, setIBSS->channel);
   sret = system(gCmdStr);

   /*
    * Tell the supplicant for IBSS mode (1)
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 mode 1", setIBSS->intf);
   sret = system(gCmdStr);

   /*
    * set Key management to NONE (NO WPA) for plaintext or WEP
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt NONE", setIBSS->intf);
   sret = system(gCmdStr);

   if(setIBSS->encpType == 1)
   {
      for(i=0; i<4; i++)
      {
         if(strlen(setIBSS->keys[i]) ==5 || strlen(setIBSS->keys[i]) == 13)
         {
             sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_key%i \"%s\"", 
                setIBSS->intf, i, setIBSS->keys[i]);
             sret = system(gCmdStr);
         }
      } 

      i = setIBSS->activeKeyIdx;
      if(strlen(setIBSS->keys[i]) ==5 || strlen(setIBSS->keys[i]) == 13)
      {
         sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_tx_keyidx %i", 
            setIBSS->intf, setIBSS->activeKeyIdx);
         sret = system(gCmdStr);
      }
   }

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", setIBSS->intf);
   sret = system(gCmdStr);

   setIbssResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_IBSS_RESP_TLV, 4, (BYTE *)setIbssResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

/*
 *  wfaSetMode():
 *  The function is to set the wireless interface with a given mode (possible 
 *  adhoc)
 *  Input parameters:
 *    1. I/F
 *    2. ssid
 *    3. mode adhoc or managed
 *    4. encType
 *    5. channel
 *    6. key(s)
 *    7. active  key
 */ 
int wfaStaSetMode(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetMode_t *setmode = (caStaSetMode_t *)caCmdBuf;
   dutCmdResponse_t *SetModeResp = &gGenericResp;
   int i;

   /*
    * bring down the interface
    */
   sprintf(gCmdStr, "ifconfig %s down",setmode->intf);
   sret = system(gCmdStr);

   /*
    * distroy the interface
    */
   sprintf(gCmdStr, "wlanconfig %s destroy",setmode->intf);
   sret = system(gCmdStr);


   /*
    * re-create the interface with the given mode
    */
   if(setmode->mode == 1)
        sprintf(gCmdStr, "wlanconfig %s create wlandev wifi0 wlanmode adhoc",setmode->intf);
   else
        sprintf(gCmdStr, "wlanconfig %s create wlandev wifi0 wlanmode managed",setmode->intf);

   sret = system(gCmdStr);
   if(setmode->encpType == ENCRYPT_WEP)
    {
      int j = setmode->activeKeyIdx;
      for(i=0; i<4; i++)
      {
         if(setmode->keys[i][0] != '\0')
         {
             sprintf(gCmdStr, "iwconfig  %s key  s:%s",
                   setmode->intf, setmode->keys[i]);
             sret = system(gCmdStr);
         }
      /* set active key */
         if(setmode->keys[j][0] != '\0')
             sprintf(gCmdStr, "iwconfig  %s key  s:%s",
                   setmode->intf, setmode->keys[j]);
         sret = system(gCmdStr);
      }

    }
   /*
    * Set channel for IBSS
    */
    if(setmode->channel)
    {
      sprintf(gCmdStr, "iwconfig %s channel %i", setmode->intf, setmode->channel);
      sret = system(gCmdStr);
    }


   /*
    * set SSID
    */
   sprintf(gCmdStr, "iwconfig %s essid %s", setmode->intf, setmode->ssid);
   sret = system(gCmdStr);

   /*
    * bring up the interface
    */
   sprintf(gCmdStr, "ifconfig %s up",setmode->intf);
   sret = system(gCmdStr);

   SetModeResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_MODE_RESP_TLV, 4, (BYTE *)SetModeResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

int wfaStaSetPwrSave(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetPwrSave_t *setps = (caStaSetPwrSave_t *)caCmdBuf;
   dutCmdResponse_t *SetPSResp = &gGenericResp;

   sprintf(gCmdStr, "iwconfig %s power %s", setps->intf, setps->mode);
   sret = system(gCmdStr);


   SetPSResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PWRSAVE_RESP_TLV, 4, (BYTE *)SetPSResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

int wfaStaUpload(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaUpload_t *upload = &((dutCommand_t *)caCmdBuf)->cmdsu.upload;
   dutCmdResponse_t *upLoadResp = &gGenericResp;
   caStaUploadResp_t *upld = &upLoadResp->cmdru.uld;
   
   if(upload->type == WFA_UPLOAD_VHSO_RPT)
   {
       int rbytes;
       /*
        * if asked for the first packet, always to open the file
        */
       if(upload->next == 1)
       {
          if(e2efp != NULL)
          {
              fclose(e2efp);
              e2efp = NULL;
          }

          e2efp = fopen(e2eResults, "r");
       }

       if(e2efp == NULL)
       {
           upLoadResp->status = STATUS_ERROR;
           wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, 4, (BYTE *)upLoadResp, respBuf);
           *respLen = WFA_TLV_HDR_LEN + 4;
           return WFA_FAILURE;
       }
        
       rbytes = fread(upld->bytes, 1, 256, e2efp); 

       if(rbytes < 256)  
       {
           /* 
            * this means no more bytes after this read
            */
           upld->seqnum = 0;
           fclose(e2efp);
           e2efp=NULL;
       }
       else
       { 
           upld->seqnum = upload->next;
       }

       upld->nbytes = rbytes;

       upLoadResp->status = STATUS_COMPLETE;
       wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)upLoadResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
   }
   else
   {
       upLoadResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, 4, (BYTE *)upLoadResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;
   }

   return WFA_SUCCESS;
}
/*
 * wfaStaSetWMM()
 *  TO be ported on a specific plaform for the DUT
 *  This is to set the WMM related parameters at the DUT.
 *  Currently the function is used for GROUPS WMM-AC and WMM general configuration for setting RTS Threshhold, Fragmentation threshold and wmm (ON/OFF)
 *  It is expected that this function will set all the WMM related parametrs for a particular GROUP .
 */
int wfaStaSetWMM(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
#ifdef WFA_WMM_AC
    caStaSetWMM_t *setwmm = (caStaSetWMM_t *)caCmdBuf;
    char *ifname = setwmm->intf;
    dutCmdResponse_t *setwmmResp = &gGenericResp;
    //IEEEtypes_WMM_TSPEC_t tspec;

    switch(setwmm->group)
    {
    case GROUP_WMMAC:
	if (setwmm->send_trig)
	{
	    int Sockfd;
	    struct sockaddr_in psToAddr;
	    unsigned int TxMsg[512];
         
            Sockfd = wfaCreateUDPSock(setwmm->dipaddr, 12346);
	    memset(&psToAddr, 0, sizeof(psToAddr));
	    psToAddr.sin_family = AF_INET;
	    psToAddr.sin_addr.s_addr = inet_addr(setwmm->dipaddr);
	    psToAddr.sin_port = htons(12346);


	    switch (setwmm->trig_ac)
	    {
	    case WMMAC_AC_VO:
	        wfaTGSetPrio(Sockfd, 7);
	        create_apts_msg(APTS_CK_VO, TxMsg, 0);
	        printf("\r\nSending AC_VO trigger packet\n");
	        break;

	    case WMMAC_AC_VI:
	        wfaTGSetPrio(Sockfd, 5);
	        create_apts_msg(APTS_CK_VI, TxMsg, 0);
	        printf("\r\nSending AC_VI trigger packet\n");
	        break;

	    case WMMAC_AC_BK:
	        wfaTGSetPrio(Sockfd, 2);
	        create_apts_msg(APTS_CK_BK, TxMsg, 0);
	        printf("\r\nSending AC_BK trigger packet\n");
	        break;

	    default:
            case WMMAC_AC_BE:
	        wfaTGSetPrio(Sockfd, 0);
	        create_apts_msg(APTS_CK_BE, TxMsg, 0);
	        printf("\r\nSending AC_BE trigger packet\n");
	        break;
            }

	    sendto(Sockfd, TxMsg, 256, 0, (struct sockaddr *)&psToAddr,
	           sizeof(struct sockaddr));
	    close(Sockfd);
	    usleep(1000000);
	} 
	else if (setwmm->action == WMMAC_ADDTS)
        {
	    //wmmtspec_t* pCmdTspec = &(setwmm->actions.addts.tspec);
            printf("ADDTS AC PARAMS: dialog id: %d, TID: %d, "
	           "DIRECTION: %d, PSB: %d, UP: %d, INFOACK: %d BURST SIZE DEF: %d"
		   "Fixed %d, MSDU Size: %d, Max MSDU Size %d, "
		   "MIN SERVICE INTERVAL: %d, MAX SERVICE INTERVAL: %d, "
		   "INACTIVITY: %d, SUSPENSION %d, SERVICE START TIME: %d, "
		   "MIN DATARATE: %d, MEAN DATA RATE: %d, PEAK DATA RATE: %d, "
	           "BURSTSIZE or MSDU Aggreg: %d, DELAY BOUND: %d, PHYRATE: %d, SPLUSBW: %f, "
		   "MEDIUM TIME: %d, ACCESSCAT: %d\n",
		   setwmm->actions.addts.dialog_token,
		   setwmm->actions.addts.tspec.tsinfo.TID,
		   setwmm->actions.addts.tspec.tsinfo.direction,
		   setwmm->actions.addts.tspec.tsinfo.PSB,
		   setwmm->actions.addts.tspec.tsinfo.UP,
		   setwmm->actions.addts.tspec.tsinfo.infoAck,
		   setwmm->actions.addts.tspec.tsinfo.bstSzDef,
		   setwmm->actions.addts.tspec.Fixed,
		   setwmm->actions.addts.tspec.size,
		   setwmm->actions.addts.tspec.maxsize,
		   setwmm->actions.addts.tspec.min_srvc,
		   setwmm->actions.addts.tspec.max_srvc,
		   setwmm->actions.addts.tspec.inactivity,
		   setwmm->actions.addts.tspec.suspension,
		   setwmm->actions.addts.tspec.srvc_strt_tim,
		   setwmm->actions.addts.tspec.mindatarate,
		   setwmm->actions.addts.tspec.meandatarate,
		   setwmm->actions.addts.tspec.peakdatarate,
		   setwmm->actions.addts.tspec.burstsize,
		   setwmm->actions.addts.tspec.delaybound,
		   setwmm->actions.addts.tspec.PHYrate,
		   setwmm->actions.addts.tspec.sba,
		   setwmm->actions.addts.tspec.medium_time,
		   setwmm->actions.addts.accesscat);

            // you should set your tspec here.

            sret = system(gCmdStr);
        }
        else if (setwmm->action == WMMAC_DELTS)
	{
             // send del tspec 
        }

        setwmmResp->status = STATUS_COMPLETE;
        break;

    case GROUP_WMMCONF:
        sprintf(gCmdStr, "iwconfig %s rts %d",
                ifname,setwmm->actions.config.rts_thr);

        sret = system(gCmdStr);
        sprintf(gCmdStr, "iwconfig %s frag %d",
                ifname,setwmm->actions.config.frag_thr);

        sret = system(gCmdStr);
        sprintf(gCmdStr, "iwpriv %s wmmcfg %d",
                ifname, setwmm->actions.config.wmm);

        sret = system(gCmdStr);
        setwmmResp->status = STATUS_COMPLETE;
        break;

    default:
        DPRINT_ERR(WFA_ERR, "The group %d is not supported\n",setwmm->group);
        setwmmResp->status = STATUS_ERROR;
        break;

    }

    wfaEncodeTLV(WFA_STA_SET_WMM_RESP_TLV, 4, (BYTE *)setwmmResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
#endif

    return WFA_SUCCESS;
}

int wfaStaSendNeigReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   //dutCommand_t *sendNeigReq = (dutCommand_t *)caCmdBuf;
   dutCmdResponse_t *sendNeigReqResp = &gGenericResp;

   /*
    *  run your device to send NEIGREQ
    */

   sendNeigReqResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SEND_NEIGREQ_RESP_TLV, 4, (BYTE *)sendNeigReqResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

int wfaStaSetEapFAST(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetEapFAST_t *setFAST= (caStaSetEapFAST_t *)caCmdBuf;
    char *ifname = setFAST->intf;
    dutCmdResponse_t *setEapFastResp = &gGenericResp;

#ifdef WFA_NEW_CLI_FORMAT
    sprintf(gCmdStr, "wfa_set_eapfast %s %s %s %s %s %s", ifname, setFAST->ssid, setFAST->username,
                                                          setFAST->passwd, setFAST->pacFileName,
                                                          setFAST->innerEAP);
    sret = system(gCmdStr);
#else

    sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
    sret = system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setFAST->ssid);
    sret = system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setFAST->username);
    sret = system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 password '\"%s\"'", ifname, setFAST->passwd);
    sret = system(gCmdStr);

    if(strcasecmp(setFAST->keyMgmtType, "wpa2-sha256") == 0)
    {
    }
    else if(strcasecmp(setFAST->keyMgmtType, "wpa2-eap") == 0)
    {
    }
    else if(strcasecmp(setFAST->keyMgmtType, "wpa2-ft") == 0)
    {
 
    }
    else if(strcasecmp(setFAST->keyMgmtType, "wpa") == 0)
    {
       sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
    }
    else if(strcasecmp(setFAST->keyMgmtType, "wpa2") == 0)
    {
      // take all and device to pick one which is supported.
    }
    else
    {
      // ??
    }
    sret = system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap FAST", ifname);
    sret = system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 pac_file '\"%s/%s\"'", ifname, CERTIFICATES_PATH,     setFAST->pacFileName);
    sret = system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 anonymous_identity '\"anonymous\"'", ifname);
    sret = system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase1 '\"fast_provisioning=1\"'", ifname);
    sret = system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase2 '\"auth=%s\"'", ifname,setFAST->innerEAP);
    sret = system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
    sret = system(gCmdStr);
#endif

    setEapFastResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_EAPFAST_RESP_TLV, 4, (BYTE *)setEapFastResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}

int wfaStaSetEapAKA(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetEapAKA_t *setAKA= (caStaSetEapAKA_t *)caCmdBuf;
    char *ifname = setAKA->intf;
    dutCmdResponse_t *setEapAkaResp = &gGenericResp;

#ifdef WFA_NEW_CLI_FORMAT
    sprintf(gCmdStr, "wfa_set_eapaka %s %s %s %s", ifname, setAKA->ssid, setAKA->username, setAKA->passwd);
    sret = system(gCmdStr);
#else
#ifdef MTK_11N_SIGMA
	char ssidbuf[64];
	char buf[512];
	int network_id = mtk_add_network(ifname);

	mtk_set_global(ifname, "external_sim", "0");

	memset(buf, 0, sizeof(buf));
	memset(ssidbuf, 0, sizeof(ssidbuf));
	mtk_parse_ssid(buf, sizeof(buf), setAKA->ssid, sizeof(ssidbuf));
	snprintf(ssidbuf, sizeof(ssidbuf), "\\\"%s\\\"", buf);
	mtk_set_network(ifname, network_id, "ssid", ssidbuf);

	memset(buf, 0, sizeof(buf));
	snprintf(buf, sizeof(buf), "\\\"%s\\\"", setAKA->username);
	mtk_set_network(ifname, network_id, "imsi", buf);

	mtk_set_network(ifname, network_id, "identity", buf);

	memset(buf, 0, sizeof(buf));
	snprintf(buf, sizeof(buf), "\\\"%s\\\"", setAKA->passwd);

	mtk_set_network(ifname, network_id, "password", buf);

	/* sim_slot should be -1 if using milenage */
	mtk_set_network(ifname, network_id, "sim_slot", "\\\"-1\\\"");
	
	/* password for milenage should set in property */
	memset(buf, 0, sizeof(buf));
	snprintf(buf, sizeof(buf), "setprop wlan.softsim.sim %s", setAKA->passwd);
	system(buf);
	memset(buf, 0, sizeof(buf));
	if (strstr(setAKA->encrptype, "ccmp"))
		strcat(buf, "CCMP");
	if (strstr(setAKA->encrptype, "tkip"))
		strcat(buf, " TKIP");
	if (buf[0] == 0) {
		DPRINT_INFO(WFA_OUT, "no pairwise cipher is set, default set to CCMP TKIP\n");
		strcpy(buf, "CCMP TKIP");
	}
	DPRINT_INFO(WFA_OUT, "buf %s\n", buf);
	mtk_set_network(ifname, network_id, "pairwise", buf);
	if (setAKA->username[0] == '6')
		mtk_set_network(ifname, network_id, "eap", "\"AKA'\"");
	else
		mtk_set_network(ifname, network_id, "eap", "AKA");

	mtk_set_network(ifname, network_id, "proto", "RSN WPA");
	mtk_set_network(ifname, network_id, "key_mgmt", "WPA-EAP");

	mtk_select_network(ifname, network_id);
#else
    sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
    sret = system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setAKA->ssid);
    sret = system(gCmdStr);

    if(strcasecmp(setAKA->keyMgmtType, "wpa2-sha256") == 0)
    {
    }
    else if(strcasecmp(setAKA->keyMgmtType, "wpa2-eap") == 0)
    {
    }
    else if(strcasecmp(setAKA->keyMgmtType, "wpa2-ft") == 0)
    {
 
    }
    else if(strcasecmp(setAKA->keyMgmtType, "wpa") == 0)
    {
       sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
    }
    else if(strcasecmp(setAKA->keyMgmtType, "wpa2") == 0)
    {
      // take all and device to pick one which is supported.
    }
    else
    {
       // ??
    }
    sret = system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA2", ifname);
    sret = system(gCmdStr);
    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 proto CCMP", ifname);
    sret = system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap AKA", ifname);
    sret = system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase1 \"result_ind=1\"", ifname);
    sret = system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setAKA->username);
    sret = system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 password '\"%s\"'", ifname, setAKA->passwd);
    sret = system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
    sret = system(gCmdStr);
#endif
#endif

    setEapAkaResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_EAPAKA_RESP_TLV, 4, (BYTE *)setEapAkaResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
error:
	setEapAkaResp->status = STATUS_ERROR;
    wfaEncodeTLV(WFA_STA_SET_EAPAKA_RESP_TLV, 4, (BYTE *)setEapAkaResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}

int wfaStaSetSystime(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetSystime_t *systime = (caStaSetSystime_t *)caCmdBuf;
    dutCmdResponse_t *setSystimeResp = &gGenericResp;

    DPRINT_INFO(WFA_OUT, "Entering wfaStaSetSystime ...\n");

#ifdef MTK_11N_SIGMA
    sprintf(gCmdStr, BIN_PATH"busybox date %d.%d.%d-%d:%d:%d",
	    systime->year,systime->month,systime->date,systime->hours,systime->minutes,systime->seconds);
    sret = system(gCmdStr);

    setSystimeResp->status = STATUS_COMPLETE;
#endif

    wfaEncodeTLV(WFA_STA_SET_SYSTIME_RESP_TLV, 4, (BYTE *)setSystimeResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}

#ifdef WFA_STA_TB
int wfaStaPresetParams(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *PresetParamsResp = &gGenericResp;
   caStaPresetParameters_t *presetParams = (caStaPresetParameters_t *)caCmdBuf;
   //int ret;
   //char *intfname = presetParams->intf;
   BYTE presetDone = 1;
   int st = 0;

   DPRINT_INFO(WFA_OUT, "Inside wfaStaPresetParameters function ...\n");

   if(presetParams->wmmFlag)
   {
      st = wfaExecuteCLI(gCmdStr);
      switch(st)
      {
         case 0:
         presetDone = 1;
         break;
         case 1:
         presetDone = 0;
         break;
         case 2:
         presetDone = 0;
         break;
      }
   }

   if(presetParams->modeFlag != 0)
   {
      switch(presetParams->wirelessMode)
      {
         default:
         printf("other mode does not need to support\n");
      }

      st = wfaExecuteCLI(gCmdStr);
      switch(st)
      {
         case 0:
         presetDone = 1;
         break;
         case 1:
         presetDone = 0;
         case 2:
         presetDone = 0;
         break;
      }
   }


   if(presetParams->psFlag)
   {

      printf("%s\n", gCmdStr);
      sret = system(gCmdStr);
   }

   /************the followings are used for Voice Enterprise **************/
   if(presetParams->program == PROG_TYPE_VENT)
   {
      if(presetParams->ftoa == eEnable)
      {
      // enable Fast BSS Transition Over the Air
      }
      else
      {
	  // disable Fast BSS Transition Over the Air
      }

      if(presetParams->ftds == eEnable)
      {
         // enable Fast BSS Transition Over the DS 
      }
      else
      {
         // disable Fast BSS Transition Over the DS 
      }

      if(presetParams->activescan == eEnable)
      {
	      // Enable Active Scan on STA 
      }
      else
      {
	      // disable Active Scan on STA 
      }
   }

   /************the followings are used for Wi-Fi Display *************/
   if(presetParams->program == PROG_TYPE_WFD)
   {

      if(presetParams->tdlsFlag)
      {
      // enable / disable tdls based on tdls
      }
      if(presetParams->wfdDevTypeFlag)
      {
      // set WFD device type to source/sink/dual based on wfdDevType 
      }
      if(presetParams->wfdUibcGenFlag)
      {
      // enable / disable the feature
      }
      if(presetParams->wfdUibcHidFlag)
      {
      // enable / disable feature
      }
      if(presetParams->wfdUiInputFlag)
      {
      // set the UI input as mentioned
      }
      if(presetParams->wfdHdcpFlag)
      {
      // enable / disable feature
      }
      if(presetParams->wfdFrameSkipFlag)
      {
      // enable / disable feature
      }
      if(presetParams->wfdAvChangeFlag)
      {
      // enable / disable feature
      }
      if(presetParams->wfdStandByFlag)
      {
      // enable / disable feature
      }
      if(presetParams->wfdInVideoFlag)
      {
      // select the input vide as protecteed or non-protetcted or protected audio
      // or unprotected audio etc.
      }

      if(presetParams->wfdVideoFmatFlag)
      {
      // set the video format as requested
      
      //switch(presetParams->wfdVideoFmt )
      //{
          // case e640x480p60:
          //   ;
          // default:
          // set the mandatory	
      // }
      }
      if(presetParams->wfdAudioFmatFlag)
      {
      // set the Audio format as requested
	      
      //switch(presetParams->wfdAudioFmt )
      //{
      // case eMandatoryAudioMode:
      //	;
      // case eDefaultAudioMode:
      //  ;

      // default:
      // set the mandatory	
      // }
      }
	   
      if(presetParams->wfdI2cFlag)
      {
      // enable / disable feature
      }
      if(presetParams->wfdVideoRecoveryFlag)
      {
      // enable / disable feature
      }
      if(presetParams->wfdPrefDisplayFlag)
      {
      // enable / disable feature
      }
      if(presetParams->wfdServiceDiscoveryFlag)
      {
      // enable / disable feature
      }
      if(presetParams->wfd3dVideoFlag)
      {
      // enable / disable feature
      }
      if(presetParams->wfdMultiTxStreamFlag)
      {
      // enable / disable feature
      }
      if(presetParams->wfdTimeSyncFlag)
      {
      // enable / disable feature
      }
      if(presetParams->wfdEDIDFlag)
      {
      // enable / disable feature
      }
      if(presetParams->wfdUIBCPrepareFlag)
      {
      // Provdes information to start valid WFD session to check UIBC operation.
      }
      if(presetParams->wfdCoupledCapFlag)
      {
      // enable / disable feature
      }
      if(presetParams->wfdOptionalFeatureFlag)
      {
      // disable all program specific optional features
      }
      if(presetParams->wfdSessionAvailFlag)
      {
      // enable / disable session available bit 
      }
      if(presetParams->wfdDeviceDiscoverabilityFlag)
      {
      // enable / disable feature
      }
   }

   if (presetDone)
   {
      PresetParamsResp->status = STATUS_COMPLETE;
   }
   else
   {
      PresetParamsResp->status = STATUS_INVALID;
   }

   wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_RESP_TLV, 4, (BYTE *)PresetParamsResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

int wfaStaSet11n(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *v11nParamsResp = &gGenericResp;

    v11nParamsResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, 4, (BYTE *)v11nParamsResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    return WFA_SUCCESS;
}
int wfaStaSetWireless(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staWirelessResp = &gGenericResp;

    staWirelessResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_WIRELESS_RESP_TLV, 4, (BYTE *)staWirelessResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    return WFA_SUCCESS;
}

int wfaStaSendADDBA(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staSendADDBAResp = &gGenericResp;
#ifdef MTK_11N_SIGMA
    mtk_printf("Fix wfaStaSendADDBA not send status bug\n");
    staSendADDBAResp->status = STATUS_COMPLETE;
#endif
    wfaEncodeTLV(WFA_STA_SET_SEND_ADDBA_RESP_TLV, 4, (BYTE *)staSendADDBAResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    return WFA_SUCCESS;
}

int wfaStaSetRIFS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staSetRIFSResp = &gGenericResp;
#ifdef MTK_11N_SIGMA
    mtk_printf("Fix wfaStaSetRIFS not send status bug\n");
    staSetRIFSResp->status = STATUS_COMPLETE;
#endif
    wfaEncodeTLV(WFA_STA_SET_RIFS_TEST_RESP_TLV, 4, (BYTE *)staSetRIFSResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}

int wfaStaSendCoExistMGMT(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staSendMGMTResp = &gGenericResp;
#ifdef MTK_11N_SIGMA
    mtk_printf("Fix wfaStaSendCoExistMGMT not send status bug\n");
    staSendMGMTResp->status = STATUS_COMPLETE;
#endif
    wfaEncodeTLV(WFA_STA_SEND_COEXIST_MGMT_RESP_TLV, 4, (BYTE *)staSendMGMTResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;

}

int wfaStaResetDefault(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaResetDefault_t *reset = (caStaResetDefault_t *)caCmdBuf;
   dutCmdResponse_t *ResetResp = &gGenericResp;


   // need to make your own command available for this, here is only an example
   //sprintf(gCmdStr, "myresetdefault %s program %s", reset->intf, reset->prog);
   //sret = system(gCmdStr);
   sprintf(gCmdStr, "wpa_cli -i %s -p %s remove_network all", WFA_STAUT_IF, WPA_SUPPLICANT_SOCKET_PATH);
   system(gCmdStr);
   printf("  system: %s \n",gCmdStr);
   
   sprintf(gCmdStr, "wpa_cli -i %s -p %s add_network", WFA_STAUT_IF, WPA_SUPPLICANT_SOCKET_PATH);
   system(gCmdStr);
   printf("  system: %s \n",gCmdStr);
   
   sprintf(gCmdStr, "wpa_cli -i %s -p %s disconnect", WFA_STAUT_IF, WPA_SUPPLICANT_SOCKET_PATH);
   system(gCmdStr);
   printf("  system: %s \n",gCmdStr);

   ResetResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_RESET_DEFAULT_RESP_TLV, 4, (BYTE *)ResetResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

#else

int wfaStaTestBedCmd(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staCmdResp = &gGenericResp;

    wfaEncodeTLV(WFA_STA_DISCONNECT_RESP_TLV, 4, (BYTE *)staCmdResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}
#endif

/*
 * This is used to send a frame or action frame
 */
int wfaStaDevSendFrame(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *cmd = (dutCommand_t *)caCmdBuf;
   /* uncomment it if needed */
   // char *ifname = cmd->intf;
   dutCmdResponse_t *devSendResp = &gGenericResp;
   caStaDevSendFrame_t *sf = &cmd->cmdsu.sf;

   DPRINT_INFO(WFA_OUT, "Inside wfaStaDevSendFrame function ...\n");
   /* processing the frame */

   switch(sf->program)
   {
       case PROG_TYPE_PMF:
       {
          pmfFrame_t *pmf = &sf->frameType.pmf;
          switch(pmf->eFrameName)
          {
              case PMF_TYPE_DISASSOC:
              {
              /* use the protected to set what type of key to send */

              }
              break;
              case PMF_TYPE_DEAUTH:
              {

              }
              break;
              case PMF_TYPE_SAQUERY:
              {

              }
              break;
              case PMF_TYPE_AUTH:
              {
              }
              break;
              case PMF_TYPE_ASSOCREQ:
              {
              }
              break;
              case PMF_TYPE_REASSOCREQ:
              {
              }
              break;
          }
       }
       break;
       case PROG_TYPE_TDLS:
       {
          tdlsFrame_t *tdls = &sf->frameType.tdls;
          switch(tdls->eFrameName)
          {
              case TDLS_TYPE_DISCOVERY:
              /* use the peer mac address to send the frame */
              break;
              case TDLS_TYPE_SETUP:
              break;
              case TDLS_TYPE_TEARDOWN:
              break;
              case TDLS_TYPE_CHANNELSWITCH:
              break;
              case TDLS_TYPE_NULLFRAME:
              break;
          }
       }
       break;
       case PROG_TYPE_VENT:
       {
          ventFrame_t *vent = &sf->frameType.vent;
          switch(vent->type)
          {
              case VENT_TYPE_NEIGREQ:
              break;
              case VENT_TYPE_TRANSMGMT:
              break;
          }
       } 
       case PROG_TYPE_WFD:
       {
          wfdFrame_t *wfd = &sf->frameType.wfd;
          switch(wfd->eframe)
          {
              case WFD_FRAME_PRBREQ:
              {
                  /* send probe req */
              }
              break;

              case WFD_FRAME_PRBREQ_TDLS_REQ:
              {
                  /* send tunneled tdls probe req  */
              }
              break;

              case WFD_FRAME_11V_TIMING_MSR_REQ:
              {
                  /* send 11v timing mearurement request */
              }
              break;

              case WFD_FRAME_RTSP:
              {
                  /* send WFD RTSP messages*/
                  // fetch the type of RTSP message and send it.
                  switch(wfd->eRtspMsgType)
                  {
                      case WFD_RTSP_PAUSE:
                      break;
                      case WFD_RTSP_PLAY:
                      //send RTSP PLAY 
                      break;
		      case WFD_RTSP_TEARDOWN:
		      //send RTSP TEARDOWN 
		      break;
                      case WFD_RTSP_TRIG_PAUSE:
                      //send RTSP TRIGGER PAUSE
                      break;
                      case WFD_RTSP_TRIG_PLAY:
                      //send RTSP TRIGGER PLAY 
                      break;
                      case WFD_RTSP_TRIG_TEARDOWN:
                      //send RTSP TRIGGER TEARDOWN 
                      break;
                      case WFD_RTSP_SET_PARAMETER:
                      //send RTSP SET PARAMETER
                      if (wfd->eSetParams == WFD_CAP_UIBC_KEYBOARD)
                      {
                      //send RTSP SET PARAMETER message for UIBC keyboard						
                      }
                      if (wfd->eSetParams == WFD_CAP_UIBC_MOUSE)
                      {
                      //send RTSP SET PARAMETER message for UIBC Mouse						
                      }
                      else if (wfd->eSetParams == WFD_CAP_RE_NEGO)
                      {
                      //send RTSP SET PARAMETER message Capability re-negotiation						
                      }
                      else if (wfd->eSetParams == WFD_STANDBY)
                      {
                      //send RTSP SET PARAMETER message for standby						
                      }
                      else if (wfd->eSetParams == WFD_UIBC_SETTINGS_ENABLE)
                      {
                      //send RTSP SET PARAMETER message for UIBC settings enable						
                      }
                      else if (wfd->eSetParams == WFD_UIBC_SETTINGS_DISABLE)
                      {
                      //send RTSP SET PARAMETER message for UIBC settings disable						
                      }						
                      else if (wfd->eSetParams == WFD_ROUTE_AUDIO)
                      {
                      //send RTSP SET PARAMETER message for route audio 					
                      }						
                      else if (wfd->eSetParams == WFD_3D_VIDEOPARAM)
                      {
                      //send RTSP SET PARAMETER message for 3D video parameters						
                      }						
                      else if (wfd->eSetParams == WFD_2D_VIDEOPARAM)
                      {
                      //send RTSP SET PARAMETER message for 2D video parameters						
                      }						
                      break;
                  }
              }
              break;
          }
       } 
       case PROG_TYPE_GEN:
       {
          /* General frames */
       } 
	   
	   
   }
   devSendResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_DEV_SEND_FRAME_RESP_TLV, 4, (BYTE *)devSendResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

/*
 * This is used to set a temporary MAC address of an interface
 */
int wfaStaSetMacAddr(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   // Uncomment it if needed
   //dutCommand_t *cmd = (dutCommand_t *)caCmdBuf;
   // char *ifname = cmd->intf;
   dutCmdResponse_t *staCmdResp = &gGenericResp;
   // Uncomment it if needed
   //char *macaddr = &cmd->cmdsu.macaddr[0];

   wfaEncodeTLV(WFA_STA_SET_MAC_ADDRESS_RESP_TLV, 4, (BYTE *)staCmdResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}


int wfaStaDisconnect(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    //dutCommand_t *disc = (dutCommand_t *)caCmdBuf;
    //char *intf = disc->intf;
    dutCmdResponse_t *staDiscResp = &gGenericResp;

    // stop the supplicant
#ifdef MTK_11N_SIGMA
	/*
	* remove this due to UCC won't guantee that it will
	* set network parameters after issue disconnect
	* mtk_remove_network("wlan0", REMOVE_ALL, 0);
	*/
	mtk_disconnect("wlan0");
#endif
    staDiscResp->status = STATUS_COMPLETE;

    wfaEncodeTLV(WFA_STA_DISCONNECT_RESP_TLV, 4, (BYTE *)staDiscResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}

/* Execute CLI, read the status from Environment variable */
int wfaExecuteCLI(char *CLI)
{
   char *retstr;

   sret = system(CLI);

   retstr = getenv("WFA_CLI_STATUS");
   printf("cli status %s\n", retstr);
   return atoi(retstr);
}

/* Supporting Functions */

void wfaSendPing(tgPingStart_t *staPing, float *interval, int streamid)
{
    int totalpkts;
    char cmdStr[256];
//    char *addr = staPing->dipaddr;
#ifdef WFA_PC_CONSOLE
    char addr[40];
    char bflag[] = "-b";
    char *tmpstr;
    int inum=0;
#else
    char bflag[] = "  ";
#endif
    
#ifdef MTK_11N_SIGMA
	/* create pthread for ping */
	pthread_t pingPid;
	struct ping_status *p = NULL;
	int ret;
#endif
    totalpkts = (int)(staPing->duration * staPing->frameRate);
    
#ifdef WFA_PC_CONSOLE

    printf("\nCS : The Stream ID is %d",streamid);
    printf("\nCS :the addr is %s ",addr);
    strcpy(addr,staPing->dipaddr);
    printf("\nCS :Inside the WFA_PC_CONSLE BLOCK");
    printf("\nCS :the addr is %s ",addr);
    if (staPing->iptype == 2)
    {
        memset(bflag, 0, strlen(bflag));
    }
    else
    {
        tmpstr = strtok(addr, ".");
        inum = atoi(tmpstr);

        printf("interval %f\n", *interval);

        if(inum >= 224 && inum <= 239) // multicast
        {
        }
        else // if not MC, check if it is BC address
        {
            printf("\nCS :Inside the BC address BLOCK");
            printf("\nCS :the inum %d",inum);
            strtok(NULL, ".");
            //strtok(NULL, ".");
            tmpstr = strtok(NULL, ".");
            printf("tmpstr %s\n", tmpstr);
            inum = atoi(tmpstr);
            printf("\nCS : The string is %s",tmpstr);
            if(inum != 255)
            memset(bflag, 0, strlen(bflag));
        }
    }
#endif
#if !defined(MTK_11N_SIGMA) && !defined(__CYGWIN__)
    printf("\nCS : The Stream ID is %d",streamid);
    printf("IPtype : %i",staPing->iptype);
#elif defined (MTK_11N_SIGMA)
    mtk_printf("CS : The Stream ID is %d\n",streamid);
#endif

#if !defined(MTK_11N_SIGMA) && !defined(__CYGWIN__)
    if (staPing->iptype == 2)
    {    
#endif
#if !defined(MTK_11N_SIGMA) && !defined(__CYGWIN__)
	printf("%s we do not support ipv6 ping...\n", __func__);
#endif
#if !defined(MTK_11N_SIGMA) && !defined(__CYGWIN__)
        sprintf(cmdStr, "echo streamid=%i > /tmp/spout_%d.txt;wfaping6.sh %s %s -i %f -c %i -s %i -q >> /tmp/spout_%d.txt 2>/dev/null",
          streamid,streamid,bflag, staPing->dipaddr, *interval, totalpkts, staPing->frameSize,streamid);
        sret = system(cmdStr);
        printf("\nCS : The command string is %s",cmdStr);
#endif
#if !defined(MTK_11N_SIGMA) && !defined(__CYGWIN__)
    }
    else
    {
#endif
#ifdef MTK_11N_SIGMA
	p = get_pingstatus();
	if (p == NULL) {
		return;
	}

	/* 2>&1 forces the bash to redirect stderr to stdout   */
	snprintf(&p->pingcmd, 124, SIGMA_PING" %s -i %f -c %i -s %i %s 2>&1",
				bflag, *interval, totalpkts, staPing->frameSize,
				staPing->dipaddr);
	p->streamid = streamid;
	mtk_printf("%s Creating pthread for ping\n", __func__);
	mtk_printf("%s Ping cmd: %s streamid: %d\n",
			__func__, p->pingcmd, p->streamid);
	ret = pthread_create(&p->ppid, NULL, start_ping_child, p);
	if (ret == 0) {
		mtk_printf("%s Create pthread for ping success, pthread_id:0x%x\n", __func__, p->ppid);
	} else {
		mtk_printf("%s Create pthread for ping failed, ret:%d\n", __func__, ret);
	}

#else
        sprintf(cmdStr, "echo streamid=%i > /tmp/spout_%d.txt;wfaping.sh %s %s -i %f -c %i -s %i -q >> /tmp/spout_%d.txt 2>/dev/null",
          streamid,streamid,bflag, staPing->dipaddr, *interval, totalpkts, staPing->frameSize,streamid);
        sret = system(cmdStr);
        printf("\nCS : The command string is %s",cmdStr);
#endif
#if !defined(MTK_11N_SIGMA) && !defined(__CYGWIN__)
    }    
#endif
#if !defined(MTK_11N_SIGMA) && !defined(__CYGWIN__)
    sprintf(cmdStr, "updatepid.sh /tmp/spout_%d.txt",streamid);
    sret = system(cmdStr);
    printf("\nCS : The command string is %s",cmdStr);
#endif
}

int wfaStopPing(dutCmdResponse_t *stpResp, int streamid)
{
    char strout[256];
    FILE *tmpfile = NULL;
    char cmdStr[128];

#ifdef MTK_11N_SIGMA
	struct ping_status *p = NULL;
	int ret;
#endif

    printf("Ping stop id %d\n", streamid);
#ifdef MTK_11N_SIGMA
	p = find_pingstatus(streamid);
	if (p == NULL) {
		return WFA_ERROR;
	}

	p->exit_req = 1;
	mtk_printf("%s child ppid:0x%x, exit_req:%d\n", __func__, p->ppid, p->exit_req);
	while (p->exit_rsp == 0){
		mtk_printf("%s wait for ping thraed (0x%x) exit, exit_rsp:%d\n", __func__, p->ppid, p->exit_rsp);
		sleep(1);
	}

	mtk_printf("%s p->transmitted: %s\n", __func__, p->transmitted);
	mtk_printf("%s p->received: %s\n", __func__, p->received);
	mtk_printf("%s p->loss: %s\n", __func__, p->loss);

	stpResp->cmdru.pingStp.sendCnt = atoi(p->transmitted);
	stpResp->cmdru.pingStp.repliedCnt = atoi(p->received);
	put_pingstatus(p);
#else
    sprintf(cmdStr, "getpid.sh /tmp/spout_%d.txt /tmp/pid.txt",streamid);
    sret = system(cmdStr);

    printf("\nCS : The command string is %s",cmdStr);

    sret = system("stoping.sh /tmp/pid.txt ; sleep 2");

    sprintf(cmdStr, "getpstats.sh /tmp/spout_%d.txt",streamid);
    sret = system(cmdStr);

    printf("\nCS : The command string is %s",cmdStr);

    tmpfile = fopen("/tmp/stpsta.txt", "r+");

    if(tmpfile == NULL)
    {
        return WFA_FAILURE;
    }

    if(fscanf(tmpfile, "%s", strout) != EOF)
    {
        if(*strout == '\0')
        {
            stpResp->cmdru.pingStp.sendCnt = 0;
        }

        else
            stpResp->cmdru.pingStp.sendCnt = atoi(strout);
    }

    printf("after scan sent count %i\n", stpResp->cmdru.pingStp.sendCnt);


    if(fscanf(tmpfile, "%s", strout) != EOF)
    {
        if(*strout == '\0')
        {
            stpResp->cmdru.pingStp.repliedCnt = 0;
        }
        else
            stpResp->cmdru.pingStp.repliedCnt = atoi(strout);
    }
    printf("after scan replied count %i\n", stpResp->cmdru.pingStp.repliedCnt);

    fclose(tmpfile);
#endif

    return WFA_SUCCESS;
}

/*
 * wfaStaGetP2pDevAddress(): 
 */
int wfaStaGetP2pDevAddress(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* dutCommand_t *getInfo = (dutCommand_t *)caCmdBuf; */

   printf("\n Entry wfaStaGetP2pDevAddress... ");

   // Fetch the device ID and store into infoResp->cmdru.devid 
   //strcpy(infoResp->cmdru.devid, str);
   strcpy(&infoResp.cmdru.devid[0], "ABCDEFGH");
   
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_GET_DEV_ADDRESS_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}



/*
 * wfaStaSetP2p(): 
 */
int wfaStaSetP2p(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* caStaSetP2p_t *getStaSetP2p = (caStaSetP2p_t *)caCmdBuf; uncomment and use it*/

   printf("\n Entry wfaStaSetP2p... ");

   // Implement the function and this does not return any thing back.
   
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_SETP2P_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}
/*
 * wfaStaP2pConnect(): 
 */
int wfaStaP2pConnect(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* caStaP2pConnect_t *getStaP2pConnect = (caStaP2pConnect_t *)caCmdBuf; uncomment and use it */

   printf("\n Entry wfaStaP2pConnect... ");

   // Implement the function and does not return anything.

	
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_CONNECT_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}

/*
 * wfaStaStartAutoGo(): 
 */
int wfaStaStartAutoGo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   //caStaStartAutoGo_t *getStaStartAutoGo = (caStaStartAutoGo_t *)caCmdBuf;

   printf("\n Entry wfaStaStartAutoGo... ");

   // Fetch the group ID and store into 	infoResp->cmdru.grpid 
   strcpy(&infoResp.cmdru.grpid[0], "ABCDEFGH");
	
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_START_AUTO_GO_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}




/*
 * wfaStaP2pStartGrpFormation(): 
 */
int wfaStaP2pStartGrpFormation(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   //caStaP2pStartGrpForm_t *getStaP2pStartGrpForm = (caStaP2pStartGrpForm_t *)caCmdBuf;

   printf("\n Entry wfaStaP2pStartGrpFormation... ");

   // Fetch the device mode and put in 	infoResp->cmdru.p2presult 
   //strcpy(infoResp->cmdru.p2presult, "GO");

   // Fetch the device grp id and put in 	infoResp->cmdru.grpid 
   //strcpy(infoResp->cmdru.grpid, "AA:BB:CC:DD:EE:FF_DIRECT-SSID");

   strcpy(infoResp.cmdru.grpFormInfo.result, "CLIENT");
   strcpy(infoResp.cmdru.grpFormInfo.grpId, "AA:BB:CC:DD:EE:FF_DIRECT-SSID");

   
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_START_GRP_FORMATION_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}


/*
 * wfaStaP2pDissolve(): 
 */
int wfaStaP2pDissolve(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   //caStaP2pDissolve_t *getStap2pDissolve= (caStaP2pDissolve_t *)caCmdBuf;

   printf("\n Entry wfaStaP2pDissolve... ");

   // Implement the function and this does not return any thing back.
   
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_DISSOLVE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}

/*
 * wfaStaSendP2pInvReq(): 
 */
int wfaStaSendP2pInvReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* caStaSendP2pInvReq_t *getStaP2pInvReq= (caStaSendP2pInvReq_t *)caCmdBuf; */

   printf("\n Entry wfaStaSendP2pInvReq... ");

   // Implement the function and this does not return any thing back.
   
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_SEND_INV_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}


/*
 * wfaStaAcceptP2pInvReq(): 
 */
int wfaStaAcceptP2pInvReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* uncomment and use it
    * caStaAcceptP2pInvReq_t *getStaP2pInvReq= (caStaAcceptP2pInvReq_t *)caCmdBuf;
    */

   printf("\n Entry wfaStaAcceptP2pInvReq... ");

   // Implement the function and this does not return any thing back.
   
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_ACCEPT_INV_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}


/*
 * wfaStaSendP2pProvDisReq(): 
 */
int wfaStaSendP2pProvDisReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* uncomment and use it
    * caStaSendP2pProvDisReq_t *getStaP2pProvDisReq= (caStaSendP2pProvDisReq_t *)caCmdBuf;
    */

   printf("\n Entry wfaStaSendP2pProvDisReq... ");

   // Implement the function and this does not return any thing back.
   
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_SEND_PROV_DIS_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}

/*
 * wfaStaSetWpsPbc(): 
 */
int wfaStaSetWpsPbc(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* uncomment and use it 
    * caStaSetWpsPbc_t *getStaSetWpsPbc= (caStaSetWpsPbc_t *)caCmdBuf;
    */

   printf("\n Entry wfaStaSetWpsPbc... ");

   // Implement the function and this does not return any thing back.
   
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_WPS_SETWPS_PBC_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}

/*
 * wfaStaWpsReadPin(): 
 */
int wfaStaWpsReadPin(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* uncomment and use it 
    * caStaWpsReadPin_t *getStaWpsReadPin= (caStaWpsReadPin_t *)caCmdBuf;
    */

   printf("\n Entry wfaStaWpsReadPin... ");

   // Fetch the device PIN and put in 	infoResp->cmdru.wpsPin 
   //strcpy(infoResp->cmdru.wpsPin, "12345678");
   strcpy(&infoResp.cmdru.wpsPin[0], "1234456");

   
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_WPS_READ_PIN_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}



/*
 * wfaStaWpsReadLabel(): 
 */
int wfaStaWpsReadLabel(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;

   printf("\n Entry wfaStaWpsReadLabel... ");

   // Fetch the device Label and put in	infoResp->cmdru.wpsPin 
   //strcpy(infoResp->cmdru.wpsPin, "12345678");
   strcpy(&infoResp.cmdru.wpsPin[0], "1234456");

   
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_WPS_READ_PIN_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);	
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}


/*
 * wfaStaWpsEnterPin(): 
 */
int wfaStaWpsEnterPin(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* uncomment and use it 
    * caStaWpsEnterPin_t *getStaWpsEnterPin= (caStaWpsEnterPin_t *)caCmdBuf;
    */  

   printf("\n Entry wfaStaWpsEnterPin... ");

   // Implement the function and this does not return any thing back.

   
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_WPS_ENTER_PIN_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}


/*
 * wfaStaGetPsk(): 
 */
int wfaStaGetPsk(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* caStaGetPsk_t *getStaGetPsk= (caStaGetPsk_t *)caCmdBuf; uncomment and use it */

   printf("\n Entry wfaStaGetPsk... ");


   // Fetch the device PP and SSID  and put in 	infoResp->cmdru.pskInfo 
   //strcpy(infoResp->cmdru.wpsPin, "12345678");
   strcpy(&infoResp.cmdru.pskInfo.passPhrase[0], "1234456");
   strcpy(&infoResp.cmdru.pskInfo.ssid[0], "WIFI_DIRECT");	

   
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_GET_PSK_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}

/*
 * wfaStaP2pReset(): 
 */
int wfaStaP2pReset(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* dutCommand_t *getStaP2pReset= (dutCommand_t *)caCmdBuf; */

   printf("\n Entry wfaStaP2pReset... ");
   // Implement the function and this does not return any thing back.
   
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_RESET_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}



/*
 * wfaStaGetP2pIpConfig(): 
 */
int wfaStaGetP2pIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* caStaGetP2pIpConfig_t *staGetP2pIpConfig= (caStaGetP2pIpConfig_t *)caCmdBuf; */
   
   caStaGetIpConfigResp_t *ifinfo = &(infoResp.cmdru.getIfconfig);

   printf("\n Entry wfaStaGetP2pIpConfig... ");


   // Fetch the device IP config  and put in 	infoResp->cmdru 
   //strcpy(infoResp->cmdru.wpsPin, "12345678");
   ifinfo->isDhcp =0;
   strcpy(&(ifinfo->ipaddr[0]), "192.165.100.111");
   strcpy(&(ifinfo->mask[0]), "255.255.255.0");
   strcpy(&(ifinfo->dns[0][0]), "192.165.100.1");
   strcpy(&(ifinfo->mac[0]), "ba:ba:ba:ba:ba:ba");
	
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_GET_IP_CONFIG_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}




/*
 * wfaStaSendServiceDiscoveryReq(): 
 */
int wfaStaSendServiceDiscoveryReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   
   printf("\n Entry wfaStaSendServiceDiscoveryReq... ");
   // Implement the function and this does not return any thing back.

	
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_SEND_SERVICE_DISCOVERY_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}



/*
 * wfaStaSendP2pPresenceReq(): 
 */
int wfaStaSendP2pPresenceReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   //caStaSendP2pPresenceReq_t *staSendP2pPresenceReq= (caStaSendP2pPresenceReq_t *)caCmdBuf;
   
   //printf("\n Entry wfaStaSendP2pPresenceReq... ");
   //printf("\n The long long Duration: %lld... ",staSendP2pPresenceReq->duration);
   //printf("\n The long long interval : %lld.. ",staSendP2pPresenceReq->interval);

   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_SEND_PRESENCE_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}

/*
 * wfaStaSetSleepReq(): 
 */
int wfaStaSetSleepReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* caStaSetSleep_t *staSetSleepReq= (caStaSetSleep_t *)caCmdBuf; */
   
   printf("\n Entry wfaStaSetSleepReq... ");
   // Implement the function and this does not return any thing back.

	
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_SET_SLEEP_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN +4;

   return WFA_SUCCESS;
}

/*
 * wfaStaSetOpportunisticPsReq(): 
 */
int wfaStaSetOpportunisticPsReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* caStaSetOpprPs_t *staSetOpperPsReq= (caStaSetOpprPs_t *)caCmdBuf; uncomment and use it */
   
   printf("\n Entry wfaStaSetOpportunisticPsReq... ");
   // Implement the function and this does not return any thing back.

	
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_SET_OPPORTUNISTIC_PS_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}
#ifndef WFA_STA_TB
/*
 * wfaStaPresetParams(): 
 */

int wfaStaPresetParams(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;

   //caStaPresetParameters_t *presetParams = (caStaPresetParameters_t *)caCmdBuf;


   DPRINT_INFO(WFA_OUT, "Inside wfaStaPresetParameters function ...\n");

   // Implement the function and its sub commands 
   infoResp.status = STATUS_COMPLETE;

   wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_RESP_TLV, 4, (BYTE *)&infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}
int wfaStaSet11n(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf) 
{

    dutCmdResponse_t infoResp;
    dutCmdResponse_t *v11nParamsResp = &infoResp;

#ifdef WFA_11N_SUPPORT_ONLY
	
    caSta11n_t * v11nParams = (caSta11n_t *)caCmdBuf;

    int st =0; // SUCCESS
	
    DPRINT_INFO(WFA_OUT, "Inside wfaStaSet11n function....\n"); 

    if(v11nParams->addba_reject != 0xFF && v11nParams->addba_reject < 2)
    {
       // implement the funciton
       //st = wfaExecuteCLI(gCmdStr); 
       if(st != 0)
       {
            v11nParamsResp->status = STATUS_ERROR;
            strcpy(v11nParamsResp->cmdru.info, "set_addba_reject failed");
            wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
            *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
            return FALSE;
       }
    }
	
    if(v11nParams->ampdu != 0xFF && v11nParams->ampdu < 2)
    {
    // implement the funciton
    //st = wfaExecuteCLI(gCmdStr); 

        if(st != 0)
        {
            v11nParamsResp->status = STATUS_ERROR;
            strcpy(v11nParamsResp->cmdru.info, "set_ampdu failed");
            wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
            *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
            return FALSE;
        }
    }

    if(v11nParams->amsdu != 0xFF && v11nParams->amsdu < 2)
    {
    // implement the funciton
    //st = wfaExecuteCLI(gCmdStr); 
        if(st != 0)
        {
            v11nParamsResp->status = STATUS_ERROR;
            strcpy(v11nParamsResp->cmdru.info, "set_amsdu failed");
            wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
            *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
	    return FALSE;
        }
    }

    if(v11nParams->greenfield != 0xFF && v11nParams->greenfield < 2)
    {
        // implement the funciton
       //st = wfaExecuteCLI(gCmdStr); 
       if(st != 0)
       {
            v11nParamsResp->status = STATUS_ERROR;
            strcpy(v11nParamsResp->cmdru.info, "_set_greenfield failed");
            wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
            *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
            return FALSE;
       }
    }

    if(v11nParams->mcs32!= 0xFF && v11nParams->mcs32 < 2 && v11nParams->mcs_fixedrate[0] != '\0')
    {
     // implement the funciton
     //st = wfaExecuteCLI(gCmdStr); 
         if(st != 0)
         {
             v11nParamsResp->status = STATUS_ERROR;
             strcpy(v11nParamsResp->cmdru.info, "set_mcs failed");
             wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
             *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
             return FALSE;
         }
    } 
    else if (v11nParams->mcs32!= 0xFF && v11nParams->mcs32 < 2 && v11nParams->mcs_fixedrate[0] == '\0')
    {
        // implement the funciton
        //st = wfaExecuteCLI(gCmdStr); 
        if(st != 0)
        {
            v11nParamsResp->status = STATUS_ERROR;
            strcpy(v11nParamsResp->cmdru.info, "set_mcs32 failed");
	    wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
            return FALSE;
        }
    } 
    else if (v11nParams->mcs32 == 0xFF && v11nParams->mcs_fixedrate[0] != '\0')
    {
        // implement the funciton
        //st = wfaExecuteCLI(gCmdStr); 
        if(st != 0)
        {
            v11nParamsResp->status = STATUS_ERROR;
            strcpy(v11nParamsResp->cmdru.info, "set_mcs32 failed");
	    wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
            return FALSE;
        }
    }

    if(v11nParams->rifs_test != 0xFF && v11nParams->rifs_test < 2)
    {
        // implement the funciton
        //st = wfaExecuteCLI(gCmdStr); 
        if(st != 0)
        {
            v11nParamsResp->status = STATUS_ERROR;
            strcpy(v11nParamsResp->cmdru.info, "set_rifs_test failed");
	    wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
            return FALSE;
        }
    }

    if(v11nParams->sgi20 != 0xFF && v11nParams->sgi20 < 2)
    {
        // implement the funciton
        //st = wfaExecuteCLI(gCmdStr); 
        if(st != 0)
        {
            v11nParamsResp->status = STATUS_ERROR;
            strcpy(v11nParamsResp->cmdru.info, "set_sgi20 failed");
            wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
            *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
            return FALSE;
        }
    }

    if(v11nParams->smps != 0xFFFF)
    {
        if(v11nParams->smps == 0)
        {
           // implement the funciton
	   //st = wfaExecuteCLI(gCmdStr); 
	}
        else if(v11nParams->smps == 1)
        {
        // implement the funciton
        //st = wfaExecuteCLI(gCmdStr); 
            ;
        }		
        else if(v11nParams->smps == 2)
        {
        // implement the funciton
        //st = wfaExecuteCLI(gCmdStr); 
            ;		
        }
        if(st != 0)
        {
            v11nParamsResp->status = STATUS_ERROR;
            strcpy(v11nParamsResp->cmdru.info, "set_smps failed");
            wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
            *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
            return FALSE;
        }
    }

    if(v11nParams->stbc_rx != 0xFFFF)
    {
        // implement the funciton
        //st = wfaExecuteCLI(gCmdStr); 
        if(st != 0)
        {
            v11nParamsResp->status = STATUS_ERROR;
            strcpy(v11nParamsResp->cmdru.info, "set_stbc_rx failed");
	    wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
            return FALSE;
        }
    }
	
    if(v11nParams->width[0] != '\0')
    {
        // implement the funciton
        //st = wfaExecuteCLI(gCmdStr); 
        if(st != 0)
        {
            v11nParamsResp->status = STATUS_ERROR;
            strcpy(v11nParamsResp->cmdru.info, "set_11n_channel_width failed");
            wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
            *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
            return FALSE;
        }
    }
	
    if(v11nParams->_40_intolerant != 0xFF && v11nParams->_40_intolerant < 2)
    {
        // implement the funciton
        //st = wfaExecuteCLI(gCmdStr); 
        if(st != 0)
        {
            v11nParamsResp->status = STATUS_ERROR;
            strcpy(v11nParamsResp->cmdru.info, "set_40_intolerant failed");
            wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
            *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
            return FALSE;
        }
    }

    if(v11nParams->txsp_stream != 0 && v11nParams->txsp_stream <4)
    {
        // implement the funciton
        //st = wfaExecuteCLI(gCmdStr); 
        if(st != 0)
        {
            v11nParamsResp->status = STATUS_ERROR;
	    strcpy(v11nParamsResp->cmdru.info, "set_txsp_stream failed");
            wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
            *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
            return FALSE;
        }

    }

    if(v11nParams->rxsp_stream != 0 && v11nParams->rxsp_stream < 4)
    {
        // implement the funciton
        //st = wfaExecuteCLI(gCmdStr); 
        if(st != 0)
        {
            v11nParamsResp->status = STATUS_ERROR;
            strcpy(v11nParamsResp->cmdru.info, "set_rxsp_stream failed");
            wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
            *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
            return FALSE;
        }
    }

#endif

    v11nParamsResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, 4, (BYTE *)v11nParamsResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    return WFA_SUCCESS;
}
#endif
/*
 * wfaStaAddArpTableEntry(): 
 */
int wfaStaAddArpTableEntry(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* caStaAddARPTableEntry_t *staAddARPTableEntry= (caStaAddARPTableEntry_t *)caCmdBuf; uncomment and use it */
   
   printf("\n Entry wfastaAddARPTableEntry... ");
   // Implement the function and this does not return any thing back.

   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_ADD_ARP_TABLE_ENTRY_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}

/*
 * wfaStaBlockICMPResponse(): 
 */
int wfaStaBlockICMPResponse(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   /* caStaBlockICMPResponse_t *staAddARPTableEntry= (caStaBlockICMPResponse_t *)caCmdBuf; uncomment and use it */
   
   printf("\n Entry wfaStaBlockICMPResponse... ");
   // Implement the function and this does not return any thing back.

   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_BLOCK_ICMP_RESPONSE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}

/*
 * wfaStaSetRadio(): 
 */

int wfaStaSetRadio(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *setRadio = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *staCmdResp = &gGenericResp;
    caStaSetRadio_t *sr = &setRadio->cmdsu.sr;

    if(sr->mode == WFA_OFF)
    {
       // turn radio off
    }
    else
    {
       // always turn the radio on
    }

    staCmdResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_RADIO_RESP_TLV, 4, (BYTE *)staCmdResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}

/*
 * wfaStaSetRFeature(): 
 */

int wfaStaSetRFeature(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *dutCmd = (dutCommand_t *)caCmdBuf;
   caStaRFeat_t *rfeat = &dutCmd->cmdsu.rfeat;
   dutCmdResponse_t *caResp = &gGenericResp;

   if(strcasecmp(rfeat->prog, "tdls") == 0)
   {


   }

   caResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_RFEATURE_RESP_TLV, 4, (BYTE *)caResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}

/*
 * wfaStaStartWfdConnection(): 
 */	
int wfaStaStartWfdConnection(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   //caStaStartWfdConn_t *staStartWfdConn= (caStaStartWfdConn_t *)caCmdBuf; //uncomment and use it
	
   printf("\n Entry wfaStaStartWfdConnection... ");
	
	
   // Fetch the GrpId and WFD session and return
   strcpy(&infoResp.cmdru.wfdConnInfo.wfdSessionId[0], "1234567890");
   strcpy(&infoResp.cmdru.wfdConnInfo.p2pGrpId[0], "WIFI_DISPLAY"); 
   strcpy(&infoResp.cmdru.wfdConnInfo.result[0], "GO"); 

   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_START_WFD_CONNECTION_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);	
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	
   return WFA_SUCCESS;
}
/*
 * wfaStaCliCommand(): 
 */

int wfaStaCliCommand(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{

   char cmdName[32];
   char *pcmdStr=NULL, *str;
   int  st;
   char CmdStr[WFA_CMD_STR_SZ];
   FILE *wfaCliFd;
   char wfaCliBuff[64];
   char retstr[256];
   int CmdReturnFlag;
   char tmp[256];
   FILE * sh_pipe;
    
   caStaCliCmdResp_t infoResp;

   printf("\n Entry wfaStaCliCommand... ");

   printf("The command Received: %s",caCmdBuf);

   memcpy(cmdName, strtok_r((char *)caCmdBuf, ",", (char **)&pcmdStr), 32);

   sprintf(CmdStr, "%s",cmdName);

   for(;;)
   {
      str = strtok_r(NULL, ",", &pcmdStr);
      if(str == NULL || str[0] == '\0')
          break;
      else
      {
          sprintf(CmdStr, "%s /%s",CmdStr,str);
          str = strtok_r(NULL, ",", &pcmdStr);
          sprintf(CmdStr, "%s %s",CmdStr,str);
      }
   }

   CmdReturnFlag =0;
   // check the return process
   wfaCliFd=fopen("/etc/WfaEndpoint/wfa_cli.txt","r");
   if(wfaCliFd!= NULL)
   {
      while(fgets(wfaCliBuff, 64, wfaCliFd) != NULL)
      {
         //printf("\nLine read from CLI file : %s",wfaCliBuff);
         if(ferror(wfaCliFd))
            break;

         str=strtok(wfaCliBuff,"-");
         if(strcmp(str,cmdName) == 0)
         {
            str=strtok(NULL,",");
            if(strcmp(str,"TRUE") == 0)
               CmdReturnFlag =1;

            break;
         }
      }
      fclose(wfaCliFd);
   }


   //printf("\n Command Return Flag : %d",CmdReturnFlag);
   st = 1;
   memset(&retstr[0],'\0',255);
   memset(&tmp[0],'\0',255);

   sprintf(gCmdStr, "%s",  CmdStr);
   printf("\nCLI Command -- %s\n", gCmdStr);
    
   sh_pipe = popen(gCmdStr,"r");
    
   if(!sh_pipe)
   {
      printf ("Error in opening pipe");
   }


   //tmp_val=getdelim(&retstr,255,"\n",sh_pipe);
   if (fgets(&retstr[0], 255, sh_pipe) == NULL)
   {
      printf("Getting NULL string\n");
   }
    
   if(pclose(sh_pipe) != 0)
   {
      printf("Error in closing shell cmd pipe");
   }
   sleep(2);
    
   printf("CLI retun value- %s\n",retstr);

   memcpy(tmp, strtok_r((char *)retstr, "-", (char **)&pcmdStr), 2);
   printf("\ncli status - %s",tmp);
   if(strlen(tmp) > 0)
   st = atoi(tmp);

   infoResp.resFlag=CmdReturnFlag;
    
   switch(st)
   {
       case 0:
       infoResp.status = STATUS_COMPLETE;
       if (CmdReturnFlag)
       {
           str=strtok_r(NULL, "\n", (char **)&pcmdStr);
           strncpy(tmp,str, 255);
           printf("\nresult - %s",tmp);
           memset(&infoResp.result[0],'\0',WFA_CLI_CMD_RESP_LEN-1);			    
           strncpy(&infoResp.result[0], tmp,(strlen(tmp) < WFA_CLI_CMD_RESP_LEN ) ? strlen(tmp) : (WFA_CLI_CMD_RESP_LEN-1) );
           printf("Return CLI result to CA: %s****\n", &infoResp.result[0]);			
       }
       break;
       case 1:
       infoResp.status = STATUS_ERROR;
       break;
       case 2:
       infoResp.status = STATUS_INVALID;
       break;
   }

   wfaEncodeTLV(WFA_STA_CLI_CMD_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

    printf("\nExit from CLI function\n");    
   return TRUE;

	
}
/*
 * wfaStaConnectGoStartWfd(): 
 */

int wfaStaConnectGoStartWfd(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
//  caStaConnectGoStartWfd_t *staConnecGoStartWfd= (caStaConnectGoStartWfd_t *)caCmdBuf; //uncomment and use it
	
    printf("\n Entry wfaStaConnectGoStartWfd... ");

    // connect the specified GO and then establish the wfd session	
	
    // Fetch WFD session and return
    strcpy(&infoResp.cmdru.wfdConnInfo.wfdSessionId[0], "1234567890");

    infoResp.status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_CONNECT_GO_START_WFD_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);	
    *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	
    return WFA_SUCCESS;
}

/*
 * wfaStaGenerateEvent(): 
 */

int wfaStaGenerateEvent(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
    caStaGenEvent_t *staGenerateEvent= (caStaGenEvent_t *)caCmdBuf; //uncomment and use it
    caWfdStaGenEvent_t *wfdGenEvent;
	
    printf("\n Entry wfaStaGenerateEvent... ");


    // Geneate the specified action and return with complete/error.
    if(staGenerateEvent->program == PROG_TYPE_WFD)
    {
        wfdGenEvent = &staGenerateEvent->wfdEvent;
        if(wfdGenEvent ->type == eUibcGen)
        {
        } 
        else if(wfdGenEvent ->type == eUibcHid)
        {
        }		
        else if(wfdGenEvent ->type == eFrameSkip)
        {

        }
        else if(wfdGenEvent ->type == eI2cRead)
        {
        }
        else if(wfdGenEvent ->type == eI2cWrite)
        {
        }		
        else if(wfdGenEvent ->type == eInputContent)
        {
        }		
        else if(wfdGenEvent ->type == eIdrReq)
        {
        }		
    }
	
    infoResp.status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_GENERATE_EVENT_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);	
    *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	
    return WFA_SUCCESS;
}

	


/*
 * wfaStaReinvokeWfdSession(): 
 */

int wfaStaReinvokeWfdSession(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
//  caStaReinvokeWfdSession_t *staReinvokeSession= (caStaReinvokeWfdSession_t *)caCmdBuf; //uncomment and use it
	
    printf("\n Entry wfaStaReinvokeWfdSession... ");

    // Reinvoke the WFD session by accepting the p2p invitation   or sending p2p invitation
	

    infoResp.status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_REINVOKE_WFD_SESSION_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);	
    *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	
    return WFA_SUCCESS;
}


int wfaStaGetParameter(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaGetParameter_t *staGetParam= (caStaGetParameter_t *)caCmdBuf; //uncomment and use it


   caStaGetParameterResp_t *paramList = &infoResp.cmdru.getParamValue;
	
   printf("\n Entry wfaStaGetParameter... ");

   // Check the program type
   if(staGetParam->program == PROG_TYPE_WFD)
   {
      if(staGetParam->getParamValue == eDiscoveredDevList )
      {
          // Get the discovered devices, make space seperated list and return, check list is not bigger than 128 bytes.
          paramList->getParamType = eDiscoveredDevList;
          strcpy((char *)&paramList->devList, "11:22:33:44:55:66 22:33:44:55:66:77 33:44:55:66:77:88");
      }
   }


   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_GET_PARAMETER_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);	
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}

#define WFA_TIME_DIFF(before, after, rtime, dtime) \
             dtime = rtime + (after.tv_sec*1000000 + after.tv_usec) - (before.tv_sec*1000000 + before.tv_usec);

void suspend_time(int delay)
{
    struct timeval now, stop;
    int diff;
    int remain_time = 0;

    wGETTIMEOFDAY(&stop, 0);

    stop.tv_usec += delay;
    if(stop.tv_usec > 1000000)
    {
        stop.tv_usec -=1000000;
	stop.tv_sec +=1;
    }

    do
    {
        wGETTIMEOFDAY(&now, 0);
	WFA_TIME_DIFF(now, stop, remain_time, diff);
    } while(diff>0);
}

int wfaStaHs20StaScan(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	caStaScan_t *staScan= (caStaScan_t *)caCmdBuf;
	int j=0;
	char hessid_t[WFA_HS20_LEN_64] = " -h";
	char accs_net_type_t[WFA_HS20_LEN_64] = " -a";

	MTK_HS20_CMD("-i %s -p %s ap_scan 0 ", staScan->intf, WPA_SUPPLICANT_SOCKET_PATH);

	if((staScan->hessid[0] != '\0') || (staScan->accs_net_type[0] != '\0')) {
		MTK_HS20_CMD("-i %s -p/tmp/wpa_supplicant sta_add_scan_info%s%s\n",
			staScan->intf,
			(staScan->hessid[0] == '\0')?"":strcat(hessid_t,staScan->hessid),
			(staScan->accs_net_type[0] == '\0')?"":strcat(accs_net_type_t,staScan->accs_net_type)
			);
	}

	printf("Setting Scan Info");
	for(j=1; j<=5; j++){
		printf(".", j);
		suspend_time(1000000);
	}
	printf("\n");

	MTK_HS20_CMD("-i %s -p/tmp/wpa_supplicant ap_scan 1 ", staScan->intf);
	MTK_HS20_CMD("-i %s -p/tmp/wpa_supplicant scan", staScan->intf);

	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_HS20_STA_SCAN_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

	return WFA_SUCCESS;
}


